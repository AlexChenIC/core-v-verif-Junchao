# CV32E40Pæµ‹è¯•å¼€å‘å®æˆ˜æ‰‹å†Œ ğŸ› ï¸

> **æŒæ¡CV32E40På¹³å°æµ‹è¯•å¼€å‘çš„å®Œæ•´å·¥ä½œæµ**  
> ä»ç®€å•æµ‹è¯•ç¨‹åºåˆ°å¤æ‚UVMåºåˆ—çš„ç³»ç»ŸåŒ–å¼€å‘æŒ‡å—

---

## ğŸ“š æœ¬æ‰‹å†Œå†…å®¹æ¦‚è§ˆ

- ğŸ—ï¸ **æµ‹è¯•ç¨‹åºå¼€å‘** - C/Assemblyæµ‹è¯•ç¨‹åºçš„æ ‡å‡†å¼€å‘æµç¨‹
- ğŸ¯ **UVMåºåˆ—å¼€å‘** - è™šæ‹Ÿåºåˆ—ç¼–å†™å’Œé›†æˆæ–¹æ³•
- ğŸ”§ **æµ‹è¯•é…ç½®ç®¡ç†** - YAMLé…ç½®å’Œå‚æ•°åŒ–æŠ€å·§
- ğŸ“Š **çº¦æŸéšæœºåŒ–** - é«˜çº§çº¦æŸç¼–å†™å’Œè°ƒè¯•æŠ€å·§
- ğŸš€ **æ€§èƒ½ä¼˜åŒ–** - æµ‹è¯•æ‰§è¡Œæ•ˆç‡æå‡æ–¹æ³•

---

## ğŸ—ï¸ Part 1: æµ‹è¯•ç¨‹åºå¼€å‘å®æˆ˜

### ğŸ“ æ ‡å‡†æµ‹è¯•ç›®å½•ç»“æ„

æ¯ä¸ªæµ‹è¯•éƒ½éµå¾ªä»¥ä¸‹æ ‡å‡†ç»“æ„ï¼š

```
cv32e40p/tests/programs/custom/my_test/
â”œâ”€â”€ my_test.c              # ä¸»æµ‹è¯•ç¨‹åº
â”œâ”€â”€ test.yaml              # æµ‹è¯•é…ç½®æ–‡ä»¶
â”œâ”€â”€ Makefile               # ç¼–è¯‘é…ç½® (å¯é€‰)
â””â”€â”€ README.md              # æµ‹è¯•è¯´æ˜ (æ¨è)
```

### ğŸ”¨ åˆ›å»ºæ–°æµ‹è¯•çš„å®Œæ•´æµç¨‹

#### Step 1: åˆ›å»ºæµ‹è¯•ç›®å½•

```bash
# è®¾ç½®å·¥ä½œç›®å½•
cd $CORE_V_VERIF/cv32e40p/tests/programs/custom

# åˆ›å»ºæ–°æµ‹è¯•ç›®å½•
TEST_NAME="arithmetic_test"
mkdir $TEST_NAME
cd $TEST_NAME
```

#### Step 2: ç¼–å†™æµ‹è¯•ç¨‹åº

åˆ›å»º `arithmetic_test.c`:

```c
/*
 * arithmetic_test.c - ç®—æœ¯è¿ç®—åŠŸèƒ½æµ‹è¯•
 * 
 * æµ‹è¯•ç›®æ ‡:
 * - åŸºæœ¬ç®—æœ¯è¿ç®— (åŠ å‡ä¹˜é™¤)
 * - æº¢å‡ºæ£€æµ‹
 * - è¾¹ç•Œæ¡ä»¶å¤„ç†
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

// ğŸ”¹ æµ‹è¯•ç”¨ä¾‹ç»“æ„ä½“
typedef struct {
    int32_t a;
    int32_t b;
    int32_t expected_add;
    int32_t expected_sub;
    int32_t expected_mul;
    int32_t expected_div;
} test_case_t;

// ğŸ”¹ æµ‹è¯•æ•°æ®é›†
static const test_case_t test_cases[] = {
    // æ­£å¸¸æƒ…å†µ
    {100, 50, 150, 50, 5000, 2},
    {-100, 50, -50, -150, -5000, -2},
    {0, 100, 100, -100, 0, 0},
    
    // è¾¹ç•Œæƒ…å†µ
    {INT32_MAX, 1, INT32_MIN, INT32_MAX-1, -1, INT32_MAX},  // æº¢å‡ºæµ‹è¯•
    {INT32_MIN, -1, INT32_MAX, INT32_MIN+1, INT32_MIN, INT32_MIN},
    
    // é™¤é›¶ä¿æŠ¤ (éœ€è¦ç‰¹æ®Šå¤„ç†)
    {100, 0, 100, 100, 0, 0}  // é™¤æ•°ä¸º0çš„æƒ…å†µ
};

#define NUM_TEST_CASES (sizeof(test_cases) / sizeof(test_case_t))

// ğŸ”¹ å®‰å…¨é™¤æ³• (é¿å…é™¤é›¶)
static int32_t safe_divide(int32_t a, int32_t b) {
    if (b == 0) {
        printf("\tâš ï¸  é™¤é›¶æ£€æµ‹: %d / %d = 0 (ä¿æŠ¤å¤„ç†)\n", a, b);
        return 0;
    }
    return a / b;
}

// ğŸ”¹ æµ‹è¯•æ‰§è¡Œå‡½æ•°
static int run_arithmetic_tests(void) {
    int failed_count = 0;
    
    printf("ğŸ§® ç®—æœ¯è¿ç®—æµ‹è¯•å¼€å§‹ (å…±%dä¸ªæµ‹è¯•ç”¨ä¾‹)\n", NUM_TEST_CASES);
    printf("=" * 50 + "\n");
    
    for (int i = 0; i < NUM_TEST_CASES; i++) {
        const test_case_t *tc = &test_cases[i];
        printf("æµ‹è¯•ç”¨ä¾‹ %d: a=%d, b=%d\n", i+1, tc->a, tc->b);
        
        // ğŸ”¹ åŠ æ³•æµ‹è¯•
        int32_t add_result = tc->a + tc->b;
        if (add_result != tc->expected_add) {
            printf("\tâŒ åŠ æ³•å¤±è´¥: %d + %d = %d (æœŸæœ› %d)\n", 
                   tc->a, tc->b, add_result, tc->expected_add);
            failed_count++;
        } else {
            printf("\tâœ… åŠ æ³•é€šè¿‡: %d + %d = %d\n", tc->a, tc->b, add_result);
        }
        
        // ğŸ”¹ å‡æ³•æµ‹è¯•
        int32_t sub_result = tc->a - tc->b;
        if (sub_result != tc->expected_sub) {
            printf("\tâŒ å‡æ³•å¤±è´¥: %d - %d = %d (æœŸæœ› %d)\n", 
                   tc->a, tc->b, sub_result, tc->expected_sub);
            failed_count++;
        } else {
            printf("\tâœ… å‡æ³•é€šè¿‡: %d - %d = %d\n", tc->a, tc->b, sub_result);
        }
        
        // ğŸ”¹ ä¹˜æ³•æµ‹è¯•
        int32_t mul_result = tc->a * tc->b;
        if (mul_result != tc->expected_mul) {
            printf("\tâŒ ä¹˜æ³•å¤±è´¥: %d * %d = %d (æœŸæœ› %d)\n", 
                   tc->a, tc->b, mul_result, tc->expected_mul);
            failed_count++;
        } else {
            printf("\tâœ… ä¹˜æ³•é€šè¿‡: %d * %d = %d\n", tc->a, tc->b, mul_result);
        }
        
        // ğŸ”¹ é™¤æ³•æµ‹è¯• (å¸¦ä¿æŠ¤)
        int32_t div_result = safe_divide(tc->a, tc->b);
        if (div_result != tc->expected_div) {
            printf("\tâŒ é™¤æ³•å¤±è´¥: %d / %d = %d (æœŸæœ› %d)\n", 
                   tc->a, tc->b, div_result, tc->expected_div);
            failed_count++;
        } else {
            printf("\tâœ… é™¤æ³•é€šè¿‡: %d / %d = %d\n", tc->a, tc->b, div_result);
        }
        
        printf("\n");
    }
    
    return failed_count;
}

// ğŸ”¹ ä¸»å‡½æ•°
int main(int argc, char *argv[]) {
    printf("ğŸš€ CV32E40Pç®—æœ¯è¿ç®—æµ‹è¯•å¯åŠ¨\n");
    printf("æµ‹è¯•å¹³å°: OpenHW Group CV32E40P\n");
    printf("æµ‹è¯•æ—¶é—´: %s %s\n\n", __DATE__, __TIME__);
    
    int failed_count = run_arithmetic_tests();
    
    if (failed_count == 0) {
        printf("ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡! ç®—æœ¯è¿ç®—åŠŸèƒ½æ­£å¸¸\n");
        return EXIT_SUCCESS;
    } else {
        printf("ğŸ’¥ æµ‹è¯•å¤±è´¥! %dä¸ªæµ‹è¯•ç”¨ä¾‹æœªé€šè¿‡\n", failed_count);
        return EXIT_FAILURE;
    }
}
```

#### Step 3: åˆ›å»ºæµ‹è¯•é…ç½®

åˆ›å»º `test.yaml`:

```yaml
# arithmetic_test æµ‹è¯•é…ç½®
name: arithmetic_test

# UVMæµ‹è¯•ç±» - ä½¿ç”¨å›ºä»¶æµ‹è¯•åŸºç±»
uvm_test: uvmt_cv32e40p_firmware_test_c

# æµ‹è¯•æè¿°
description: >
    ç®—æœ¯è¿ç®—åŠŸèƒ½ç»¼åˆæµ‹è¯•ï¼ŒåŒ…æ‹¬ï¼š
    - åŸºæœ¬å››åˆ™è¿ç®— (åŠ å‡ä¹˜é™¤)  
    - æ•´æ•°æº¢å‡ºæ£€æµ‹
    - è¾¹ç•Œæ¡ä»¶å¤„ç†
    - é™¤é›¶ä¿æŠ¤æœºåˆ¶

# å¯é€‰é…ç½®
plusargs:
    - "+UVM_VERBOSITY=UVM_MEDIUM"
    - "+test_name=arithmetic_test"

# é¢„æœŸè¿è¡Œæ—¶é—´ (ç§’)  
expected_runtime: 30

# æµ‹è¯•ç±»åˆ«æ ‡ç­¾
tags:
    - arithmetic
    - basic_functionality  
    - regression
```

#### Step 4: è¿è¡Œå’ŒéªŒè¯æµ‹è¯•

```bash
# å›åˆ°UVMTç›®å½•
cd $CORE_V_VERIF/cv32e40p/sim/uvmt

# è¿è¡Œæ–°æµ‹è¯•
make test TEST=arithmetic_test

# éªŒè¯æµ‹è¯•ç»“æœ
grep -E "(TEST PASSED|TEST FAILED|EXIT)" cv32e40p_*.log
```

### ğŸ¨ é«˜çº§æµ‹è¯•ç¼–ç¨‹æŠ€å·§

#### ğŸ”§ CSR (æ§åˆ¶çŠ¶æ€å¯„å­˜å™¨) æ“ä½œ

```c
// CSRè¯»å†™å®å®šä¹‰
#define CSR_READ(csr_num, var) \
    __asm__ volatile("csrr %0, " #csr_num : "=r"(var))

#define CSR_WRITE(csr_num, val) \
    __asm__ volatile("csrw " #csr_num ", %0" :: "r"(val))

// å®é™…ä½¿ç”¨ç¤ºä¾‹
void test_csr_operations(void) {
    uint32_t mstatus_val;
    
    // è¯»å– MSTATUS CSR
    CSR_READ(0x300, mstatus_val);
    printf("MSTATUS = 0x%08x\n", mstatus_val);
    
    // è®¾ç½®æœºå™¨æ¨¡å¼ä¸­æ–­ä½¿èƒ½
    CSR_WRITE(0x300, mstatus_val | 0x8);
    
    // éªŒè¯å†™å…¥ç»“æœ
    CSR_READ(0x300, mstatus_val);
    printf("MSTATUS after write = 0x%08x\n", mstatus_val);
}
```

#### ğŸ¯ ä¸­æ–­å’Œå¼‚å¸¸æµ‹è¯•

```c
// ä¸­æ–­å¤„ç†å‡½æ•°
void __attribute__((interrupt)) timer_interrupt_handler(void) {
    printf("â° å®šæ—¶å™¨ä¸­æ–­è§¦å‘\n");
    // æ¸…é™¤ä¸­æ–­æ ‡å¿—
    // ... ä¸­æ–­å¤„ç†é€»è¾‘
}

// å¼‚å¸¸æµ‹è¯•å‡½æ•°
void test_exceptions(void) {
    printf("ğŸ”¥ æµ‹è¯•éæ³•æŒ‡ä»¤å¼‚å¸¸\n");
    
    // ä½¿ç”¨å†…è”æ±‡ç¼–äº§ç”Ÿéæ³•æŒ‡ä»¤
    __asm__ volatile(".word 0x00000000");  // éæ³•æŒ‡ä»¤
    
    // å¦‚æœåˆ°è¾¾è¿™é‡Œï¼Œè¯´æ˜å¼‚å¸¸å¤„ç†æœ‰é—®é¢˜
    printf("âŒ å¼‚å¸¸å¤„ç†å¤±è´¥\n");
}
```

#### ğŸ“Š æ€§èƒ½æµ‹è¯•æ¨¡æ¿

```c
// æ€§èƒ½è®¡æ•°å™¨è¯»å–
static inline uint64_t read_cycle_counter(void) {
    uint32_t cycle_low, cycle_high;
    CSR_READ(0xC00, cycle_low);   // CYCLE
    CSR_READ(0xC80, cycle_high);  // CYCLEH
    return ((uint64_t)cycle_high << 32) | cycle_low;
}

// æ€§èƒ½æµ‹è¯•æ¡†æ¶
typedef struct {
    const char *test_name;
    void (*test_func)(void);
    uint64_t max_cycles;  // é¢„æœŸæœ€å¤§å‘¨æœŸæ•°
} perf_test_t;

void run_performance_test(const perf_test_t *test) {
    printf("â±ï¸  æ€§èƒ½æµ‹è¯•: %s\n", test->test_name);
    
    uint64_t start_cycles = read_cycle_counter();
    test->test_func();
    uint64_t end_cycles = read_cycle_counter();
    
    uint64_t elapsed = end_cycles - start_cycles;
    printf("   æ‰§è¡Œå‘¨æœŸ: %llu (é¢„æœŸ â‰¤ %llu)\n", elapsed, test->max_cycles);
    
    if (elapsed <= test->max_cycles) {
        printf("   âœ… æ€§èƒ½è¾¾æ ‡\n");
    } else {
        printf("   âŒ æ€§èƒ½ä¸è¾¾æ ‡ (è¶…æ—¶ %llu å‘¨æœŸ)\n", elapsed - test->max_cycles);
    }
}
```

---

## ğŸ¯ Part 2: UVMåºåˆ—å¼€å‘å®æˆ˜

### ğŸ—ï¸ è™šæ‹Ÿåºåˆ—æ¶æ„

åŸºäºé¡¹ç›®å®é™…ç»“æ„ï¼Œåˆ›å»ºè‡ªå®šä¹‰è™šæ‹Ÿåºåˆ—ï¼š

#### ğŸ“ åˆ›å»ºåºåˆ—æ–‡ä»¶

```bash
# åœ¨UVMæµ‹è¯•ç›®å½•ä¸‹åˆ›å»ºåºåˆ—æ–‡ä»¶
cd $CORE_V_VERIF/cv32e40p/tests/uvmt/vseq

# åˆ›å»ºè‡ªå®šä¹‰åºåˆ—æ–‡ä»¶
touch uvmt_cv32e40p_custom_vseq.sv
```

#### ğŸ“ åºåˆ—åŸºç¡€æ¨¡æ¿

```systemverilog
// uvmt_cv32e40p_custom_vseq.sv - è‡ªå®šä¹‰è™šæ‹Ÿåºåˆ—æ¨¡æ¿

`ifndef __UVMT_CV32E40P_CUSTOM_VSEQ_SV__
`define __UVMT_CV32E40P_CUSTOM_VSEQ_SV__

/**
 * è‡ªå®šä¹‰è™šæ‹Ÿåºåˆ—åŸºç±»
 * æä¾›å¸¸ç”¨çš„åºåˆ—æ“ä½œå’Œå·¥å…·å‡½æ•°
 */
class uvmt_cv32e40p_custom_base_vseq_c extends uvmt_cv32e40p_base_vseq_c;
   
   `uvm_object_utils(uvmt_cv32e40p_custom_base_vseq_c)
   
   /**
    * æ„é€ å‡½æ•°
    */
   function new(string name="uvmt_cv32e40p_custom_base_vseq");
      super.new(name);
   endfunction
   
   /**
    * ğŸ”§ å¸¸ç”¨å·¥å…·å‡½æ•°ï¼šç­‰å¾…æ—¶é’Ÿå‘¨æœŸ
    */
   virtual task wait_clk_cycles(int num_cycles);
      repeat(num_cycles) @(posedge cntxt.clknrst_cntxt.vif.clk);
   endtask
   
   /**
    * ğŸ”§ å¸¸ç”¨å·¥å…·å‡½æ•°ï¼šç­‰å¾…å¤ä½å®Œæˆ
    */
   virtual task wait_reset_complete();
      wait(cntxt.clknrst_cntxt.vif.reset_n === 1'b1);
      wait_clk_cycles(5);  // å¤ä½åç¨³å®šç­‰å¾…
   endtask
   
   /**
    * ğŸ”§ å¸¸ç”¨å·¥å…·å‡½æ•°ï¼šè§¦å‘ä¸­æ–­
    */
   virtual task trigger_interrupt(int interrupt_id);
      if (cntxt.interrupt_cntxt.vif != null) begin
         cntxt.interrupt_cntxt.vif.irq[interrupt_id] = 1'b1;
         wait_clk_cycles(1);
         cntxt.interrupt_cntxt.vif.irq[interrupt_id] = 1'b0;
      end
   endtask
   
endclass

/**
 * ğŸ¯ å…·ä½“åº”ç”¨åºåˆ—ï¼šå­˜å‚¨å™¨å‹åŠ›æµ‹è¯•
 */
class uvmt_cv32e40p_memory_stress_vseq_c extends uvmt_cv32e40p_custom_base_vseq_c;
   
   `uvm_object_utils(uvmt_cv32e40p_memory_stress_vseq_c)
   
   // ğŸ”¹ åºåˆ—å‚æ•°
   rand int num_transactions;     // äº‹åŠ¡æ•°é‡
   rand int max_delay;           // æœ€å¤§å»¶è¿Ÿ
   rand bit enable_backpressure; // æ˜¯å¦å¯ç”¨èƒŒå‹
   
   // ğŸ”¹ çº¦æŸå®šä¹‰
   constraint reasonable_params {
      num_transactions inside {[10:1000]};
      max_delay inside {[0:50]};
   }
   
   function new(string name="uvmt_cv32e40p_memory_stress_vseq");
      super.new(name);
   endfunction
   
   /**
    * ğŸš€ ä¸»æ‰§è¡Œä»»åŠ¡
    */
   virtual task body();
      uvma_obi_memory_mstr_seq_item_c  mem_req;
      
      `uvm_info("VSEQ", $sformatf("å¼€å§‹å­˜å‚¨å™¨å‹åŠ›æµ‹è¯•: %0däº‹åŠ¡, æœ€å¤§å»¶è¿Ÿ%0d", 
                                 num_transactions, max_delay), UVM_MEDIUM)
      
      // ğŸ”¹ ç­‰å¾…å¤ä½å®Œæˆ
      wait_reset_complete();
      
      // ğŸ”¹ æ‰§è¡Œå­˜å‚¨å™¨äº‹åŠ¡
      for (int i = 0; i < num_transactions; i++) begin
         
         // åˆ›å»ºéšæœºå­˜å‚¨å™¨è®¿é—®
         `uvm_create(mem_req)
         
         if (!mem_req.randomize() with {
            access_type inside {UVMA_OBI_MEMORY_ACCESS_READ, UVMA_OBI_MEMORY_ACCESS_WRITE};
            address inside {[32'h1000_0000:32'h1FFF_FFFF]};  // æœ‰æ•ˆåœ°å€èŒƒå›´
         }) begin
            `uvm_fatal("VSEQ", "å­˜å‚¨å™¨è¯·æ±‚éšæœºåŒ–å¤±è´¥")
         end
         
         // ğŸ”¹ å¯é€‰å»¶è¿Ÿæ³¨å…¥
         if (max_delay > 0) begin
            int delay = $urandom_range(0, max_delay);
            wait_clk_cycles(delay);
         end
         
         // ğŸ”¹ å¯åŠ¨äº‹åŠ¡
         `uvm_send(mem_req)
         
         `uvm_info("VSEQ", $sformatf("å­˜å‚¨å™¨äº‹åŠ¡ %0d/%0d: %s @ 0x%08x", 
                                   i+1, num_transactions, 
                                   mem_req.access_type.name(),
                                   mem_req.address), UVM_HIGH)
      end
      
      `uvm_info("VSEQ", "å­˜å‚¨å™¨å‹åŠ›æµ‹è¯•å®Œæˆ", UVM_MEDIUM)
      
   endtask
   
endclass

/**
 * ğŸ¯ å…·ä½“åº”ç”¨åºåˆ—ï¼šè°ƒè¯•æ¥å£æµ‹è¯•
 */
class uvmt_cv32e40p_debug_test_vseq_c extends uvmt_cv32e40p_custom_base_vseq_c;
   
   `uvm_object_utils(uvmt_cv32e40p_debug_test_vseq_c)
   
   function new(string name="uvmt_cv32e40p_debug_test_vseq");
      super.new(name);
   endfunction
   
   virtual task body();
      
      `uvm_info("VSEQ", "å¼€å§‹è°ƒè¯•æ¥å£æµ‹è¯•", UVM_MEDIUM)
      
      // ğŸ”¹ ç­‰å¾…å¤ä½å®Œæˆ
      wait_reset_complete();
      
      // ğŸ”¹ è¿›å…¥è°ƒè¯•æ¨¡å¼
      fork
         begin
            // è§¦å‘è°ƒè¯•è¯·æ±‚
            if (cntxt.debug_cntxt.vif != null) begin
               cntxt.debug_cntxt.vif.debug_req = 1'b1;
               wait_clk_cycles(5);
               cntxt.debug_cntxt.vif.debug_req = 1'b0;
            end
         end
         begin
            // ç­‰å¾…è°ƒè¯•æ¨¡å¼ç¡®è®¤
            wait(cntxt.debug_cntxt.vif.debug_mode === 1'b1);
            `uvm_info("VSEQ", "æˆåŠŸè¿›å…¥è°ƒè¯•æ¨¡å¼", UVM_MEDIUM)
         end
      join
      
      // ğŸ”¹ æ‰§è¡Œè°ƒè¯•æ“ä½œ
      // ... è°ƒè¯•å¯„å­˜å™¨è®¿é—®ç­‰æ“ä½œ
      
      // ğŸ”¹ é€€å‡ºè°ƒè¯•æ¨¡å¼
      if (cntxt.debug_cntxt.vif != null) begin
         cntxt.debug_cntxt.vif.debug_resume_req = 1'b1;
         wait_clk_cycles(1);
         cntxt.debug_cntxt.vif.debug_resume_req = 1'b0;
      end
      
      wait(cntxt.debug_cntxt.vif.debug_mode === 1'b0);
      `uvm_info("VSEQ", "æˆåŠŸé€€å‡ºè°ƒè¯•æ¨¡å¼", UVM_MEDIUM)
      
   endtask
   
endclass

`endif // __UVMT_CV32E40P_CUSTOM_VSEQ_SV__
```

#### ğŸ”§ é›†æˆåºåˆ—åˆ°æµ‹è¯•

ä¿®æ”¹ `uvmt_cv32e40p_vseq_lib.sv`:

```systemverilog
function uvmt_cv32e40p_vseq_lib_c::new(string name="uvmt_cv32e40p_vseq_lib");
   
   super.new(name);
   init_sequence_library();
   
   // ğŸ”¹ æ·»åŠ è‡ªå®šä¹‰åºåˆ—
   add_sequence(uvmt_cv32e40p_memory_stress_vseq_c::get_type());
   add_sequence(uvmt_cv32e40p_debug_test_vseq_c::get_type());
   
endfunction : new
```

---

## ğŸ”§ Part 3: é«˜çº§æµ‹è¯•é…ç½®

### ğŸ“Š YAMLé…ç½®é«˜çº§æŠ€å·§

#### ğŸ¯ å‚æ•°åŒ–æµ‹è¯•é…ç½®

```yaml
# å‚æ•°åŒ–å­˜å‚¨å™¨æµ‹è¯•é…ç½®
name: memory_stress_parameterized

uvm_test: uvmt_cv32e40p_base_test_c

description: >
    å‚æ•°åŒ–å­˜å‚¨å™¨å‹åŠ›æµ‹è¯•ï¼Œæ”¯æŒä¸åŒè´Ÿè½½å¼ºåº¦

# ğŸ”¹ æµ‹è¯•å‚æ•°å®šä¹‰
parameters:
    num_transactions: 
        type: int
        default: 100
        range: [10, 10000]
        description: "å­˜å‚¨å™¨äº‹åŠ¡æ•°é‡"
    
    max_delay:
        type: int  
        default: 10
        range: [0, 100]
        description: "æœ€å¤§å»¶è¿Ÿå‘¨æœŸæ•°"
    
    enable_backpressure:
        type: bool
        default: false
        description: "æ˜¯å¦å¯ç”¨å­˜å‚¨å™¨èƒŒå‹"

# ğŸ”¹ è¿è¡Œæ—¶å‚æ•°ä¼ é€’
plusargs:
    - "+num_transactions=${num_transactions}"
    - "+max_delay=${max_delay}"
    - "+enable_backpressure=${enable_backpressure}"
    - "+UVM_VERBOSITY=UVM_MEDIUM"

# ğŸ”¹ é¢„å®šä¹‰æµ‹è¯•åœºæ™¯
scenarios:
    light_load:
        num_transactions: 50
        max_delay: 5
        enable_backpressure: false
        
    normal_load:
        num_transactions: 500
        max_delay: 20
        enable_backpressure: true
        
    heavy_load:
        num_transactions: 2000
        max_delay: 50
        enable_backpressure: true

# ğŸ”¹ è¦†ç›–ç‡é…ç½®
coverage:
    functional: true
    line: true
    toggle: true
    
# ğŸ”¹ é¢„æœŸç»“æœ
expected_results:
    exit_code: 0
    runtime_limit: 300  # 5åˆ†é’Ÿè¶…æ—¶
    required_coverage: 90  # æœ€å°è¦†ç›–ç‡
```

#### ğŸš€ è¿è¡Œå‚æ•°åŒ–æµ‹è¯•

```bash
# è¿è¡Œé»˜è®¤é…ç½®
make test TEST=memory_stress_parameterized

# è¿è¡Œç‰¹å®šåœºæ™¯
make test TEST=memory_stress_parameterized SCENARIO=heavy_load

# è¿è¡Œè‡ªå®šä¹‰å‚æ•°
make test TEST=memory_stress_parameterized \
     USER_RUN_FLAGS="+num_transactions=1000 +max_delay=25"
```

### ğŸ¨ çº¦æŸéšæœºåŒ–é«˜çº§æŠ€å·§

#### ğŸ”§ SystemVerilogçº¦æŸç¤ºä¾‹

```systemverilog
/**
 * ğŸ¯ é«˜çº§çº¦æŸéšæœºåŒ–ç¤ºä¾‹
 */
class advanced_constraint_example;
   
   // ğŸ”¹ åŸºæœ¬éšæœºå˜é‡
   rand bit [31:0] address;
   rand bit [31:0] data;
   rand int        size;
   rand bit        is_write;
   
   // ğŸ”¹ åœ°å€å¯¹é½çº¦æŸ
   constraint addr_alignment {
      if (size == 4) address[1:0] == 2'b00;      // å­—å¯¹é½
      else if (size == 2) address[0] == 1'b0;     // åŠå­—å¯¹é½
      // å­—èŠ‚è®¿é—®æ— å¯¹é½è¦æ±‚
   }
   
   // ğŸ”¹ åœ°å€èŒƒå›´çº¦æŸ
   constraint addr_range {
      address inside {
         [32'h0000_0000:32'h0000_FFFF],  // ROMåŒºåŸŸ
         [32'h2000_0000:32'h2FFF_FFFF],  // RAMåŒºåŸŸ  
         [32'h4000_0000:32'h4FFF_FFFF]   // å¤–è®¾åŒºåŸŸ
      };
   }
   
   // ğŸ”¹ æ•°æ®æ¨¡å¼çº¦æŸ  
   constraint data_patterns {
      data dist {
         32'h0000_0000 := 5,          // é›¶å€¼ (5% æ¦‚ç‡)
         32'hFFFF_FFFF := 5,          // å…¨1 (5% æ¦‚ç‡)
         [32'h0000_0001:32'hFFFF_FFFE] := 90  // å…¶ä»–å€¼ (90% æ¦‚ç‡)
      };
   }
   
   // ğŸ”¹ å¤§å°çº¦æŸ
   constraint size_constraint {
      size inside {1, 2, 4};  // åªæ”¯æŒå­—èŠ‚ã€åŠå­—ã€å­—è®¿é—®
   }
   
   // ğŸ”¹ è¯»å†™æ¯”ä¾‹çº¦æŸ
   constraint rw_ratio {
      is_write dist {1'b0 := 70, 1'b1 := 30};  // 70%è¯», 30%å†™
   }
   
   /**
    * ğŸ¯ é«˜çº§æ–¹æ³•ï¼šæ¡ä»¶çº¦æŸ
    */
   constraint conditional_constraints {
      // ROMåŒºåŸŸåªèƒ½è¯»å–
      if (address inside {[32'h0000_0000:32'h0000_FFFF]}) {
         is_write == 1'b0;
      }
      
      // å¤–è®¾åŒºåŸŸé€šå¸¸ä¸ºå­—è®¿é—®
      if (address inside {[32'h4000_0000:32'h4FFF_FFFF]}) {
         size == 4;
      }
   }
   
   /**
    * ğŸ¯ åéšæœºåŒ–å¤„ç†
    */
   function void post_randomize();
      `uvm_info("RAND", $sformatf("ç”Ÿæˆè®¿é—®: %s %0dB @ 0x%08x = 0x%08x",
                                 is_write ? "WRITE" : "READ",
                                 size, address, data), UVM_HIGH)
   endfunction
   
endclass
```

#### ğŸ² çº¦æŸæ±‚è§£æŠ€å·§

```systemverilog
/**
 * ğŸ› ï¸ çº¦æŸè°ƒè¯•å’Œä¼˜åŒ–æŠ€å·§
 */
class constraint_debugging;
   
   rand bit [7:0] value_a, value_b, value_c;
   
   // ğŸ”¹ å¤æ‚çº¦æŸå¯èƒ½å¯¼è‡´æ±‚è§£å¤±è´¥
   constraint complex_constraint {
      value_a + value_b == value_c;
      value_a inside {[10:50]};
      value_b inside {[20:60]};  
      value_c inside {[15:25]};  // å¯èƒ½æ— è§£!
   }
   
   /**
    * ğŸ”§ çº¦æŸæ±‚è§£éªŒè¯
    */
   function bit verify_constraints();
      // æ‰‹åŠ¨éªŒè¯çº¦æŸæ˜¯å¦å¯è§£
      if (value_a + value_b != value_c) begin
         `uvm_error("CONSTRAINT", "æ•°å­¦çº¦æŸè¿å")
         return 0;
      end
      
      if (!(value_a inside {[10:50]} && 
            value_b inside {[20:60]} && 
            value_c inside {[15:25]})) begin
         `uvm_error("CONSTRAINT", "èŒƒå›´çº¦æŸè¿å")
         return 0;
      end
      
      return 1;
   endfunction
   
   /**
    * ğŸ¯ æ™ºèƒ½éšæœºåŒ–
    */
   function bit smart_randomize();
      int attempts = 0;
      while (attempts < 100) begin
         if (this.randomize()) begin
            if (verify_constraints()) begin
               `uvm_info("RAND", $sformatf("æˆåŠŸéšæœºåŒ–: a=%0d, b=%0d, c=%0d (å°è¯•%0dæ¬¡)", 
                                         value_a, value_b, value_c, attempts+1), UVM_HIGH)
               return 1;
            end
         end
         attempts++;
      end
      
      `uvm_error("RAND", $sformatf("éšæœºåŒ–å¤±è´¥ï¼Œå°è¯•%0dæ¬¡åæ”¾å¼ƒ", attempts))
      return 0;
   endfunction
   
endclass
```

---

## ğŸ“Š Part 4: æµ‹è¯•åˆ†æå’Œè°ƒè¯•

### ğŸ” æµ‹è¯•ç»“æœåˆ†æ

#### ğŸ“ˆ è‡ªåŠ¨åŒ–ç»“æœæå–

```bash
#!/bin/bash
# test_analyzer.sh - æµ‹è¯•ç»“æœè‡ªåŠ¨åˆ†æè„šæœ¬

TEST_NAME=$1
LOG_FILE="cv32e40p_${TEST_NAME}.log"

echo "ğŸ” åˆ†ææµ‹è¯•ç»“æœ: $TEST_NAME"
echo "=================================="

# ğŸ”¹ åŸºæœ¬çŠ¶æ€æ£€æŸ¥
if grep -q "TEST PASSED" $LOG_FILE; then
    echo "âœ… æµ‹è¯•çŠ¶æ€: PASSED"
elif grep -q "TEST FAILED" $LOG_FILE; then
    echo "âŒ æµ‹è¯•çŠ¶æ€: FAILED"
else
    echo "âš ï¸  æµ‹è¯•çŠ¶æ€: UNKNOWN"
fi

# ğŸ”¹ é”™è¯¯ç»Ÿè®¡
ERROR_COUNT=$(grep -c "ERROR" $LOG_FILE)
WARNING_COUNT=$(grep -c "WARNING" $LOG_FILE)
echo "ğŸ“Š é”™è¯¯ç»Ÿè®¡: $ERROR_COUNT é”™è¯¯, $WARNING_COUNT è­¦å‘Š"

# ğŸ”¹ æ€§èƒ½ç»Ÿè®¡
if grep -q "Simulation time" $LOG_FILE; then
    SIM_TIME=$(grep "Simulation time" $LOG_FILE | awk '{print $3}')
    echo "â±ï¸  ä»¿çœŸæ—¶é—´: $SIM_TIME"
fi

# ğŸ”¹ è¦†ç›–ç‡ç»Ÿè®¡
if grep -q "Coverage" $LOG_FILE; then
    COVERAGE=$(grep "Coverage" $LOG_FILE | head -1)
    echo "ğŸ“ˆ è¦†ç›–ç‡: $COVERAGE"
fi

# ğŸ”¹ å…³é”®æ¶ˆæ¯æå–
echo ""
echo "ğŸ” å…³é”®æ¶ˆæ¯:"
grep -E "(FATAL|ERROR)" $LOG_FILE | head -5
```

#### ğŸ“Š è¦†ç›–ç‡æ”¶é›†å’Œåˆ†æ

```bash
# è¿è¡Œè¦†ç›–ç‡æµ‹è¯•
make test TEST=arithmetic_test COV=1

# ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
make cov TEST=arithmetic_test

# æ‰“å¼€è¦†ç›–ç‡æµè§ˆå™¨
firefox coverage_report/index.html
```

### ğŸš¨ å¸¸è§é—®é¢˜æ’æŸ¥

#### âŒ ç¼–è¯‘é—®é¢˜

**é—®é¢˜1**: æ‰¾ä¸åˆ°å¤´æ–‡ä»¶
```bash
# æ£€æŸ¥åŒ…å«è·¯å¾„
echo $CORE_V_VERIF
ls -la $CORE_V_VERIF/cv32e40p/tests/programs/custom/

# è§£å†³æ–¹æ¡ˆ: æ·»åŠ åŒ…å«è·¯å¾„
export C_INCLUDE_PATH=$CORE_V_VERIF/cv32e40p/tests/programs/custom/common:$C_INCLUDE_PATH
```

**é—®é¢˜2**: é“¾æ¥é”™è¯¯
```bash
# æ£€æŸ¥é“¾æ¥è„šæœ¬
ls -la $CV_SW_TOOLCHAIN/riscv32-unknown-elf/lib/

# ä½¿ç”¨è°ƒè¯•ç¼–è¯‘
${CV_SW_PREFIX}gcc -v -march=rv32imc -mabi=ilp32 test.c
```

#### âŒ ä»¿çœŸé—®é¢˜

**é—®é¢˜3**: ä»¿çœŸè¶…æ—¶
```bash
# å¢åŠ è¶…æ—¶æ—¶é—´
make test TEST=my_test USER_RUN_FLAGS="+TIMEOUT=1000000"

# æ£€æŸ¥æ˜¯å¦æœ‰æ— é™å¾ªç¯
make test TEST=my_test WAVES=1
make waves TEST=my_test
```

**é—®é¢˜4**: UVMåºåˆ—å¤±è´¥
```systemverilog
// åœ¨åºåˆ—ä¸­æ·»åŠ è°ƒè¯•ä¿¡æ¯
`uvm_info("DEBUG", $sformatf("å½“å‰çŠ¶æ€: %s", current_state.name()), UVM_MEDIUM)

// ä½¿ç”¨æ–­è¨€æ£€æŸ¥
assert(condition) else `uvm_error("ASSERT", "æ¡ä»¶æ£€æŸ¥å¤±è´¥")
```

---

## ğŸš€ Part 5: æ€§èƒ½ä¼˜åŒ–å’Œæœ€ä½³å®è·µ

### âš¡ ä»¿çœŸæ€§èƒ½ä¼˜åŒ–

#### ğŸ”§ ç¼–è¯‘ä¼˜åŒ–

```bash
# ä½¿ç”¨ä¼˜åŒ–ç¼–è¯‘é€‰é¡¹
export CV_SIMULATOR_ARGS="+nc64bit +noaccess +nospecify +notimingchecks"

# ç¦ç”¨ä¸å¿…è¦çš„æ£€æŸ¥
make test TEST=my_test USER_RUN_FLAGS="+UVM_NO_RELNOTES +define+UVM_DISABLE_AUTO_ITEM_RECORDING"
```

#### ğŸ“Š å†…å­˜ä¼˜åŒ–

```systemverilog
// åœ¨åºåˆ—ä¸­æ§åˆ¶å¯¹è±¡ç”Ÿå‘½å‘¨æœŸ
class memory_efficient_seq extends uvm_sequence;
   
   virtual task body();
      // ğŸ”¹ ä½¿ç”¨æœ¬åœ°å˜é‡å‡å°‘å†…å­˜å ç”¨
      for (int i = 0; i < 1000; i++) begin
         uvma_obi_memory_seq_item_c req;
         `uvm_create(req)
         
         // ... ä½¿ç”¨req
         
         // ğŸ”¹ æ˜¾å¼é‡Šæ”¾å¤§å¯¹è±¡ (å¦‚æœéœ€è¦)
         req = null;
      end
   endtask
   
endclass
```

### ğŸ“š æœ€ä½³å®è·µæ€»ç»“

#### âœ… ä»£ç è´¨é‡

1. **å‘½åè§„èŒƒ**: éµå¾ªé¡¹ç›®çº¦å®š (uvmt_*, uvme_*, uvma_*)
2. **æ³¨é‡Šå®Œæ•´**: æ¯ä¸ªå‡½æ•°å’Œé‡è¦é€»è¾‘éƒ½è¦æœ‰æ¸…æ™°æ³¨é‡Š
3. **é”™è¯¯å¤„ç†**: ä½¿ç”¨UVMæŠ¥å‘Šæœºåˆ¶ï¼Œä¸è¦ç”¨$display
4. **èµ„æºç®¡ç†**: åŠæ—¶é‡Šæ”¾å¤§å¯¹è±¡ï¼Œé¿å…å†…å­˜æ³„æ¼

#### âœ… æµ‹è¯•è®¾è®¡

1. **å•ä¸€èŒè´£**: æ¯ä¸ªæµ‹è¯•åªéªŒè¯ä¸€ä¸ªåŠŸèƒ½ç‚¹
2. **å‚æ•°åŒ–**: ä½¿ç”¨çº¦æŸéšæœºåŒ–å¢åŠ æµ‹è¯•è¦†ç›–é¢
3. **åˆ†å±‚è®¾è®¡**: æµ‹è¯•ç¨‹åº + UVMåºåˆ—çš„åˆç†åˆ†å·¥
4. **å¯é‡å¤æ€§**: ä½¿ç”¨å›ºå®šéšæœºç§å­ç¡®ä¿ç»“æœå¯é‡ç°

#### âœ… è°ƒè¯•æ•ˆç‡

1. **åˆ†æ­¥éªŒè¯**: å…ˆç®€å•åå¤æ‚ï¼Œé€æ­¥å¢åŠ å¤æ‚åº¦
2. **æ—¥å¿—åˆ†çº§**: åˆç†ä½¿ç”¨UVMè¯¦ç»†çº§åˆ«
3. **æ³¢å½¢åˆ†æ**: å…³é”®ä¿¡å·ä¸€å®šè¦ä¿å­˜åˆ°æ³¢å½¢ä¸­
4. **ç‰ˆæœ¬æ§åˆ¶**: æ¯ä¸ªstableç‰ˆæœ¬éƒ½è¦æ‰“tag

---

## ğŸ”— è¿›é˜¶å­¦ä¹ å»ºè®®

å®Œæˆè¿™ä¸ªå®æˆ˜æ‰‹å†Œåï¼Œå»ºè®®ç»§ç»­å­¦ä¹ ï¼š

1. **[03-è°ƒè¯•é—®é¢˜è§£å†³å®å…¸](./03-è°ƒè¯•é—®é¢˜è§£å†³å®å…¸.md)** - ç³»ç»ŸåŒ–é—®é¢˜æ’æŸ¥æ–¹æ³•
2. **[../05-é«˜çº§åŠŸèƒ½åº”ç”¨/01-å¹³å°é«˜çº§åŠŸèƒ½ä½¿ç”¨æŒ‡å—.md](../05-é«˜çº§åŠŸèƒ½åº”ç”¨/01-å¹³å°é«˜çº§åŠŸèƒ½ä½¿ç”¨æŒ‡å—.md)** - è¦†ç›–ç‡ã€COREV-DVç­‰é«˜çº§åŠŸèƒ½
3. **[../02-ä»£ç åˆ†æ/02-ç»„ä»¶æ¶æ„ä»£ç è¯¦è§£.md](../02-ä»£ç åˆ†æ/02-ç»„ä»¶æ¶æ„ä»£ç è¯¦è§£.md)** - æ·±å…¥ç†è§£ç»„ä»¶æ‰©å±•

---

> ğŸ’¡ **å®æˆ˜å¿ƒå¾—**  
> æµ‹è¯•å¼€å‘æ˜¯ä¸€ä¸ªè¿­ä»£è¿‡ç¨‹ã€‚ä»ç®€å•çš„åŠŸèƒ½æµ‹è¯•å¼€å§‹ï¼Œé€æ­¥å¢åŠ å¤æ‚åº¦å’Œè¦†ç›–é¢ã€‚æ¯æ¬¡é‡åˆ°é—®é¢˜éƒ½æ˜¯å­¦ä¹ çš„æœºä¼šï¼Œè®°å½•ä¸‹æ¥å½¢æˆè‡ªå·±çš„çŸ¥è¯†åº“ã€‚

> ğŸ¯ **æ•ˆç‡å»ºè®®**  
> å»ºç«‹è‡ªå·±çš„æµ‹è¯•æ¨¡æ¿åº“ï¼Œå°†å¸¸ç”¨çš„æµ‹è¯•æ¨¡å¼æ€»ç»“æˆå¯å¤ç”¨çš„ä»£ç ç‰‡æ®µã€‚è¿™æ ·å¯ä»¥å¤§å¤§æå‡å¼€å‘æ•ˆç‡ï¼ŒåŒæ—¶ä¿è¯ä»£ç è´¨é‡çš„ä¸€è‡´æ€§ã€‚