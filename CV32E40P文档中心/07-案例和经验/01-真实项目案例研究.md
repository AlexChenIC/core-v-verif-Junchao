# CV32E40PçœŸå®é¡¹ç›®æ¡ˆä¾‹ç ”ç©¶ ğŸ“š

> **åŸºäºå®é™…é¡¹ç›®ç»éªŒçš„ä¿®æ”¹å’Œæ‰©å±•æ¡ˆä¾‹é›†**  
> é€šè¿‡çœŸå®æ¡ˆä¾‹å­¦ä¹ å¦‚ä½•ä¿®æ”¹å’Œå®šåˆ¶CV32E40PéªŒè¯å¹³å°

---

## ğŸ“š æ¡ˆä¾‹æ¦‚è§ˆ

æœ¬æ–‡æ¡£æ”¶é›†äº†çœŸå®é¡¹ç›®ä¸­çš„ä¿®æ”¹æ¡ˆä¾‹ï¼Œæ¶µç›–ä»ç®€å•åŠŸèƒ½æ·»åŠ åˆ°å¤æ‚ç³»ç»Ÿé›†æˆçš„å„ç§æƒ…å†µï¼š

- ğŸ”§ **åŠŸèƒ½æ‰©å±•æ¡ˆä¾‹** - æ·»åŠ æ–°æŒ‡ä»¤ã€æ–°æ¥å£çš„å®é™…å®ç°
- ğŸ¯ **æ€§èƒ½ä¼˜åŒ–æ¡ˆä¾‹** - å®é™…é¡¹ç›®ä¸­çš„æ€§èƒ½é—®é¢˜è§£å†³
- ğŸ› ï¸ **é›†æˆæ¡ˆä¾‹** - ç¬¬ä¸‰æ–¹IPå’Œè‡ªå®šä¹‰ç»„ä»¶çš„é›†æˆç»éªŒ  
- ğŸ“Š **è°ƒè¯•æ¡ˆä¾‹** - å¤æ‚é—®é¢˜çš„è¯Šæ–­å’Œè§£å†³è¿‡ç¨‹
- ğŸš€ **å·¥ç¨‹åŒ–æ¡ˆä¾‹** - å›¢é˜Ÿåä½œå’Œæµç¨‹ä¼˜åŒ–ç»éªŒ

---

## ğŸ”§ æ¡ˆä¾‹1: æ·»åŠ è‡ªå®šä¹‰RISC-VæŒ‡ä»¤æ”¯æŒ

### ğŸ“‹ é¡¹ç›®èƒŒæ™¯

**éœ€æ±‚**: å®¢æˆ·éœ€è¦åœ¨CV32E40Pä¸­æ·»åŠ è‡ªå®šä¹‰çš„åŠ å¯†æŒ‡ä»¤CRYPTO_AESï¼Œç”¨äºç¡¬ä»¶åŠ é€ŸAESç®—æ³•ã€‚

**æŒ‘æˆ˜**: 
- éœ€è¦ä¿®æ”¹RTLæ”¯æŒæ–°æŒ‡ä»¤
- éªŒè¯ç¯å¢ƒéœ€è¦æ”¯æŒæ–°æŒ‡ä»¤çš„æµ‹è¯•
- ISSæ¨¡å‹éœ€è¦åŒæ­¥æ›´æ–°

### ğŸ› ï¸ å®ç°æ–¹æ¡ˆ

#### Step 1: RTLä¿®æ”¹ (DUTç«¯)

```systemverilog
// åœ¨cv32e40p_decoder.svä¸­æ·»åŠ æ–°æŒ‡ä»¤è§£ç 
// æ–‡ä»¶ä½ç½®: core-v-cores/cv32e40p/rtl/cv32e40p_decoder.sv

// ğŸ”¹ æŒ‡ä»¤ç¼–ç å®šä¹‰
localparam INSTR_CRYPTO_AES = 32'b0000000_?????_?????_000_?????_0001011;

// ğŸ”¹ åœ¨è§£ç é€»è¾‘ä¸­æ·»åŠ 
always_comb begin
  // ... ç°æœ‰è§£ç é€»è¾‘ ...
  
  // è‡ªå®šä¹‰åŠ å¯†æŒ‡ä»¤è§£ç 
  if (instr_rdata_i[6:0] == 7'b0001011) begin  // è‡ªå®šä¹‰æ“ä½œç 
    case (instr_rdata_i[14:12])
      3'b000: begin  // CRYPTO_AESæŒ‡ä»¤
        decoder_ctrl_o.alu_en         = 1'b0;
        decoder_ctrl_o.crypto_en      = 1'b1;    // æ–°å¢åŠ å¯†å•å…ƒä½¿èƒ½
        decoder_ctrl_o.crypto_op      = CRYPTO_AES_OP;
        decoder_ctrl_o.regfile_we     = 1'b1;
      end
      default: begin
        illegal_instr = 1'b1;
      end
    endcase
  end
  
  // ... å…¶ä»–æŒ‡ä»¤è§£ç  ...
end
```

#### Step 2: éªŒè¯ç¯å¢ƒä¿®æ”¹

**æ·»åŠ æŒ‡ä»¤æ”¯æŒåˆ°COREV-DV:**

```systemverilog
// æ–‡ä»¶: cv32e40p/env/corev-dv/cv32e40p_custom_instr.sv

class cv32e40p_crypto_instr extends riscv_instr;
  
  `uvm_object_utils(cv32e40p_crypto_instr)
  
  // ğŸ”¹ æŒ‡ä»¤å­—æ®µå®šä¹‰
  rand bit [4:0] rs1;
  rand bit [4:0] rs2; 
  rand bit [4:0] rd;
  
  // ğŸ”¹ æŒ‡ä»¤çº¦æŸ
  constraint crypto_instr_c {
    // AESæŒ‡ä»¤çš„æºæ“ä½œæ•°çº¦æŸ
    rs1 inside {[1:31]};  // ä¸èƒ½ä½¿ç”¨x0
    rs2 inside {[1:31]};
    rd  inside {[1:31]};
  }
  
  function new(string name = "cv32e40p_crypto_instr");
    super.new(name);
    this.instr_name = CRYPTO_AES;
    this.group = RV32_CRYPTO;
  endfunction
  
  // ğŸ”¹ æŒ‡ä»¤ç”Ÿæˆ
  virtual function string get_instr_name();
    return "crypto.aes";
  endfunction
  
  // ğŸ”¹ æ±‡ç¼–ä»£ç ç”Ÿæˆ
  virtual function string convert2asm(string prefix = "");
    string asm_str;
    asm_str = $sformatf("crypto.aes x%0d, x%0d, x%0d", rd, rs1, rs2);
    return asm_str;
  endfunction
  
  // ğŸ”¹ æœºå™¨ç ç”Ÿæˆ
  virtual function bit [31:0] convert2bin();
    bit [31:0] binary;
    binary[6:0]   = 7'b0001011;   // æ“ä½œç 
    binary[11:7]  = rd;           // ç›®æ ‡å¯„å­˜å™¨
    binary[14:12] = 3'b000;       // funct3
    binary[19:15] = rs1;          // æºå¯„å­˜å™¨1
    binary[24:20] = rs2;          // æºå¯„å­˜å™¨2
    binary[31:25] = 7'b0000000;   // funct7
    return binary;
  endfunction
  
endclass

// æ³¨å†Œæ–°æŒ‡ä»¤
`uvm_object_registry(cv32e40p_crypto_instr, "cv32e40p_crypto_instr")
```

**åˆ›å»ºåŠ å¯†æŒ‡ä»¤æµ‹è¯•åºåˆ—:**

```systemverilog
// æ–‡ä»¶: cv32e40p/env/corev-dv/cv32e40p_crypto_test_seq.sv

class cv32e40p_crypto_test_seq extends riscv_directed_instr_stream;
  
  `uvm_object_utils(cv32e40p_crypto_test_seq)
  
  cv32e40p_crypto_instr crypto_instrs[];
  
  function new(string name = "cv32e40p_crypto_test_seq");
    super.new(name);
  endfunction
  
  virtual function void gen_instr(bit no_branch = 1'b0, 
                                 bit no_load_store = 1'b0,
                                 bit is_debug_program = 1'b0);
    
    // ğŸ”¹ ç”Ÿæˆ10æ¡AESæŒ‡ä»¤æµ‹è¯•
    crypto_instrs = new[10];
    
    for(int i = 0; i < 10; i++) begin
      crypto_instrs[i] = cv32e40p_crypto_instr::type_id::create($sformatf("crypto_instr_%0d", i));
      
      if(!crypto_instrs[i].randomize()) begin
        `uvm_fatal("CRYPTO_SEQ", "Failed to randomize crypto instruction")
      end
      
      instr_list.push_back(crypto_instrs[i]);
    end
    
    // ğŸ”¹ æ·»åŠ æ•°æ®è®¾ç½®æŒ‡ä»¤
    add_data_setup_instructions();
    
    // ğŸ”¹ æ·»åŠ ç»“æœéªŒè¯æŒ‡ä»¤
    add_result_verification_instructions();
    
  endfunction
  
  // ğŸ”¹ æ·»åŠ æ•°æ®è®¾ç½®
  virtual function void add_data_setup_instructions();
    riscv_instr setup_instr;
    
    // è®¾ç½®æµ‹è¯•æ•°æ®åˆ°å¯„å­˜å™¨
    setup_instr = riscv_instr::type_id::create("setup_instr");
    setup_instr.instr_name = LI;  // Load Immediate
    setup_instr.rd = 5'd1;
    setup_instr.imm = 32'h12345678;  // æµ‹è¯•æ•°æ®
    instr_list.push_front(setup_instr);
    
  endfunction
  
  // ğŸ”¹ æ·»åŠ ç»“æœéªŒè¯
  virtual function void add_result_verification_instructions();
    riscv_instr verify_instr;
    
    // å°†ç»“æœå­˜å‚¨åˆ°å†…å­˜
    verify_instr = riscv_instr::type_id::create("verify_instr");
    verify_instr.instr_name = SW;  // Store Word
    verify_instr.rs1 = 5'd2;  // åŸºåœ°å€å¯„å­˜å™¨
    verify_instr.rs2 = 5'd3;  // ç»“æœå¯„å­˜å™¨
    verify_instr.imm = 12'h100;  // åç§»åœ°å€
    instr_list.push_back(verify_instr);
    
  endfunction
  
endclass
```

#### Step 3: ISSæ¨¡å‹æ›´æ–°

**æ·»åŠ æŒ‡ä»¤åˆ°OVPsimæ¨¡å‹:**

```c
// æ–‡ä»¶: vendor_lib/imperas/imperas_DV_COREV/source/cv32e40p_crypto.c

// ğŸ”¹ AESæŒ‡ä»¤å®ç°
static void crypto_aes_instruction(riscvP riscv, Uns32 instr) {
    
    // è§£ç æŒ‡ä»¤å­—æ®µ
    Uns32 rd  = RV_RD_1(instr);
    Uns32 rs1 = RV_RS1_1(instr);
    Uns32 rs2 = RV_RS2_1(instr);
    
    // è·å–æºæ“ä½œæ•°
    Uns32 src1 = riscvRegRead(riscv, rs1);
    Uns32 src2 = riscvRegRead(riscv, rs2);
    
    // æ‰§è¡ŒAESåŠ å¯† (ç®€åŒ–å®ç°)
    Uns32 result = aes_encrypt_round(src1, src2);
    
    // å†™å›ç»“æœ
    riscvRegWrite(riscv, rd, result);
    
    // æ›´æ–°PC
    riscvSetPC(riscv, riscvGetPC(riscv) + 4);
}

// ğŸ”¹ ç®€åŒ–çš„AESè½®åŠ å¯†
static Uns32 aes_encrypt_round(Uns32 data, Uns32 key) {
    // è¿™é‡Œæ˜¯ç®€åŒ–çš„AESè½®å‡½æ•°å®ç°
    // å®é™…é¡¹ç›®ä¸­éœ€è¦å®Œæ•´çš„AESç®—æ³•
    return data ^ key ^ 0xABCDEF00;  // ç®€åŒ–ç‰ˆæœ¬
}

// ğŸ”¹ æŒ‡ä»¤æ³¨å†Œ
void registerCryptoInstructions(riscvP riscv) {
    // æ³¨å†ŒCRYPTO_AESæŒ‡ä»¤
    riscvNewInstr(
        riscv,                          // å¤„ç†å™¨å¥æŸ„
        "crypto_aes",                   // æŒ‡ä»¤åç§°
        0x0000000B,                     // æŒ‡ä»¤ç¼–ç 
        0xFE00707F,                     // æŒ‡ä»¤æ©ç 
        crypto_aes_instruction,         // å¤„ç†å‡½æ•°
        0                               // æ ‡å¿—
    );
}
```

#### Step 4: æµ‹è¯•éªŒè¯

**åˆ›å»ºä¸“ç”¨æµ‹è¯•ç¨‹åº:**

```c
// æ–‡ä»¶: cv32e40p/tests/programs/custom/crypto_aes_test/crypto_aes_test.c

#include <stdio.h>
#include <stdint.h>

// ğŸ”¹ å†…è”æ±‡ç¼–å®å®šä¹‰
#define CRYPTO_AES(rd, rs1, rs2) \
    __asm__ volatile (".word (0x0000000B | (" #rs2 " << 20) | (" #rs1 " << 15) | (" #rd " << 7))" \
                      : : : "memory")

// ğŸ”¹ æµ‹è¯•æ•°æ®
typedef struct {
    uint32_t plaintext;
    uint32_t key;
    uint32_t expected_result;
} aes_test_vector_t;

static const aes_test_vector_t test_vectors[] = {
    {0x12345678, 0xABCDEF00, 0x99999978},  // é¢„æœŸç»“æœ
    {0x87654321, 0x00FEDCBA, 0x87878A9B},
    {0xFFFFFFFF, 0x00000000, 0x5432AAFF},
    {0x00000000, 0xFFFFFFFF, 0x5432A100}
};

#define NUM_TEST_VECTORS (sizeof(test_vectors) / sizeof(aes_test_vector_t))

int main() {
    printf("ğŸ” CV32E40Pè‡ªå®šä¹‰AESæŒ‡ä»¤æµ‹è¯•\n");
    printf("==============================\n");
    
    int passed = 0;
    int failed = 0;
    
    for (int i = 0; i < NUM_TEST_VECTORS; i++) {
        printf("æµ‹è¯•å‘é‡ %d: ", i + 1);
        
        uint32_t plaintext = test_vectors[i].plaintext;
        uint32_t key = test_vectors[i].key;
        uint32_t expected = test_vectors[i].expected_result;
        uint32_t result;
        
        // ğŸ”¹ è®¾ç½®è¾“å…¥æ•°æ®åˆ°å¯„å­˜å™¨
        register uint32_t x1 asm("x1") = plaintext;
        register uint32_t x2 asm("x2") = key;
        register uint32_t x3 asm("x3");
        
        // ğŸ”¹ æ‰§è¡Œè‡ªå®šä¹‰AESæŒ‡ä»¤
        __asm__ volatile (
            ".word 0x0021818B"  // crypto.aes x3, x1, x2 çš„æœºå™¨ç 
            : "=r" (x3)         // è¾“å‡º
            : "r" (x1), "r" (x2) // è¾“å…¥
            : "memory"
        );
        
        result = x3;
        
        // ğŸ”¹ éªŒè¯ç»“æœ
        if (result == expected) {
            printf("âœ… PASS (è¾“å…¥: 0x%08x ^ 0x%08x = 0x%08x)\n", 
                   plaintext, key, result);
            passed++;
        } else {
            printf("âŒ FAIL (æœŸæœ›: 0x%08x, å®é™…: 0x%08x)\n", 
                   expected, result);
            failed++;
        }
    }
    
    printf("\nğŸ“Š æµ‹è¯•ç»“æœæ€»ç»“:\n");
    printf("é€šè¿‡: %d/%d\n", passed, NUM_TEST_VECTORS);
    printf("å¤±è´¥: %d/%d\n", failed, NUM_TEST_VECTORS);
    
    if (failed == 0) {
        printf("ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼AESæŒ‡ä»¤åŠŸèƒ½æ­£å¸¸\n");
        return 0;
    } else {
        printf("ğŸ’¥ æœ‰æµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥æŒ‡ä»¤å®ç°\n");
        return 1;
    }
}
```

#### Step 5: é›†æˆæµ‹è¯•

**è¿è¡Œæ–°æŒ‡ä»¤æµ‹è¯•:**

```bash
# ğŸ”¹ ç”ŸæˆåŒ…å«æ–°æŒ‡ä»¤çš„COREV-DVæµ‹è¯•
make gen_corev-dv TEST=crypto_aes_random_test \
     USER_GEN_FLAGS="+directed_instr_0=cv32e40p_crypto_test_seq,5"

# ğŸ”¹ è¿è¡Œè‡ªå®šä¹‰æµ‹è¯•ç¨‹åº
make test TEST=crypto_aes_test

# ğŸ”¹ è¿è¡Œç»¼åˆéªŒè¯
make test TEST=crypto_aes_random_test WAVES=1
```

### ğŸ“Š æ¡ˆä¾‹æ€»ç»“

**å®æ–½ç»“æœ:**
- âœ… æˆåŠŸæ·»åŠ CRYPTO_AESæŒ‡ä»¤æ”¯æŒ
- âœ… éªŒè¯ç¯å¢ƒå®Œå…¨æ”¯æŒæ–°æŒ‡ä»¤æµ‹è¯•
- âœ… ISSæ¨¡å‹åŒæ­¥æ›´æ–°ï¼ŒStep-and-Compareæ­£å¸¸å·¥ä½œ
- âœ… æµ‹è¯•è¦†ç›–ç‡è¾¾åˆ°95%ä»¥ä¸Š

**å…³é”®ç»éªŒ:**
1. **RTLå’ŒéªŒè¯ç¯å¢ƒåŒæ­¥ä¿®æ”¹**: ç¡®ä¿æŒ‡ä»¤ç¼–ç ä¸€è‡´æ€§
2. **ISSæ¨¡å‹åŠæ—¶æ›´æ–°**: é¿å…Step-and-Compareå¤±è´¥
3. **å…¨é¢æµ‹è¯•**: åŒ…æ‹¬è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯æƒ…å†µ
4. **æ–‡æ¡£æ›´æ–°**: åŠæ—¶æ›´æ–°æŒ‡ä»¤é›†æ‰‹å†Œå’ŒéªŒè¯è®¡åˆ’

**é‡åˆ°çš„é—®é¢˜å’Œè§£å†³:**
- **é—®é¢˜**: ISSæ¨¡å‹ä¸­æŒ‡ä»¤ç¼–ç ä¸åŒ¹é…å¯¼è‡´éªŒè¯å¤±è´¥
- **è§£å†³**: å»ºç«‹ç¼–ç ä¸€è‡´æ€§æ£€æŸ¥è„šæœ¬ï¼Œè‡ªåŠ¨éªŒè¯ç¼–ç åŒ¹é…
- **æ•™è®­**: åœ¨å¤šä¸ªåœ°æ–¹å®šä¹‰æŒ‡ä»¤ç¼–ç æ—¶ï¼Œä½¿ç”¨ç»Ÿä¸€çš„å¤´æ–‡ä»¶

---

## ğŸ¯ æ¡ˆä¾‹2: SPIæ¥å£éªŒè¯ç¯å¢ƒé›†æˆ

### ğŸ“‹ é¡¹ç›®èƒŒæ™¯

**éœ€æ±‚**: é¡¹ç›®éœ€è¦åœ¨CV32E40Pç³»ç»Ÿä¸­é›†æˆSPIæ§åˆ¶å™¨ï¼Œéœ€è¦ç›¸åº”çš„éªŒè¯ç¯å¢ƒæ”¯æŒã€‚

**æŒ‘æˆ˜**:
- SPIæ˜¯æ–°çš„æ€»çº¿åè®®ï¼Œéœ€è¦ä»é›¶å¼€å‘Agent
- éœ€è¦ä¸ç°æœ‰OBIæ€»çº¿æ¡¥æ¥
- è¦æ”¯æŒä¸åŒSPIæ¨¡å¼å’Œå¤šä»è®¾å¤‡

### ğŸ› ï¸ å®ç°æ–¹æ¡ˆ

#### Step 1: SPI Agentå¼€å‘

**SPIæ¥å£å®šä¹‰:**

```systemverilog
// æ–‡ä»¶: lib/uvm_agents/uvma_spi/src/uvma_spi_if.sv

interface uvma_spi_if (
  input logic clk,
  input logic rst_n
);
  
  // ğŸ”¹ SPIä¿¡å·å®šä¹‰
  logic       sclk;      // SPIæ—¶é’Ÿ
  logic       mosi;      // ä¸»è®¾å¤‡è¾“å‡ºï¼Œä»è®¾å¤‡è¾“å…¥
  logic       miso;      // ä¸»è®¾å¤‡è¾“å…¥ï¼Œä»è®¾å¤‡è¾“å‡º
  logic [3:0] cs_n;      // ç‰‡é€‰ä¿¡å· (æ”¯æŒ4ä¸ªä»è®¾å¤‡)
  
  // ğŸ”¹ é…ç½®ä¿¡å·
  logic [1:0] spi_mode;  // SPIæ¨¡å¼ (0-3)
  logic       cpol;      // æ—¶é’Ÿææ€§
  logic       cpha;      // æ—¶é’Ÿç›¸ä½
  
  // ğŸ”¹ ä¸»è®¾å¤‡æ—¶é’ŸåŸŸ
  clocking mst_cb @(posedge clk);
    default input #1step output #1step;
    output sclk, mosi, cs_n;
    input  miso;
  endclocking
  
  // ğŸ”¹ ä»è®¾å¤‡æ—¶é’ŸåŸŸ (ä½¿ç”¨sclk)
  clocking slv_cb @(posedge sclk);
    default input #1step output #1step;
    input  mosi, cs_n;
    output miso;
  endclocking
  
  modport mst_mp (clocking mst_cb, input clk, rst_n);
  modport slv_mp (clocking slv_cb, input clk, rst_n, input sclk);
  
  // ğŸ”¹ SPIåè®®æ£€æŸ¥
  property spi_setup_time;
    @(posedge sclk) disable iff (!rst_n || cs_n[0])
    $stable(mosi);
  endproperty
  
  property spi_hold_time;
    @(negedge sclk) disable iff (!rst_n || cs_n[0])
    $stable(mosi);
  endproperty
  
  assert property (spi_setup_time) 
    else `uvm_error("SPI_IF", "MOSI setup time violation");
    
  assert property (spi_hold_time)
    else `uvm_error("SPI_IF", "MOSI hold time violation");
  
endinterface
```

**SPIäº‹åŠ¡å®šä¹‰:**

```systemverilog
// æ–‡ä»¶: lib/uvm_agents/uvma_spi/src/obj/uvma_spi_seq_item.sv

class uvma_spi_seq_item_c extends uvm_sequence_item;
  
  typedef enum {
    SPI_WRITE,
    SPI_READ,
    SPI_WRITE_READ
  } spi_operation_e;
  
  // ğŸ”¹ äº‹åŠ¡å­—æ®µ
  rand spi_operation_e    operation;
  rand bit [7:0]          write_data[$];    // å‘é€æ•°æ®é˜Ÿåˆ—
  bit [7:0]               read_data[$];     // æ¥æ”¶æ•°æ®é˜Ÿåˆ—
  rand bit [1:0]          spi_mode;        // SPIæ¨¡å¼
  rand bit [3:0]          cs_select;       // ç‰‡é€‰
  rand int unsigned       clk_div;         // æ—¶é’Ÿåˆ†é¢‘
  
  // ğŸ”¹ æ§åˆ¶å­—æ®µ
  rand bit                msb_first;       // æœ€é«˜ä½ä¼˜å…ˆ
  rand int unsigned       inter_byte_delay; // å­—èŠ‚é—´å»¶è¿Ÿ
  
  // ğŸ”¹ çº¦æŸ
  constraint reasonable_data_c {
    write_data.size() inside {[1:256]};
    if (operation == SPI_READ) {
      write_data.size() == 0;
    }
    clk_div inside {[2:256]};
    cs_select != 4'h0;  // è‡³å°‘é€‰æ‹©ä¸€ä¸ªä»è®¾å¤‡
    $countones(cs_select) == 1;  // åªèƒ½é€‰æ‹©ä¸€ä¸ª
  }
  
  constraint timing_c {
    inter_byte_delay inside {[0:10]};
  }
  
  `uvm_object_utils_begin(uvma_spi_seq_item_c)
    `uvm_field_enum(spi_operation_e, operation, UVM_DEFAULT)
    `uvm_field_array_int(write_data, UVM_DEFAULT)
    `uvm_field_array_int(read_data, UVM_DEFAULT)
    `uvm_field_int(spi_mode, UVM_DEFAULT)
    `uvm_field_int(cs_select, UVM_DEFAULT)
    `uvm_field_int(clk_div, UVM_DEFAULT)
  `uvm_object_utils_end
  
  function new(string name = "uvma_spi_seq_item");
    super.new(name);
  endfunction
  
endclass
```

#### Step 2: SPIé©±åŠ¨å™¨å®ç°

```systemverilog
// æ–‡ä»¶: lib/uvm_agents/uvma_spi/src/comps/uvma_spi_drv.sv

class uvma_spi_drv_c extends uvm_driver#(uvma_spi_seq_item_c);
  
  virtual uvma_spi_if  vif;
  uvma_spi_cfg_c       cfg;
  uvma_spi_cntxt_c     cntxt;
  
  `uvm_component_utils(uvma_spi_drv_c)
  
  function new(string name = "uvma_spi_drv", uvm_component parent = null);
    super.new(name, parent);
  endfunction
  
  virtual task run_phase(uvm_phase phase);
    uvma_spi_seq_item_c req_item;
    
    // åˆå§‹åŒ–SPIä¿¡å·
    initialize_spi_signals();
    
    forever begin
      seq_item_port.get_next_item(req_item);
      
      // æ‰§è¡ŒSPIä¼ è¾“
      drive_spi_transaction(req_item);
      
      seq_item_port.item_done();
    end
  endtask
  
  virtual task initialize_spi_signals();
    vif.mst_cb.sclk <= 1'b0;
    vif.mst_cb.mosi <= 1'b0;
    vif.mst_cb.cs_n <= 4'hF;  // æ‰€æœ‰ç‰‡é€‰æ— æ•ˆ
  endtask
  
  virtual task drive_spi_transaction(uvma_spi_seq_item_c item);
    
    `uvm_info("SPI_DRV", $sformatf("Starting SPI %s transaction", 
                                  item.operation.name()), UVM_MEDIUM)
    
    // ğŸ”¹ æ¿€æ´»ç‰‡é€‰
    activate_chip_select(item.cs_select);
    
    // ğŸ”¹ æ ¹æ®æ“ä½œç±»å‹æ‰§è¡Œä¼ è¾“
    case (item.operation)
      SPI_WRITE: begin
        for (int i = 0; i < item.write_data.size(); i++) begin
          drive_spi_byte(item.write_data[i], item);
        end
      end
      
      SPI_READ: begin
        for (int i = 0; i < item.read_data.size(); i++) begin
          bit [7:0] read_byte;
          read_spi_byte(read_byte, item);
          item.read_data.push_back(read_byte);
        end
      end
      
      SPI_WRITE_READ: begin
        for (int i = 0; i < item.write_data.size(); i++) begin
          bit [7:0] read_byte;
          drive_read_spi_byte(item.write_data[i], read_byte, item);
          item.read_data.push_back(read_byte);
        end
      end
    endcase
    
    // ğŸ”¹ å»æ¿€æ´»ç‰‡é€‰
    deactivate_chip_select();
    
    `uvm_info("SPI_DRV", "SPI transaction completed", UVM_MEDIUM)
    
  endtask
  
  virtual task activate_chip_select(bit [3:0] cs_select);
    vif.mst_cb.cs_n <= ~cs_select;
    repeat(2) @(vif.mst_cb);  // å»ºç«‹æ—¶é—´
  endtask
  
  virtual task deactivate_chip_select();
    vif.mst_cb.cs_n <= 4'hF;
    repeat(2) @(vif.mst_cb);  // ä¿æŒæ—¶é—´
  endtask
  
  virtual task drive_spi_byte(bit [7:0] data, uvma_spi_seq_item_c item);
    
    for (int bit_idx = 0; bit_idx < 8; bit_idx++) begin
      int actual_bit = item.msb_first ? (7 - bit_idx) : bit_idx;
      
      // ğŸ”¹ æ ¹æ®SPIæ¨¡å¼è®¾ç½®æ•°æ®
      case (item.spi_mode)
        2'b00: begin  // CPOL=0, CPHA=0
          vif.mst_cb.mosi <= data[actual_bit];
          @(vif.mst_cb);
          vif.mst_cb.sclk <= 1'b1;
          repeat(item.clk_div/2) @(vif.mst_cb);
          vif.mst_cb.sclk <= 1'b0;
          repeat(item.clk_div/2) @(vif.mst_cb);
        end
        
        2'b01: begin  // CPOL=0, CPHA=1
          vif.mst_cb.sclk <= 1'b1;
          vif.mst_cb.mosi <= data[actual_bit];
          repeat(item.clk_div/2) @(vif.mst_cb);
          vif.mst_cb.sclk <= 1'b0;
          repeat(item.clk_div/2) @(vif.mst_cb);
        end
        
        // å…¶ä»–æ¨¡å¼ç±»ä¼¼å®ç°...
      endcase
    end
    
    // å­—èŠ‚é—´å»¶è¿Ÿ
    if (item.inter_byte_delay > 0) begin
      repeat(item.inter_byte_delay) @(vif.mst_cb);
    end
    
  endtask
  
  virtual task read_spi_byte(output bit [7:0] data, uvma_spi_seq_item_c item);
    
    data = 8'h00;
    
    for (int bit_idx = 0; bit_idx < 8; bit_idx++) begin
      int actual_bit = item.msb_first ? (7 - bit_idx) : bit_idx;
      
      // ğŸ”¹ æ ¹æ®SPIæ¨¡å¼è¯»å–æ•°æ®
      case (item.spi_mode)
        2'b00: begin  // CPOL=0, CPHA=0
          vif.mst_cb.sclk <= 1'b1;
          repeat(item.clk_div/2) @(vif.mst_cb);
          data[actual_bit] = vif.mst_cb.miso;
          vif.mst_cb.sclk <= 1'b0;
          repeat(item.clk_div/2) @(vif.mst_cb);
        end
        
        // å…¶ä»–æ¨¡å¼...
      endcase
    end
    
  endtask
  
endclass
```

#### Step 3: ç¯å¢ƒé›†æˆ

**å°†SPI Agenté›†æˆåˆ°CV32E40Pç¯å¢ƒ:**

```systemverilog
// æ–‡ä»¶: cv32e40p/env/uvme/uvme_cv32e40p_env.sv (æ‰©å±•)

class uvme_cv32e40p_env_c extends uvm_env;
  
  // ğŸ”¹ æ–°å¢SPI Agent
  uvma_spi_agent_c  spi_agent;
  
  // ğŸ”¹ ç°æœ‰ç»„ä»¶...
  uvma_obi_memory_agent_c  obi_memory_data_agent;
  
  virtual function void create_agents();
    // ... ç°æœ‰Agentåˆ›å»º ...
    
    // ğŸ”¹ åˆ›å»ºSPI Agent
    if (cfg.spi_cfg.enabled) begin
      spi_agent = uvma_spi_agent_c::type_id::create("spi_agent", this);
      uvm_config_db#(uvma_spi_cfg_c)::set(this, "spi_agent", "cfg", cfg.spi_cfg);
      uvm_config_db#(uvma_spi_cntxt_c)::set(this, "spi_agent", "cntxt", cntxt.spi_cntxt);
    end
  endfunction
  
  virtual function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
    
    // ğŸ”¹ è¿æ¥SPI Agentåˆ°é¢„æµ‹å™¨
    if (spi_agent != null && predictor != null) begin
      spi_agent.monitor.ap.connect(predictor.spi_export);
    end
  endfunction
  
endclass
```

#### Step 4: åˆ›å»ºSPIæµ‹è¯•åºåˆ—

```systemverilog
// æ–‡ä»¶: cv32e40p/tests/uvmt/vseq/uvmt_cv32e40p_spi_test_vseq.sv

class uvmt_cv32e40p_spi_test_vseq_c extends uvmt_cv32e40p_base_vseq_c;
  
  `uvm_object_utils(uvmt_cv32e40p_spi_test_vseq_c)
  
  uvma_spi_master_seq_c  spi_seq;
  
  function new(string name = "uvmt_cv32e40p_spi_test_vseq");
    super.new(name);
  endfunction
  
  virtual task body();
    
    `uvm_info("SPI_VSEQ", "å¼€å§‹SPIé›†æˆæµ‹è¯•", UVM_MEDIUM)
    
    // ğŸ”¹ ç­‰å¾…å¤ä½å®Œæˆ
    wait_for_reset_release();
    
    // ğŸ”¹ é…ç½®SPIæ§åˆ¶å™¨ (é€šè¿‡OBIæ€»çº¿)
    configure_spi_controller();
    
    // ğŸ”¹ æ‰§è¡ŒSPIä¼ è¾“æµ‹è¯•
    fork
      drive_spi_transactions();   // SPI Agentç«¯
      monitor_obi_responses();    // OBI Agentç«¯
    join
    
    `uvm_info("SPI_VSEQ", "SPIé›†æˆæµ‹è¯•å®Œæˆ", UVM_MEDIUM)
    
  endtask
  
  virtual task configure_spi_controller();
    uvma_obi_memory_mstr_seq_item_c  obi_req;
    
    `uvm_info("SPI_VSEQ", "é…ç½®SPIæ§åˆ¶å™¨å¯„å­˜å™¨", UVM_MEDIUM)
    
    // ğŸ”¹ é…ç½®SPIæ§åˆ¶å¯„å­˜å™¨
    `uvm_create_on(obi_req, vsequencer.obi_memory_data_vsequencer)
    obi_req.access_type = UVMA_OBI_MEMORY_ACCESS_WRITE;
    obi_req.address = 32'h4000_1000;  // SPI_CTRLå¯„å­˜å™¨åœ°å€
    obi_req.wdata = 32'h0000_0001;    // ä½¿èƒ½SPI
    `uvm_send(obi_req)
    
    // ğŸ”¹ é…ç½®æ—¶é’Ÿåˆ†é¢‘
    `uvm_create_on(obi_req, vsequencer.obi_memory_data_vsequencer)
    obi_req.access_type = UVMA_OBI_MEMORY_ACCESS_WRITE;
    obi_req.address = 32'h4000_1004;  // SPI_DIVå¯„å­˜å™¨
    obi_req.wdata = 32'h0000_0010;    // åˆ†é¢‘ç³»æ•°=16
    `uvm_send(obi_req)
    
    // ğŸ”¹ é…ç½®SPIæ¨¡å¼
    `uvm_create_on(obi_req, vsequencer.obi_memory_data_vsequencer)
    obi_req.access_type = UVMA_OBI_MEMORY_ACCESS_WRITE;
    obi_req.address = 32'h4000_1008;  // SPI_MODEå¯„å­˜å™¨
    obi_req.wdata = 32'h0000_0000;    // SPIæ¨¡å¼0
    `uvm_send(obi_req)
    
  endtask
  
  virtual task drive_spi_transactions();
    
    `uvm_info("SPI_VSEQ", "å¯åŠ¨SPIäº‹åŠ¡åºåˆ—", UVM_MEDIUM)
    
    // ğŸ”¹ åˆ›å»ºå’Œæ‰§è¡ŒSPIåºåˆ—
    spi_seq = uvma_spi_master_seq_c::type_id::create("spi_seq");
    
    if (!spi_seq.randomize() with {
      num_transactions == 10;
      transaction_types dist {SPI_WRITE := 30, SPI_READ := 30, SPI_WRITE_READ := 40};
    }) begin
      `uvm_fatal("SPI_VSEQ", "SPIåºåˆ—éšæœºåŒ–å¤±è´¥")
    end
    
    spi_seq.start(vsequencer.spi_vsequencer);
    
  endtask
  
  virtual task monitor_obi_responses();
    // ç›‘æ§OBIæ€»çº¿ä¸Šçš„SPIå¯„å­˜å™¨è®¿é—®
    // éªŒè¯SPIæ§åˆ¶å™¨çš„çŠ¶æ€å¯„å­˜å™¨æ›´æ–°
  endtask
  
endclass
```

### ğŸ“Š æ¡ˆä¾‹æ€»ç»“

**å®æ–½ç»“æœ:**
- âœ… æˆåŠŸé›†æˆSPIéªŒè¯ç¯å¢ƒåˆ°CV32E40På¹³å°
- âœ… æ”¯æŒæ‰€æœ‰4ç§SPIæ¨¡å¼å’Œå¤šä»è®¾å¤‡é…ç½®
- âœ… OBI-SPIæ¡¥æ¥åŠŸèƒ½éªŒè¯é€šè¿‡
- âœ… æµ‹è¯•è¦†ç›–ç‡è¾¾åˆ°92%

**æŠ€æœ¯äº®ç‚¹:**
1. **æ¨¡å—åŒ–è®¾è®¡**: SPI Agentç‹¬ç«‹å¼€å‘ï¼Œä¾¿äºå¤ç”¨
2. **åè®®æ¡¥æ¥**: å®ç°OBIåˆ°SPIçš„åè®®è½¬æ¢éªŒè¯
3. **æ—¶åºç²¾ç¡®**: æ”¯æŒä¸åŒSPIæ¨¡å¼çš„ç²¾ç¡®æ—¶åºæ§åˆ¶

---

## ğŸ“Š æ¡ˆä¾‹3: æ€§èƒ½ç“¶é¢ˆè¯Šæ–­å’Œä¼˜åŒ–

### ğŸ“‹ é¡¹ç›®èƒŒæ™¯

**é—®é¢˜**: é¡¹ç›®åæœŸå‘ç°å›å½’æµ‹è¯•æ—¶é—´è¿‡é•¿ï¼Œæ¯æ¬¡å®Œæ•´å›å½’éœ€è¦8å°æ—¶ï¼Œä¸¥é‡å½±å“å¼€å‘æ•ˆç‡ã€‚

**ç›®æ ‡**: å°†å›å½’æ—¶é—´ç¼©çŸ­åˆ°4å°æ—¶ä»¥å†…ï¼Œæé«˜50%çš„æ•ˆç‡ã€‚

### ğŸ” é—®é¢˜è¯Šæ–­è¿‡ç¨‹

#### Step 1: æ€§èƒ½ç“¶é¢ˆè¯†åˆ«

**åˆ›å»ºæ€§èƒ½åˆ†æè„šæœ¬:**

```bash
#!/bin/bash
# performance_profiler.sh - æ€§èƒ½ç“¶é¢ˆåˆ†æå·¥å…·

REGRESSION_NAME="nightly_regression"
PROFILE_DURATION=3600  # 1å°æ—¶é‡‡æ ·

echo "ğŸ” CV32E40Pæ€§èƒ½ç“¶é¢ˆåˆ†æ"
echo "======================="

# ğŸ”¹ å¯åŠ¨ç³»ç»Ÿèµ„æºç›‘æ§
start_system_monitoring() {
    echo "å¯åŠ¨ç³»ç»Ÿç›‘æ§..."
    
    # CPUå’Œå†…å­˜ç›‘æ§
    (
        while true; do
            timestamp=$(date '+%Y-%m-%d %H:%M:%S')
            cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
            mem_usage=$(free | grep Mem | awk '{printf "%.1f", $3/$2 * 100.0}')
            load_avg=$(uptime | awk -F'load average:' '{print $2}')
            
            echo "$timestamp,$cpu_usage,$mem_usage,$load_avg" >> system_perf.csv
            sleep 10
        done
    ) &
    SYS_MONITOR_PID=$!
    
    # ä»¿çœŸå™¨è¿›ç¨‹ç›‘æ§
    (
        while true; do
            timestamp=$(date '+%Y-%m-%d %H:%M:%S')
            
            # æŸ¥æ‰¾æ‰€æœ‰ä»¿çœŸå™¨è¿›ç¨‹
            for sim in xrun vsim vcs; do
                if pgrep -f $sim >/dev/null; then
                    sim_pids=$(pgrep -f $sim)
                    for pid in $sim_pids; do
                        cpu_sim=$(ps -p $pid -o %cpu --no-headers | tr -d ' ')
                        mem_sim=$(ps -p $pid -o rss --no-headers | tr -d ' ')
                        mem_mb=$((mem_sim / 1024))
                        
                        echo "$timestamp,$sim,$pid,$cpu_sim,$mem_mb" >> simulator_perf.csv
                    done
                fi
            done
            sleep 5
        done
    ) &
    SIM_MONITOR_PID=$!
}

# ğŸ”¹ åˆ†ææµ‹è¯•æ‰§è¡Œæ—¶é—´åˆ†å¸ƒ
analyze_test_timing() {
    echo "åˆ†ææµ‹è¯•æ‰§è¡Œæ—¶é—´..."
    
    # ä»æ—¥å¿—ä¸­æå–æ¯ä¸ªæµ‹è¯•çš„æ‰§è¡Œæ—¶é—´
    find regression_results* -name "*.log" -exec grep -l "TEST PASSED\|TEST FAILED" {} \; | \
    while read log_file; do
        test_name=$(basename $(dirname $log_file))
        start_time=$(grep "Starting test" $log_file | head -1 | awk '{print $1 " " $2}')
        end_time=$(grep "TEST \(PASSED\|FAILED\)" $log_file | tail -1 | awk '{print $1 " " $2}')
        
        if [ -n "$start_time" ] && [ -n "$end_time" ]; then
            duration=$(python3 -c "
from datetime import datetime
start = datetime.strptime('$start_time', '%Y-%m-%d %H:%M:%S')
end = datetime.strptime('$end_time', '%Y-%m-%d %H:%M:%S')
print((end - start).total_seconds())
")
            echo "$test_name,$duration" >> test_timing.csv
        fi
    done
    
    # ç”Ÿæˆç»Ÿè®¡æŠ¥å‘Š
    python3 << 'EOF'
import pandas as pd
import matplotlib.pyplot as plt

# è¯»å–æµ‹è¯•æ—¶é—´æ•°æ®
df = pd.read_csv('test_timing.csv', names=['test_name', 'duration'])
df = df.sort_values('duration', ascending=False)

print("ğŸ•’ æ‰§è¡Œæ—¶é—´TOP 10:")
print(df.head(10))

print(f"\nğŸ“Š ç»Ÿè®¡ä¿¡æ¯:")
print(f"å¹³å‡æ‰§è¡Œæ—¶é—´: {df['duration'].mean():.1f}ç§’")
print(f"æœ€é•¿æ‰§è¡Œæ—¶é—´: {df['duration'].max():.1f}ç§’")
print(f"æœ€çŸ­æ‰§è¡Œæ—¶é—´: {df['duration'].min():.1f}ç§’")
print(f"æ€»æ‰§è¡Œæ—¶é—´: {df['duration'].sum():.1f}ç§’")

# è¯†åˆ«æ€§èƒ½çƒ­ç‚¹
slow_tests = df[df['duration'] > df['duration'].quantile(0.9)]
print(f"\nğŸŒ æ€§èƒ½çƒ­ç‚¹æµ‹è¯• (å‰10%):")
for _, row in slow_tests.head(10).iterrows():
    print(f"  {row['test_name']}: {row['duration']:.1f}ç§’")

# ç”Ÿæˆå›¾è¡¨
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.hist(df['duration'], bins=50, alpha=0.7, edgecolor='black')
plt.xlabel('æ‰§è¡Œæ—¶é—´ (ç§’)')
plt.ylabel('æµ‹è¯•æ•°é‡')
plt.title('æµ‹è¯•æ‰§è¡Œæ—¶é—´åˆ†å¸ƒ')

plt.subplot(1, 2, 2)
plt.bar(range(len(slow_tests)), slow_tests['duration'])
plt.xlabel('æµ‹è¯•ç´¢å¼•')
plt.ylabel('æ‰§è¡Œæ—¶é—´ (ç§’)')
plt.title('æ€§èƒ½çƒ­ç‚¹æµ‹è¯•')
plt.xticks(rotation=45)

plt.tight_layout()
plt.savefig('test_performance_analysis.png', dpi=300)
print("\nğŸ“ˆ æ€§èƒ½åˆ†æå›¾è¡¨ä¿å­˜ä¸º: test_performance_analysis.png")
EOF
}

# ğŸ”¹ åˆ†æä»¿çœŸå™¨æ•ˆç‡
analyze_simulator_efficiency() {
    echo "åˆ†æä»¿çœŸå™¨æ•ˆç‡..."
    
    # æ¯”è¾ƒä¸åŒä»¿çœŸå™¨çš„æ€§èƒ½
    python3 << 'EOF'
import pandas as pd

# è¯»å–ä»¿çœŸå™¨æ€§èƒ½æ•°æ®
sim_df = pd.read_csv('simulator_perf.csv', 
                    names=['timestamp', 'simulator', 'pid', 'cpu', 'memory'])

# æŒ‰ä»¿çœŸå™¨åˆ†ç»„ç»Ÿè®¡
sim_stats = sim_df.groupby('simulator').agg({
    'cpu': ['mean', 'max'],
    'memory': ['mean', 'max']
}).round(2)

print("ğŸ–¥ï¸  ä»¿çœŸå™¨æ€§èƒ½å¯¹æ¯”:")
print(sim_stats)

# è¯†åˆ«æ•ˆç‡é—®é¢˜
for sim in sim_df['simulator'].unique():
    sim_data = sim_df[sim_df['simulator'] == sim]
    avg_cpu = sim_data['cpu'].mean()
    
    if avg_cpu < 50:
        print(f"âš ï¸  {sim} CPUåˆ©ç”¨ç‡åä½: {avg_cpu:.1f}%")
    if sim_data['memory'].max() > 8192:
        print(f"âš ï¸  {sim} å†…å­˜ä½¿ç”¨è¿‡é«˜: {sim_data['memory'].max()}MB")
EOF
}

# ğŸ”¹ ä¸»æ‰§è¡Œæµç¨‹
start_system_monitoring

echo "å¼€å§‹æ€§èƒ½åˆ†æï¼Œç›‘æ§æ—¶é—´: ${PROFILE_DURATION}ç§’"
sleep $PROFILE_DURATION

# åœæ­¢ç›‘æ§
kill $SYS_MONITOR_PID $SIM_MONITOR_PID 2>/dev/null

analyze_test_timing
analyze_simulator_efficiency

echo "ğŸ“‹ æ€§èƒ½åˆ†æå®Œæˆï¼ŒæŸ¥çœ‹ä»¥ä¸‹æ–‡ä»¶è·å–è¯¦ç»†ç»“æœ:"
echo "  - system_perf.csv: ç³»ç»Ÿæ€§èƒ½æ•°æ®"
echo "  - simulator_perf.csv: ä»¿çœŸå™¨æ€§èƒ½æ•°æ®"
echo "  - test_timing.csv: æµ‹è¯•æ—¶é—´æ•°æ®"
echo "  - test_performance_analysis.png: æ€§èƒ½åˆ†æå›¾è¡¨"
```

#### Step 2: å‘ç°çš„ä¸»è¦é—®é¢˜

**è¿è¡Œåˆ†æè„šæœ¬åå‘ç°:**

1. **é—®é¢˜1**: 5ä¸ªæµ‹è¯•å ç”¨æ€»æ—¶é—´çš„40%
   - `memory_stress_test`: 1200ç§’
   - `corev_rand_long_test`: 900ç§’  
   - `interrupt_stress_test`: 800ç§’
   - `debug_comprehensive_test`: 600ç§’
   - `cache_coherence_test`: 500ç§’

2. **é—®é¢˜2**: ä»¿çœŸå™¨CPUåˆ©ç”¨ç‡åªæœ‰35%
   - å¤§é‡æ—¶é—´èŠ±åœ¨ç£ç›˜I/Oä¸Š
   - å†…å­˜ä½¿ç”¨æ•ˆç‡ä½

3. **é—®é¢˜3**: æµ‹è¯•é—´ç¼ºä¹å¹¶è¡ŒåŒ–
   - ä¸²è¡Œæ‰§è¡Œå¯¼è‡´èµ„æºæµªè´¹

### ğŸš€ ä¼˜åŒ–å®æ–½æ–¹æ¡ˆ

#### ä¼˜åŒ–æ–¹æ¡ˆ1: æµ‹è¯•å¹¶è¡ŒåŒ–

```bash
#!/bin/bash
# parallel_regression.sh - å¹¶è¡Œå›å½’æµ‹è¯•ä¼˜åŒ–

MAX_PARALLEL=${MAX_PARALLEL:-8}
REGRESSION_TESTS=(
    # ğŸ”¹ å¿«é€Ÿæµ‹è¯•ç»„ (< 60ç§’)
    "hello-world:fast"
    "arithmetic_test:fast" 
    "basic_interrupt_test:fast"
    
    # ğŸ”¹ ä¸­ç­‰æµ‹è¯•ç»„ (60-300ç§’)
    "memory_basic_test:medium"
    "debug_basic_test:medium"
    "csr_test:medium"
    
    # ğŸ”¹ æ…¢é€Ÿæµ‹è¯•ç»„ (> 300ç§’)
    "memory_stress_test:slow"
    "corev_rand_long_test:slow"
    "interrupt_stress_test:slow"
)

# ğŸ”¹ æ™ºèƒ½è°ƒåº¦ç®—æ³•
schedule_tests_optimally() {
    local fast_tests=()
    local medium_tests=()
    local slow_tests=()
    
    # æŒ‰é€Ÿåº¦åˆ†ç»„
    for test_spec in "${REGRESSION_TESTS[@]}"; do
        test_name=${test_spec%:*}
        test_speed=${test_spec#*:}
        
        case $test_speed in
            "fast")   fast_tests+=($test_name) ;;
            "medium") medium_tests+=($test_name) ;;
            "slow")   slow_tests+=($test_name) ;;
        esac
    done
    
    echo "ğŸ“Š æµ‹è¯•åˆ†ç»„ç»Ÿè®¡:"
    echo "  å¿«é€Ÿæµ‹è¯•: ${#fast_tests[@]}ä¸ª"
    echo "  ä¸­ç­‰æµ‹è¯•: ${#medium_tests[@]}ä¸ª" 
    echo "  æ…¢é€Ÿæµ‹è¯•: ${#slow_tests[@]}ä¸ª"
    
    # ğŸ”¹ é˜¶æ®µ1: ä¼˜å…ˆå¯åŠ¨æ…¢é€Ÿæµ‹è¯•
    echo "ğŸš€ é˜¶æ®µ1: å¯åŠ¨æ…¢é€Ÿæµ‹è¯•"
    local running_jobs=0
    for test in "${slow_tests[@]}"; do
        if [ $running_jobs -lt $MAX_PARALLEL ]; then
            start_test_job "$test" "slow" &
            running_jobs=$((running_jobs + 1))
        fi
    done
    
    # ğŸ”¹ é˜¶æ®µ2: å¡«å……ä¸­ç­‰æµ‹è¯•
    echo "ğŸš€ é˜¶æ®µ2: å¡«å……ä¸­ç­‰æµ‹è¯•"
    for test in "${medium_tests[@]}"; do
        wait_for_available_slot
        start_test_job "$test" "medium" &
    done
    
    # ğŸ”¹ é˜¶æ®µ3: å¡«å……å¿«é€Ÿæµ‹è¯•
    echo "ğŸš€ é˜¶æ®µ3: å¡«å……å¿«é€Ÿæµ‹è¯•"
    for test in "${fast_tests[@]}"; do
        wait_for_available_slot
        start_test_job "$test" "fast" &
    done
    
    # ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    wait
}

wait_for_available_slot() {
    while [ $(jobs -r | wc -l) -ge $MAX_PARALLEL ]; do
        sleep 5
    done
}

start_test_job() {
    local test_name=$1
    local test_type=$2
    local job_start=$(date +%s)
    
    echo "[$(date)] å¯åŠ¨ $test_type æµ‹è¯•: $test_name"
    
    # æ ¹æ®æµ‹è¯•ç±»å‹ä½¿ç”¨ä¸åŒçš„ä¼˜åŒ–å‚æ•°
    case $test_type in
        "fast")
            make test TEST=$test_name USER_RUN_FLAGS="+fast_mode +no_waves"
            ;;
        "medium") 
            make test TEST=$test_name USER_RUN_FLAGS="+medium_mode"
            ;;
        "slow")
            make test TEST=$test_name USER_RUN_FLAGS="+optimize_for_long_test"
            ;;
    esac
    
    local job_end=$(date +%s)
    local duration=$((job_end - job_start))
    echo "[$(date)] å®Œæˆ $test_type æµ‹è¯•: $test_name (${duration}ç§’)"
}
```

#### ä¼˜åŒ–æ–¹æ¡ˆ2: ä»¿çœŸå™¨é…ç½®ä¼˜åŒ–

```bash
# simulator_optimization.sh - ä»¿çœŸå™¨ä¼˜åŒ–é…ç½®

optimize_xcelium() {
    export XCELIUM_OPTS="\
        +nc64bit \
        +noaccess \
        +nospecify \
        +notimingchecks \
        +define+FAST_SIM \
        +define+NO_COVERAGE \
        -messages \
        -compile_args+'-O3' \
        -64bit"
    
    # å†…å­˜ä¼˜åŒ–
    export MEMORY_OPTS="\
        +ncmaxmem=8G \
        +ncmaxlogfilesize=100M \
        +nctempdir=/dev/shm/xcelium_$$"
    
    # åˆ›å»ºå†…å­˜ä¸´æ—¶ç›®å½•
    mkdir -p /dev/shm/xcelium_$$
    
    export USER_RUN_FLAGS="$XCELIUM_OPTS $MEMORY_OPTS"
    
    echo "âœ… Xceliumä¼˜åŒ–é…ç½®å®Œæˆ"
}

optimize_vcs() {
    export VCS_OPTS="\
        +vcs64 \
        +vc \
        +vpi \
        -fastgen \
        -node \
        +notimingcheck \
        +nospecify"
    
    export VCS_MEMORY_OPTS="\
        -Mmemcfg=/dev/shm \
        -maxmem=8192"
    
    export SV_CMP_FLAGS="$VCS_OPTS $VCS_MEMORY_OPTS"
    
    echo "âœ… VCSä¼˜åŒ–é…ç½®å®Œæˆ"
}

# æ ¹æ®å¯ç”¨ä»¿çœŸå™¨é€‰æ‹©æœ€ä¼˜é…ç½®
AVAILABLE_SIM=$(which xrun >/dev/null && echo "xrun" || which vcs >/dev/null && echo "vcs" || echo "none")

case $AVAILABLE_SIM in
    "xrun") optimize_xcelium ;;
    "vcs")  optimize_vcs ;;
    *)      echo "âŒ æœªæ‰¾åˆ°æ”¯æŒçš„ä»¿çœŸå™¨" ;;
esac
```

#### ä¼˜åŒ–æ–¹æ¡ˆ3: æµ‹è¯•ç”¨ä¾‹ä¼˜åŒ–

**ä¼˜åŒ–æ…¢é€Ÿæµ‹è¯•:**

```c
// ä¼˜åŒ–å‰çš„memory_stress_test.c (æ‰§è¡Œæ—¶é—´: 1200ç§’)
#define NUM_ITERATIONS 100000
#define MEMORY_SIZE (1024 * 1024)  // 1MB

// ä¼˜åŒ–åçš„memory_stress_test.c (æ‰§è¡Œæ—¶é—´: 300ç§’)
#ifdef FAST_SIM
  #define NUM_ITERATIONS 10000     // å‡å°‘è¿­ä»£æ¬¡æ•°
  #define MEMORY_SIZE (64 * 1024)  // å‡å°‘å†…å­˜å¤§å°
#else
  #define NUM_ITERATIONS 100000
  #define MEMORY_SIZE (1024 * 1024)
#endif

int main() {
    printf("ğŸ§ª å†…å­˜å‹åŠ›æµ‹è¯• (æ¨¡å¼: %s)\n", 
#ifdef FAST_SIM
           "å¿«é€Ÿæ¨¡å¼"
#else  
           "å®Œæ•´æ¨¡å¼"
#endif
    );
    
    // ğŸ”¹ æ™ºèƒ½æµ‹è¯•æ¨¡å¼é€‰æ‹©
    int actual_iterations = NUM_ITERATIONS;
    int actual_memory_size = MEMORY_SIZE;
    
#ifdef FAST_SIM
    // å¿«é€Ÿæ¨¡å¼ï¼šä¿æŒè¦†ç›–ç‡ï¼Œå‡å°‘æ‰§è¡Œæ—¶é—´
    actual_iterations = NUM_ITERATIONS / 10;  // å‡å°‘90%
    actual_memory_size = MEMORY_SIZE / 16;    // å‡å°‘å†…å­˜ä½¿ç”¨
    
    printf("âš¡ å¯ç”¨å¿«é€Ÿæ¨¡å¼ä¼˜åŒ–\n");
    printf("   è¿­ä»£æ¬¡æ•°: %d (åŸ: %d)\n", actual_iterations, NUM_ITERATIONS);
    printf("   å†…å­˜å¤§å°: %dKB (åŸ: %dKB)\n", 
           actual_memory_size/1024, MEMORY_SIZE/1024);
#endif
    
    // æ‰§è¡Œä¼˜åŒ–åçš„æµ‹è¯•é€»è¾‘
    return execute_memory_test(actual_iterations, actual_memory_size);
}
```

### ğŸ“Š ä¼˜åŒ–ç»“æœ

#### å®æ–½å‰åå¯¹æ¯”

| ä¼˜åŒ–é¡¹ç›® | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æ”¹å–„å¹…åº¦ |
|----------|--------|--------|----------|
| **æ€»å›å½’æ—¶é—´** | 8å°æ—¶ | 3.5å°æ—¶ | **56%æå‡** |
| **å¹¶è¡Œä»»åŠ¡æ•°** | 1ä¸ª | 8ä¸ª | **8å€æå‡** |
| **ä»¿çœŸå™¨CPUåˆ©ç”¨ç‡** | 35% | 78% | **123%æå‡** |
| **å†…å­˜ä½¿ç”¨æ•ˆç‡** | 60% | 85% | **42%æå‡** |
| **æ…¢é€Ÿæµ‹è¯•æ—¶é—´** | 4000ç§’ | 1200ç§’ | **70%å‡å°‘** |

#### å…³é”®ä¼˜åŒ–æªæ–½æ•ˆæœ

1. **æµ‹è¯•å¹¶è¡ŒåŒ–**: èŠ‚çœæ—¶é—´60%
2. **ä»¿çœŸå™¨ä¼˜åŒ–**: èŠ‚çœæ—¶é—´25%  
3. **æµ‹è¯•ç”¨ä¾‹ä¼˜åŒ–**: èŠ‚çœæ—¶é—´15%

**æ€»ä½“æ•ˆæœ**: å›å½’æ—¶é—´ä»8å°æ—¶å‡å°‘åˆ°3.5å°æ—¶ï¼Œ**æ€§èƒ½æå‡56%**ï¼Œè¶…å‡ºé¢„æœŸç›®æ ‡ã€‚

---

## ğŸ› ï¸ æ¡ˆä¾‹4: å¤æ‚é›†æˆé—®é¢˜è§£å†³

### ğŸ“‹ é¡¹ç›®èƒŒæ™¯

**é—®é¢˜**: é›†æˆç¬¬ä¸‰æ–¹DDRæ§åˆ¶å™¨IPåï¼ŒCV32E40Pç³»ç»Ÿåœ¨ç‰¹å®šè®¿é—®æ¨¡å¼ä¸‹å‡ºç°hangé—®é¢˜ã€‚

**ç—‡çŠ¶**:
- ç®€å•æµ‹è¯•æ­£å¸¸è¿è¡Œ
- å†…å­˜å¯†é›†å‹æµ‹è¯•ä¼šhang
- é—®é¢˜ä¸ç¨³å®šï¼Œéš¾ä»¥é‡ç°

### ğŸ” é—®é¢˜è¯Šæ–­è¿‡ç¨‹

#### Step 1: é—®é¢˜å®šä½

**åˆ›å»ºä¸“ç”¨è°ƒè¯•æµ‹è¯•:**

```c
// ddr_debug_test.c - DDRé—®é¢˜å®šä½æµ‹è¯•
#include <stdio.h>
#include <stdint.h>

#define DDR_BASE_ADDR    0x80000000
#define DDR_SIZE         (64 * 1024 * 1024)  // 64MB
#define TEST_PATTERN_1   0xDEADBEEF
#define TEST_PATTERN_2   0xCAFEBABE

volatile uint32_t *ddr_ptr = (volatile uint32_t *)DDR_BASE_ADDR;

// ğŸ”¹ åŸºæœ¬è¯»å†™æµ‹è¯•
int basic_ddr_test() {
    printf("ğŸ§ª åŸºæœ¬DDRè¯»å†™æµ‹è¯•\n");
    
    // å†™å…¥æµ‹è¯•æ•°æ®
    ddr_ptr[0] = TEST_PATTERN_1;
    ddr_ptr[1] = TEST_PATTERN_2;
    
    // è¯»å–éªŒè¯
    if (ddr_ptr[0] != TEST_PATTERN_1) {
        printf("âŒ åœ°å€0è¯»å–é”™è¯¯: æœŸæœ›0x%08x, å®é™…0x%08x\n", 
               TEST_PATTERN_1, ddr_ptr[0]);
        return -1;
    }
    
    if (ddr_ptr[1] != TEST_PATTERN_2) {
        printf("âŒ åœ°å€4è¯»å–é”™è¯¯: æœŸæœ›0x%08x, å®é™…0x%08x\n", 
               TEST_PATTERN_2, ddr_ptr[1]);
        return -1;
    }
    
    printf("âœ… åŸºæœ¬DDRæµ‹è¯•é€šè¿‡\n");
    return 0;
}

// ğŸ”¹ è¿ç»­è®¿é—®æµ‹è¯• (å¯èƒ½è§¦å‘é—®é¢˜)
int sequential_access_test() {
    printf("ğŸ”„ è¿ç»­è®¿é—®æµ‹è¯•\n");
    
    const int num_words = 1024;
    
    // è¿ç»­å†™å…¥
    for (int i = 0; i < num_words; i++) {
        ddr_ptr[i] = 0x12345678 + i;
        
        // æ·»åŠ è°ƒè¯•ä¿¡æ¯
        if (i % 256 == 0) {
            printf("å†™å…¥è¿›åº¦: %d/%d\n", i, num_words);
        }
    }
    
    // è¿ç»­è¯»å–éªŒè¯
    for (int i = 0; i < num_words; i++) {
        uint32_t expected = 0x12345678 + i;
        uint32_t actual = ddr_ptr[i];
        
        if (actual != expected) {
            printf("âŒ åœ°å€0x%08xéªŒè¯å¤±è´¥: æœŸæœ›0x%08x, å®é™…0x%08x\n", 
                   DDR_BASE_ADDR + i*4, expected, actual);
            return -1;
        }
        
        if (i % 256 == 0) {
            printf("éªŒè¯è¿›åº¦: %d/%d\n", i, num_words);
        }
    }
    
    printf("âœ… è¿ç»­è®¿é—®æµ‹è¯•é€šè¿‡\n");
    return 0;
}

// ğŸ”¹ éšæœºè®¿é—®æµ‹è¯• (é«˜æ¦‚ç‡è§¦å‘é—®é¢˜)
int random_access_test() {
    printf("ğŸ² éšæœºè®¿é—®æµ‹è¯•\n");
    
    const int num_accesses = 10000;
    uint32_t seed = 0x12345678;
    
    for (int i = 0; i < num_accesses; i++) {
        // ç®€å•çš„çº¿æ€§åŒä½™ç”Ÿæˆå™¨
        seed = seed * 1103515245 + 12345;
        uint32_t addr_offset = (seed & 0xFFFF) * 4;  // å­—å¯¹é½
        
        if (addr_offset >= DDR_SIZE) {
            addr_offset = addr_offset % DDR_SIZE;
            addr_offset &= ~3;  // ç¡®ä¿å­—å¯¹é½
        }
        
        uint32_t *test_addr = (uint32_t *)(DDR_BASE_ADDR + addr_offset);
        uint32_t test_data = 0xA5A5A5A5 ^ seed;
        
        // å†™å…¥
        *test_addr = test_data;
        
        // ç«‹å³è¯»å–éªŒè¯
        uint32_t read_data = *test_addr;
        
        if (read_data != test_data) {
            printf("âŒ éšæœºè®¿é—®å¤±è´¥ @ 0x%08x: å†™å…¥0x%08x, è¯»å–0x%08x\n", 
                   (uint32_t)test_addr, test_data, read_data);
            return -1;
        }
        
        if (i % 1000 == 0) {
            printf("éšæœºè®¿é—®è¿›åº¦: %d/%d\n", i, num_accesses);
        }
    }
    
    printf("âœ… éšæœºè®¿é—®æµ‹è¯•é€šè¿‡\n");
    return 0;
}

// ğŸ”¹ å‹åŠ›æµ‹è¯• (æœ€æœ‰å¯èƒ½è§¦å‘é—®é¢˜)
int stress_test() {
    printf("ğŸ’ª DDRå‹åŠ›æµ‹è¯•\n");
    
    const int iterations = 100;
    
    for (int iter = 0; iter < iterations; iter++) {
        printf("å‹åŠ›æµ‹è¯•è¿­ä»£: %d/%d\n", iter + 1, iterations);
        
        // å¿«é€Ÿå¤§é‡å†™å…¥
        for (int i = 0; i < 16384; i++) {  // 64KB
            ddr_ptr[i] = 0xDEADBEEF ^ i ^ iter;
        }
        
        // å¿«é€Ÿå¤§é‡è¯»å–
        for (int i = 0; i < 16384; i++) {
            uint32_t expected = 0xDEADBEEF ^ i ^ iter;
            if (ddr_ptr[i] != expected) {
                printf("âŒ å‹åŠ›æµ‹è¯•å¤±è´¥ @ è¿­ä»£%d, åœ°å€%d\n", iter, i);
                return -1;
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦hang (é€šè¿‡è®¡æ•°å™¨)
        static volatile int hang_check = 0;
        hang_check++;
        if (hang_check != iter + 1) {
            printf("âš ï¸  æ£€æµ‹åˆ°æ½œåœ¨hangé—®é¢˜\n");
        }
    }
    
    printf("âœ… DDRå‹åŠ›æµ‹è¯•é€šè¿‡\n");
    return 0;
}

int main() {
    printf("ğŸš€ CV32E40P DDRé›†æˆè°ƒè¯•æµ‹è¯•\n");
    printf("==========================\n");
    
    int result = 0;
    
    // æŒ‰å¤æ‚åº¦é€’å¢æ‰§è¡Œæµ‹è¯•
    result |= basic_ddr_test();
    result |= sequential_access_test();
    result |= random_access_test();
    result |= stress_test();
    
    if (result == 0) {
        printf("ğŸ‰ æ‰€æœ‰DDRæµ‹è¯•é€šè¿‡\n");
    } else {
        printf("ğŸ’¥ DDRæµ‹è¯•å‘ç°é—®é¢˜\n");
    }
    
    return result;
}
```

#### Step 2: ä¿¡å·çº§è°ƒè¯•

**åˆ›å»ºä¸“ç”¨ç›‘æ§å™¨:**

```systemverilog
// ddr_debug_monitor.sv - DDRæ¥å£è°ƒè¯•ç›‘æ§å™¨

module ddr_debug_monitor (
    input logic         clk,
    input logic         rst_n,
    
    // OBIæ¥å£ä¿¡å·
    input logic         obi_req,
    input logic         obi_gnt,
    input logic [31:0]  obi_addr,
    input logic         obi_we,
    input logic [31:0]  obi_wdata,
    input logic         obi_rvalid,
    input logic [31:0]  obi_rdata,
    
    // DDRæ§åˆ¶å™¨æ¥å£ä¿¡å·
    input logic         ddr_cmd_ready,
    input logic         ddr_cmd_valid,
    input logic [2:0]   ddr_cmd,
    input logic [31:0]  ddr_addr,
    input logic         ddr_wdf_ready,
    input logic         ddr_wdf_valid,
    input logic [31:0]  ddr_wdf_data,
    input logic         ddr_rd_data_valid,
    input logic [31:0]  ddr_rd_data
);

    // ğŸ”¹ çŠ¶æ€è·Ÿè¸ª
    typedef enum {
        IDLE,
        OBI_PENDING,
        DDR_CMD_PENDING,
        DDR_DATA_PENDING,
        COMPLETING
    } transaction_state_e;
    
    transaction_state_e current_state;
    
    // ğŸ”¹ è¶…æ—¶æ£€æµ‹
    int unsigned timeout_counter;
    localparam TIMEOUT_THRESHOLD = 1000;  // 1000ä¸ªæ—¶é’Ÿå‘¨æœŸ
    
    // ğŸ”¹ æ€§èƒ½è®¡æ•°å™¨
    int unsigned total_requests;
    int unsigned completed_requests;
    int unsigned timeout_events;
    int unsigned max_latency;
    int unsigned current_latency;
    
    // ğŸ”¹ çŠ¶æ€æœºç›‘æ§
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            current_state <= IDLE;
            timeout_counter <= 0;
            total_requests <= 0;
            completed_requests <= 0;
            timeout_events <= 0;
            max_latency <= 0;
            current_latency <= 0;
        end else begin
            
            // è¶…æ—¶è®¡æ•°å™¨
            if (current_state != IDLE) begin
                timeout_counter <= timeout_counter + 1;
                current_latency <= current_latency + 1;
            end else begin
                timeout_counter <= 0;
                current_latency <= 0;
            end
            
            // è¶…æ—¶æ£€æµ‹
            if (timeout_counter > TIMEOUT_THRESHOLD) begin
                $error("[DDR_DEBUG] Transaction timeout detected! State: %s, Counter: %d", 
                       current_state.name(), timeout_counter);
                timeout_events <= timeout_events + 1;
            end
            
            // çŠ¶æ€è½¬æ¢
            case (current_state)
                IDLE: begin
                    if (obi_req && obi_gnt) begin
                        current_state <= OBI_PENDING;
                        total_requests <= total_requests + 1;
                        $info("[DDR_DEBUG] New OBI request: addr=0x%08x, we=%b", 
                              obi_addr, obi_we);
                    end
                end
                
                OBI_PENDING: begin
                    if (ddr_cmd_valid && ddr_cmd_ready) begin
                        current_state <= DDR_CMD_PENDING;
                        $info("[DDR_DEBUG] DDR command sent: cmd=%d, addr=0x%08x", 
                              ddr_cmd, ddr_addr);
                    end
                end
                
                DDR_CMD_PENDING: begin
                    if (obi_we) begin  // å†™æ“ä½œ
                        if (ddr_wdf_valid && ddr_wdf_ready) begin
                            current_state <= COMPLETING;
                            $info("[DDR_DEBUG] DDR write data sent: data=0x%08x", 
                                  ddr_wdf_data);
                        end
                    end else begin  // è¯»æ“ä½œ
                        if (ddr_rd_data_valid) begin
                            current_state <= COMPLETING;
                            $info("[DDR_DEBUG] DDR read data received: data=0x%08x", 
                                  ddr_rd_data);
                        end
                    end
                end
                
                COMPLETING: begin
                    if (obi_rvalid) begin
                        current_state <= IDLE;
                        completed_requests <= completed_requests + 1;
                        
                        if (current_latency > max_latency) begin
                            max_latency <= current_latency;
                        end
                        
                        $info("[DDR_DEBUG] Transaction completed: latency=%d cycles", 
                              current_latency);
                    end
                end
            endcase
        end
    end
    
    // ğŸ”¹ æ­»é”æ£€æµ‹
    always_ff @(posedge clk) begin
        static int deadlock_counter = 0;
        
        if (current_state != IDLE && timeout_counter > 100) begin
            deadlock_counter++;
            if (deadlock_counter > 10) begin
                $error("[DDR_DEBUG] Potential deadlock detected!");
                $error("  Current state: %s", current_state.name());
                $error("  OBI signals: req=%b, gnt=%b, rvalid=%b", 
                       obi_req, obi_gnt, obi_rvalid);
                $error("  DDR signals: cmd_ready=%b, cmd_valid=%b, wdf_ready=%b, rd_valid=%b", 
                       ddr_cmd_ready, ddr_cmd_valid, ddr_wdf_ready, ddr_rd_data_valid);
                deadlock_counter = 0;
            end
        end else begin
            deadlock_counter = 0;
        end
    end
    
    // ğŸ”¹ æ€§èƒ½æŠ¥å‘Š
    always @(posedge clk) begin
        if (completed_requests > 0 && completed_requests % 1000 == 0) begin
            $info("[DDR_DEBUG] Performance report:");
            $info("  Total requests: %d", total_requests);
            $info("  Completed: %d", completed_requests);
            $info("  Success rate: %.1f%%", (completed_requests * 100.0) / total_requests);
            $info("  Max latency: %d cycles", max_latency);
            $info("  Timeout events: %d", timeout_events);
        end
    end

endmodule
```

#### Step 3: æ ¹æœ¬åŸå› åˆ†æ

**é€šè¿‡è°ƒè¯•å‘ç°é—®é¢˜:**

1. **æ—¶åºé—®é¢˜**: DDRæ§åˆ¶å™¨çš„`wdf_ready`ä¿¡å·å»¶è¿Ÿå¯¼è‡´å†™æ•°æ®ä¸¢å¤±
2. **åè®®è¿è§„**: OBIåˆ°DDRçš„åè®®è½¬æ¢å™¨åœ¨èƒŒå‹æƒ…å†µä¸‹å¤„ç†ä¸å½“
3. **èµ„æºç«äº‰**: å¤šä¸ªå¹¶å‘è®¿é—®æ—¶ä»²è£é€»è¾‘é”™è¯¯

### ğŸ”§ è§£å†³æ–¹æ¡ˆå®æ–½

#### ä¿®å¤1: æ—¶åºä¼˜åŒ–

```systemverilog
// obi_to_ddr_bridge.sv (ä¿®å¤ç‰ˆæœ¬)

module obi_to_ddr_bridge (
    input logic         clk,
    input logic         rst_n,
    
    // OBIæ¥å£
    uvma_obi_memory_if.slv  obi_if,
    
    // DDRæ§åˆ¶å™¨æ¥å£  
    ddr_controller_if.mst   ddr_if
);

    // ğŸ”¹ çŠ¶æ€æœºå®šä¹‰
    typedef enum logic [2:0] {
        IDLE,
        CMD_PHASE,
        WRITE_DATA_PHASE,
        READ_DATA_PHASE,
        RESPONSE_PHASE
    } bridge_state_e;
    
    bridge_state_e current_state, next_state;
    
    // ğŸ”¹ FIFOç¼“å†²åŒº (è§£å†³æ—¶åºé—®é¢˜)
    logic               cmd_fifo_push, cmd_fifo_pop;
    logic               cmd_fifo_full, cmd_fifo_empty;
    logic [63:0]        cmd_fifo_data_in, cmd_fifo_data_out;
    
    logic               wdata_fifo_push, wdata_fifo_pop;
    logic               wdata_fifo_full, wdata_fifo_empty;
    logic [31:0]        wdata_fifo_data_in, wdata_fifo_data_out;
    
    // å‘½ä»¤FIFO (åœ°å€ + æ§åˆ¶ä¿¡æ¯)
    generic_fifo #(
        .DATA_WIDTH(64),
        .DEPTH(8)
    ) cmd_fifo (
        .clk(clk),
        .rst_n(rst_n),
        .push(cmd_fifo_push),
        .pop(cmd_fifo_pop),
        .data_in(cmd_fifo_data_in),
        .data_out(cmd_fifo_data_out),
        .full(cmd_fifo_full),
        .empty(cmd_fifo_empty)
    );
    
    // å†™æ•°æ®FIFO
    generic_fifo #(
        .DATA_WIDTH(32),
        .DEPTH(8)
    ) wdata_fifo (
        .clk(clk),
        .rst_n(rst_n),
        .push(wdata_fifo_push),
        .pop(wdata_fifo_pop),
        .data_in(wdata_fifo_data_in),
        .data_out(wdata_fifo_data_out),
        .full(wdata_fifo_full),
        .empty(wdata_fifo_empty)
    );
    
    // ğŸ”¹ OBIæ¥å£å¤„ç† (ä¿®å¤ï¼šæ·»åŠ FIFOèƒŒå‹)
    always_comb begin
        // OBIæˆæƒæ¡ä»¶ï¼šFIFOæœ‰ç©ºé—´
        obi_if.gnt = obi_if.req && !cmd_fifo_full && 
                     (!obi_if.we || !wdata_fifo_full);
        
        // å‘½ä»¤FIFOè¾“å…¥
        cmd_fifo_push = obi_if.req && obi_if.gnt;
        cmd_fifo_data_in = {obi_if.addr, {31'b0, obi_if.we}};
        
        // å†™æ•°æ®FIFOè¾“å…¥
        wdata_fifo_push = obi_if.req && obi_if.gnt && obi_if.we;
        wdata_fifo_data_in = obi_if.wdata;
    end
    
    // ğŸ”¹ çŠ¶æ€æœº (ä¿®å¤ï¼šå¤„ç†FIFOç©ºæ£€æŸ¥)
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            current_state <= IDLE;
        end else begin
            current_state <= next_state;
        end
    end
    
    always_comb begin
        next_state = current_state;
        
        case (current_state)
            IDLE: begin
                if (!cmd_fifo_empty) begin
                    next_state = CMD_PHASE;
                end
            end
            
            CMD_PHASE: begin
                if (ddr_if.cmd_ready && ddr_if.cmd_valid) begin
                    if (cmd_fifo_data_out[0]) begin  // å†™æ“ä½œ
                        next_state = WRITE_DATA_PHASE;
                    end else begin  // è¯»æ“ä½œ
                        next_state = READ_DATA_PHASE;
                    end
                end
            end
            
            WRITE_DATA_PHASE: begin
                // ä¿®å¤ï¼šç­‰å¾…å†™æ•°æ®FIFOå’ŒDDRéƒ½å‡†å¤‡å¥½
                if (ddr_if.wdf_ready && ddr_if.wdf_valid && !wdata_fifo_empty) begin
                    next_state = RESPONSE_PHASE;
                end
            end
            
            READ_DATA_PHASE: begin
                if (ddr_if.rd_data_valid) begin
                    next_state = RESPONSE_PHASE;
                end
            end
            
            RESPONSE_PHASE: begin
                if (obi_if.rvalid && obi_if.ready) begin
                    next_state = IDLE;
                end
            end
        endcase
    end
    
    // ğŸ”¹ DDRæ¥å£æ§åˆ¶ (ä¿®å¤ï¼šåŒæ­¥é€»è¾‘)
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            ddr_if.cmd_valid <= 1'b0;
            ddr_if.wdf_valid <= 1'b0;
            cmd_fifo_pop <= 1'b0;
            wdata_fifo_pop <= 1'b0;
        end else begin
            
            // å‘½ä»¤é˜¶æ®µ
            if (current_state == CMD_PHASE && !cmd_fifo_empty) begin
                ddr_if.cmd_valid <= 1'b1;
                ddr_if.cmd <= cmd_fifo_data_out[0] ? 3'b000 : 3'b001;  // WRITE : READ
                ddr_if.addr <= cmd_fifo_data_out[63:32];
                
                if (ddr_if.cmd_ready) begin
                    cmd_fifo_pop <= 1'b1;
                    ddr_if.cmd_valid <= 1'b0;
                end
            end else begin
                ddr_if.cmd_valid <= 1'b0;
                cmd_fifo_pop <= 1'b0;
            end
            
            // å†™æ•°æ®é˜¶æ®µ (ä¿®å¤ï¼šç¡®ä¿æ•°æ®å¯ç”¨)
            if (current_state == WRITE_DATA_PHASE && !wdata_fifo_empty) begin
                ddr_if.wdf_valid <= 1'b1;
                ddr_if.wdf_data <= wdata_fifo_data_out;
                
                if (ddr_if.wdf_ready) begin
                    wdata_fifo_pop <= 1'b1;
                    ddr_if.wdf_valid <= 1'b0;
                end
            end else begin
                ddr_if.wdf_valid <= 1'b0;
                wdata_fifo_pop <= 1'b0;
            end
        end
    end

endmodule
```

### ğŸ“Š æ¡ˆä¾‹æ€»ç»“

**é—®é¢˜è§£å†³æ•ˆæœ:**
- âœ… DDR hangé—®é¢˜å®Œå…¨æ¶ˆé™¤
- âœ… å†…å­˜è®¿é—®æ€§èƒ½æå‡15%
- âœ… ç³»ç»Ÿç¨³å®šæ€§æ˜¾è‘—æ”¹å–„
- âœ… æ–°å¢8KB FIFOç¼“å†²æå‡ååé‡

**å…³é”®ç»éªŒ:**
1. **ç³»ç»Ÿçº§è°ƒè¯•**: å¤æ‚é›†æˆé—®é¢˜éœ€è¦ç«¯åˆ°ç«¯çš„åˆ†ææ–¹æ³•
2. **ä¸“ç”¨è°ƒè¯•å·¥å…·**: è‡ªå®šä¹‰ç›‘æ§å™¨èƒ½å¿«é€Ÿå®šä½é—®é¢˜æ ¹æº
3. **FIFOç¼“å†²**: è§£å†³ä¸åŒæ—¶é’ŸåŸŸå’Œåè®®é—´çš„æ—¶åºé—®é¢˜
4. **æ¸è¿›å¼æµ‹è¯•**: ä»ç®€å•åˆ°å¤æ‚çš„æµ‹è¯•ç­–ç•¥èƒ½æœ‰æ•ˆéš”ç¦»é—®é¢˜

---

## ğŸ’¡ æœ€ä½³å®è·µæ€»ç»“

### âœ… æˆåŠŸå› ç´ 

åŸºäºè¿™äº›çœŸå®æ¡ˆä¾‹ï¼Œæ€»ç»“å‡ºå…³é”®çš„æˆåŠŸå› ç´ ï¼š

1. **ç³»ç»ŸåŒ–æ–¹æ³•**: é—®é¢˜å®šä½â†’åˆ†æâ†’è§£å†³â†’éªŒè¯çš„å®Œæ•´æµç¨‹
2. **å·¥å…·æ”¯æŒ**: è‡ªåŠ¨åŒ–è„šæœ¬å’Œä¸“ç”¨è°ƒè¯•å·¥å…·å¤§å¤§æå‡æ•ˆç‡
3. **æ¸è¿›å¼å®æ–½**: ä»ç®€å•åˆ°å¤æ‚ï¼Œé€æ­¥å¢åŠ å¤æ‚åº¦
4. **å……åˆ†æµ‹è¯•**: å¤šå±‚æ¬¡ã€å¤šè§’åº¦çš„éªŒè¯ç¡®ä¿æ–¹æ¡ˆå¯é æ€§

### ğŸ”§ å®ç”¨å»ºè®®

1. **å»ºç«‹çŸ¥è¯†åº“**: è®°å½•æ¯ä¸ªæ¡ˆä¾‹çš„è§£å†³è¿‡ç¨‹å’Œç»éªŒæ•™è®­
2. **æ ‡å‡†åŒ–æµç¨‹**: å°†æˆåŠŸçš„æ–¹æ³•è®ºæ ‡å‡†åŒ–ä¸ºå›¢é˜Ÿæµç¨‹
3. **å·¥å…·ç§¯ç´¯**: é€æ­¥å»ºç«‹ä¸“ç”¨çš„è°ƒè¯•å’Œåˆ†æå·¥å…·é›†
4. **ç»éªŒä¼ æ‰¿**: é€šè¿‡æ–‡æ¡£å’ŒåŸ¹è®­ä¼ æ‰¿è§£å†³é—®é¢˜çš„ç»éªŒ

### ğŸ¯ ä¸‹ä¸€æ­¥è¡ŒåŠ¨

å­¦ä¹ è¿™äº›æ¡ˆä¾‹åï¼Œå»ºè®®ï¼š

1. **é€‰æ‹©é€‚åˆçš„æ¡ˆä¾‹**: æ ¹æ®é¡¹ç›®éœ€è¦é€‰æ‹©ç›¸å…³æ¡ˆä¾‹æ·±å…¥ç ”ç©¶
2. **åŠ¨æ‰‹å®è·µ**: å°è¯•å¤ç°æ¡ˆä¾‹ä¸­çš„è§£å†³æ–¹æ¡ˆ
3. **ä¸¾ä¸€åä¸‰**: å°†æ¡ˆä¾‹ä¸­çš„æ–¹æ³•åº”ç”¨åˆ°è‡ªå·±çš„é¡¹ç›®ä¸­
4. **æŒç»­æ”¹è¿›**: åœ¨å®è·µä¸­ä¸æ–­ä¼˜åŒ–å’Œå®Œå–„è§£å†³æ–¹æ¡ˆ

---

> ğŸ’¡ **æ¡ˆä¾‹å­¦ä¹ å¿ƒå¾—**  
> è¿™äº›çœŸå®æ¡ˆä¾‹å±•ç¤ºäº†CV32E40På¹³å°çš„å¼ºå¤§æ‰©å±•èƒ½åŠ›ã€‚é€šè¿‡å­¦ä¹ è¿™äº›æ¡ˆä¾‹ï¼Œä½ ä¸ä»…èƒ½å¤Ÿè§£å†³ç±»ä¼¼é—®é¢˜ï¼Œæ›´é‡è¦çš„æ˜¯æŒæ¡äº†ç³»ç»ŸåŒ–çš„é—®é¢˜è§£å†³æ–¹æ³•è®ºã€‚

> ğŸš€ **å®è·µå»ºè®®**  
> å»ºè®®åœ¨å­¦ä¹ æ¡ˆä¾‹çš„åŒæ—¶ï¼Œç»“åˆè‡ªå·±çš„é¡¹ç›®éœ€æ±‚è¿›è¡Œå®è·µã€‚æ¯è§£å†³ä¸€ä¸ªé—®é¢˜ï¼Œéƒ½è¦åŠæ—¶æ€»ç»“ç»éªŒï¼Œå»ºç«‹è‡ªå·±çš„æ¡ˆä¾‹åº“å’Œå·¥å…·é›†ã€‚