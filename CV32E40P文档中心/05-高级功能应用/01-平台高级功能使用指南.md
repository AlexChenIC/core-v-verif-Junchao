# CV32E40På¹³å°é«˜çº§åŠŸèƒ½ä½¿ç”¨æŒ‡å— ğŸš€

> **å‘æŒ¥CV32E40PéªŒè¯å¹³å°çš„å…¨éƒ¨æ½œåŠ›**  
> è¦†ç›–ç‡åˆ†æã€COREV-DVç”Ÿæˆå™¨ã€æ€§èƒ½ä¼˜åŒ–ç­‰é«˜çº§åŠŸèƒ½çš„å®Œæ•´ä½¿ç”¨æŒ‡å—

---

## ğŸ“‹ æœ¬æŒ‡å—åŒ…å«åŠŸèƒ½

- ğŸ“Š **è¦†ç›–ç‡æ”¶é›†å’Œåˆ†æ** - åŠŸèƒ½è¦†ç›–ç‡ã€ä»£ç è¦†ç›–ç‡çš„ç³»ç»ŸåŒ–ä½¿ç”¨
- ğŸ² **COREV-DVæµ‹è¯•ç”Ÿæˆ** - Google riscv-dvçš„å®šåˆ¶åŒ–éšæœºæµ‹è¯•ç”Ÿæˆ
- âš¡ **æ€§èƒ½åˆ†æå·¥å…·** - ä»¿çœŸæ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–æŠ€å·§  
- ğŸ”§ **å¤šä»¿çœŸå™¨æ”¯æŒ** - Xceliumã€VCSã€Questaã€Rivieraç­‰çš„é«˜çº§é…ç½®
- ğŸ¯ **Step-and-Compareæœºåˆ¶** - ISSå¯¹æ¯”éªŒè¯çš„æ·±åº¦é…ç½®
- ğŸ“ˆ **å¤§è§„æ¨¡å›å½’æµ‹è¯•** - å¹¶è¡Œæ‰§è¡Œå’Œç»“æœç®¡ç†

---

## ğŸ“Š Part 1: è¦†ç›–ç‡æ”¶é›†å’Œåˆ†æ

### ğŸ¯ è¦†ç›–ç‡ç±»å‹æ¦‚è§ˆ

CV32E40På¹³å°æ”¯æŒå¤šç§è¦†ç›–ç‡ç±»å‹ï¼š

```
è¦†ç›–ç‡å±‚æ¬¡ç»“æ„:
â”œâ”€â”€ åŠŸèƒ½è¦†ç›–ç‡ (Functional Coverage)
â”‚   â”œâ”€â”€ æŒ‡ä»¤è¦†ç›–ç‡ - å„ç±»RISC-VæŒ‡ä»¤çš„æ‰§è¡Œæƒ…å†µ
â”‚   â”œâ”€â”€ æ€»çº¿è¦†ç›–ç‡ - OBIæ¥å£çš„å„ç§è®¿é—®æ¨¡å¼
â”‚   â””â”€â”€ åœºæ™¯è¦†ç›–ç‡ - ä¸­æ–­ã€è°ƒè¯•ã€å¼‚å¸¸ç­‰ç‰¹æ®Šåœºæ™¯
â”œâ”€â”€ ä»£ç è¦†ç›–ç‡ (Code Coverage) 
â”‚   â”œâ”€â”€ è¡Œè¦†ç›–ç‡ (Line Coverage)
â”‚   â”œâ”€â”€ åˆ†æ”¯è¦†ç›–ç‡ (Branch Coverage)  
â”‚   â””â”€â”€ æ¡ä»¶è¦†ç›–ç‡ (Condition Coverage)
â””â”€â”€ æ–­è¨€è¦†ç›–ç‡ (Assertion Coverage)
    â”œâ”€â”€ SVAæ–­è¨€ç›‘æ§
    â””â”€â”€ PSLå±æ€§æ£€æŸ¥
```

### ğŸ”§ è¦†ç›–ç‡æ”¶é›†é…ç½®

#### åŸºç¡€è¦†ç›–ç‡æ”¶é›†

```bash
# ğŸ”¹ è¿è¡Œå¸¦è¦†ç›–ç‡çš„å•ä¸ªæµ‹è¯•
make test TEST=hello-world COV=1

# ğŸ”¹ è¿è¡Œå¸¦è¦†ç›–ç‡çš„å›å½’æµ‹è¯•
make regression COV=1 REGRESSION_NAME=cv32e40p_full

# ğŸ”¹ æŒ‡å®šè¦†ç›–ç‡ç±»å‹
make test TEST=arithmetic_test COV=1 USER_RUN_FLAGS="+coverage_type=functional+code"
```

#### é«˜çº§è¦†ç›–ç‡é…ç½®

**Xceliumè¦†ç›–ç‡é…ç½®:**
```bash
# åˆ›å»ºè¦†ç›–ç‡é…ç½®æ–‡ä»¶
cat > coverage_config.cfg << 'EOF'
# Xceliumè¦†ç›–ç‡é…ç½®
set_cover -du cv32e40p_wrapper -all
set_cover -assert -du cv32e40p_wrapper

# æ’é™¤ä¸éœ€è¦è¦†ç›–çš„æ¨¡å—
set_cover -remove -du mem_model
set_cover -remove -du debug_agent

# åŠŸèƒ½è¦†ç›–ç‡é‡‡æ ·ç‚¹
set_fcover -du cv32e40p_wrapper -all
EOF

# ä½¿ç”¨é…ç½®è¿è¡Œæµ‹è¯•
make test TEST=comprehensive_test COV=1 \
     USER_RUN_FLAGS="+xmcovercfg+coverage_config.cfg"
```

**VCSè¦†ç›–ç‡é…ç½®:**
```bash
# VCSè¦†ç›–ç‡é€‰é¡¹
export SV_CMP_FLAGS="$SV_CMP_FLAGS -cm line+cond+fsm+tgl+branch"
export USER_RUN_FLAGS="+coverage_type=all -cm_name test_coverage"

make test TEST=interrupt_test COV=1
```

### ğŸ“ˆ è¦†ç›–ç‡åˆ†æå·¥å…·

#### è¦†ç›–ç‡æŠ¥å‘Šç”Ÿæˆ

```bash
# ğŸ”¹ ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
make cov TEST=hello-world

# ğŸ”¹ åˆå¹¶å¤šä¸ªæµ‹è¯•çš„è¦†ç›–ç‡
make merge_cov TESTS="test1,test2,test3" MERGED_COV_NAME="regression_coverage"

# ğŸ”¹ ç”ŸæˆHTMLæŠ¥å‘Š
make cov_report COV_NAME=regression_coverage FORMAT=html
```

#### è¦†ç›–ç‡åˆ†æè„šæœ¬

```bash
#!/bin/bash
# coverage_analyzer.sh - è¦†ç›–ç‡åˆ†æè‡ªåŠ¨åŒ–å·¥å…·

COV_DB_PATH=${1:-"coverage.vdb"}
TARGET_COVERAGE=${2:-"90"}

echo "ğŸ“Š è¦†ç›–ç‡åˆ†ææŠ¥å‘Š"
echo "=================="

# ğŸ”¹ æ€»ä½“è¦†ç›–ç‡ç»Ÿè®¡
echo "1. æ€»ä½“è¦†ç›–ç‡:"
urg -dir $COV_DB_PATH -report summary | grep -E "(Overall|Total)" | head -5

# ğŸ”¹ æ¨¡å—çº§è¦†ç›–ç‡åˆ†æ
echo "2. æ¨¡å—è¦†ç›–ç‡:"
urg -dir $COV_DB_PATH -report hierarchy | grep -E "cv32e40p|core" | head -10

# ğŸ”¹ æœªè¦†ç›–çš„å…³é”®åŠŸèƒ½è¯†åˆ«
echo "3. è¦†ç›–ç‡ç¼ºå£åˆ†æ:"
urg -dir $COV_DB_PATH -report uncovered | head -20

# ğŸ”¹ è¦†ç›–ç‡è¶‹åŠ¿åˆ†æ
if [ -f "coverage_history.log" ]; then
    echo "4. è¦†ç›–ç‡è¶‹åŠ¿:"
    tail -10 coverage_history.log
fi

# ğŸ”¹ è´¨é‡é—¨æ£€æŸ¥
CURRENT_COVERAGE=$(urg -dir $COV_DB_PATH -report summary | grep "Overall" | awk '{print $3}' | sed 's/%//')
if (( $(echo "$CURRENT_COVERAGE >= $TARGET_COVERAGE" | bc -l) )); then
    echo "âœ… è¦†ç›–ç‡è´¨é‡é—¨æ£€æŸ¥é€šè¿‡: $CURRENT_COVERAGE% >= $TARGET_COVERAGE%"
else
    echo "âŒ è¦†ç›–ç‡è´¨é‡é—¨æ£€æŸ¥å¤±è´¥: $CURRENT_COVERAGE% < $TARGET_COVERAGE%"
    exit 1
fi
```

#### åŠŸèƒ½è¦†ç›–ç‡è‡ªå®šä¹‰

```systemverilog
// è‡ªå®šä¹‰åŠŸèƒ½è¦†ç›–ç‡æ¨¡å‹
class cv32e40p_custom_coverage extends uvm_component;
   
   // ğŸ”¹ æŒ‡ä»¤ç±»å‹è¦†ç›–ç‡
   covergroup instr_type_cg @(posedge clk);
      INSTR_TYPE: coverpoint instr_type {
         bins arithmetic = {ADD, SUB, MUL, DIV};
         bins logical    = {AND, OR, XOR, NOT};
         bins memory     = {LW, SW, LB, SB};
         bins branch     = {BEQ, BNE, BLT, BGE};
         bins jump       = {JAL, JALR};
         
         // éæ³•æŒ‡ä»¤è¦†ç›–
         illegal_bins illegal = {32'h0000_0000, 32'hFFFF_FFFF};
      }
   endgroup
   
   // ğŸ”¹ æ€»çº¿è®¿é—®æ¨¡å¼è¦†ç›–ç‡
   covergroup obi_access_cg @(posedge clk);
      REQ_VALID: coverpoint obi_req iff(obi_req);
      
      ADDR_ALIGN: coverpoint obi_addr[1:0] {
         bins word_aligned = {2'b00};
         bins half_aligned = {2'b10}; 
         bins byte_aligned = {2'b01, 2'b11};
      }
      
      BURST_TYPE: coverpoint {obi_req, obi_gnt} {
         bins single_cycle = {2'b11};
         bins wait_grant   = {2'b10};
         bins back_to_back = {2'b11, 2'b11};
      }
      
      // äº¤å‰è¦†ç›–ï¼šåœ°å€å¯¹é½ Ã— è®¿é—®ç±»å‹
      ADDR_ACCESS_CROSS: cross ADDR_ALIGN, REQ_VALID;
   endgroup
   
   // ğŸ”¹ ä¸­æ–­å’Œå¼‚å¸¸è¦†ç›–ç‡
   covergroup interrupt_cg @(posedge clk);
      IRQ_TYPE: coverpoint irq_id {
         bins timer_irq    = {[0:7]};
         bins external_irq = {[8:15]};
         bins software_irq = {[16:23]};
      }
      
      IRQ_TIMING: coverpoint cpu_state {
         bins idle_state   = {IDLE};
         bins fetch_state  = {FETCH};
         bins decode_state = {DECODE};
         bins execute_state = {EXECUTE};
      }
      
      // ä¸­æ–­åµŒå¥—åœºæ™¯
      IRQ_NESTING: cross IRQ_TYPE, IRQ_TIMING;
   endgroup
   
   function new(string name, uvm_component parent);
      super.new(name, parent);
      instr_type_cg = new();
      obi_access_cg = new();  
      interrupt_cg = new();
   endfunction
   
   // ğŸ”¹ è¦†ç›–ç‡é‡‡æ ·
   task run_phase(uvm_phase phase);
      forever begin
         @(posedge clk);
         
         // é‡‡æ ·å„ç§è¦†ç›–ç‡
         if (instr_valid) instr_type_cg.sample();
         if (obi_req) obi_access_cg.sample();
         if (irq_valid) interrupt_cg.sample();
      end
   endtask
   
endclass
```

---

## ğŸ² Part 2: COREV-DVéšæœºæµ‹è¯•ç”Ÿæˆ

### ğŸ—ï¸ COREV-DVæ¶æ„æ¦‚è§ˆ

COREV-DVæ˜¯åŸºäºGoogle riscv-dvçš„æ‰©å±•æµ‹è¯•ç”Ÿæˆå™¨ï¼š

```
COREV-DVæ¶æ„:
â”œâ”€â”€ Google riscv-dv (åŸºç¡€æ¡†æ¶)
â”‚   â”œâ”€â”€ æŒ‡ä»¤åºåˆ—ç”Ÿæˆå™¨
â”‚   â”œâ”€â”€ çº¦æŸéšæœºåŒ–å¼•æ“  
â”‚   â””â”€â”€ æ±‡ç¼–ä»£ç ç”Ÿæˆ
â”œâ”€â”€ é€šç”¨COREVæ‰©å±• (/lib/corev-dv)
â”‚   â”œâ”€â”€ OpenHWç‰¹å®šæŒ‡ä»¤
â”‚   â”œâ”€â”€ éªŒè¯åœºæ™¯æ‰©å±•
â”‚   â””â”€â”€ è¦†ç›–ç‡å¢å¼º
â””â”€â”€ CV32E40Pä¸“ç”¨æ‰©å±• (/cv32e40p/env/corev-dv)
    â”œâ”€â”€ PULPæŒ‡ä»¤æ”¯æŒ
    â”œâ”€â”€ ä¸­æ–­æµ‹è¯•å¢å¼º
    â””â”€â”€ è°ƒè¯•åŠŸèƒ½æµ‹è¯•
```

### ğŸš€ COREV-DVåŸºç¡€ä½¿ç”¨

#### ç”Ÿæˆå’Œè¿è¡ŒCOREV-DVæµ‹è¯•

```bash
# ğŸ”¹ ç”Ÿæˆå•ä¸ªéšæœºæµ‹è¯•
make gen_corev-dv TEST=corev_rand_arithmetic_base_test

# ğŸ”¹ ç”Ÿæˆå¹¶è¿è¡Œæµ‹è¯•
make corev-dv TEST=corev_rand_interrupt_test

# ğŸ”¹ æ‰¹é‡ç”Ÿæˆå¤šä¸ªæµ‹è¯•
make gen_corev-dv TEST=corev_rand_stress_test GEN_NUM_TESTS=10

# ğŸ”¹ ä½¿ç”¨ç‰¹å®šé…ç½®ç”Ÿæˆ
make gen_corev-dv TEST=corev_rand_pulp_test CFG=pulp
```

#### COREV-DVé…ç½®æ–‡ä»¶è¯¦è§£

åˆ›å»ºè‡ªå®šä¹‰COREV-DVé…ç½® `custom_corev_dv.yaml`:

```yaml
# custom_corev_dv.yaml - è‡ªå®šä¹‰COREV-DVæµ‹è¯•é…ç½®

# ğŸ”¹ åŸºç¡€æµ‹è¯•ä¿¡æ¯
name: custom_random_test
uvm_test: $(CV_CORE_LC)_instr_base_test
description: >
    è‡ªå®šä¹‰éšæœºæŒ‡ä»¤æµ‹è¯•ï¼Œé‡ç‚¹éªŒè¯ç®—æœ¯è¿ç®—å’Œå†…å­˜è®¿é—®

# ğŸ”¹ æ ¸å¿ƒç”Ÿæˆå‚æ•°
plusargs: >
    +instr_cnt=50000                    # æŒ‡ä»¤æ•°é‡
    +num_of_sub_program=5               # å­ç¨‹åºæ•°é‡
    +directed_instr_0=riscv_int_numeric_corner_stream,8    # ç®—æœ¯è¾¹ç•Œæµ‹è¯•
    +directed_instr_1=riscv_load_store_stress_instr_stream,4  # å†…å­˜è®¿é—®å‹åŠ›æµ‹è¯•
    +directed_instr_2=riscv_multi_page_load_store_instr_stream,2  # è·¨é¡µè®¿é—®æµ‹è¯•

# ğŸ”¹ çº¦æŸé…ç½®
constraints: >
    +no_fence=0                         # å…è®¸fenceæŒ‡ä»¤
    +no_data_page=0                     # å…è®¸æ•°æ®é¡µ
    +no_branch_jump=0                   # å…è®¸åˆ†æ”¯è·³è½¬
    +boot_mode=m                        # æœºå™¨æ¨¡å¼å¯åŠ¨
    +no_csr_instr=0                     # å…è®¸CSRæŒ‡ä»¤
    +enable_interrupt=1                 # å¯ç”¨ä¸­æ–­
    +enable_nested_interrupt=1          # å¯ç”¨ä¸­æ–­åµŒå¥—

# ğŸ”¹ è¦†ç›–ç‡å¢å¼º
coverage: >
    +enable_inst_cov=1                  # æŒ‡ä»¤è¦†ç›–ç‡
    +enable_branch_cov=1                # åˆ†æ”¯è¦†ç›–ç‡
    +enable_toggle_cov=1                # ä¿¡å·ç¿»è½¬è¦†ç›–ç‡

# ğŸ”¹ ç‰¹æ®Šåœºæ™¯é…ç½®
scenarios:
    arithmetic_focus:
        directed_instr_0: riscv_int_numeric_corner_stream,20
        no_branch_jump: 1
        
    memory_stress:
        directed_instr_0: riscv_load_store_stress_instr_stream,15
        enable_unaligned_load_store: 1
        
    interrupt_heavy:
        enable_interrupt: 1
        interrupt_rate: high
        enable_nested_interrupt: 1
```

#### è¿è¡Œè‡ªå®šä¹‰é…ç½®

```bash
# ä½¿ç”¨è‡ªå®šä¹‰é…ç½®ç”Ÿæˆæµ‹è¯•
make gen_corev-dv TEST=custom_random_test \
     COREV_DV_CONFIG=custom_corev_dv.yaml \
     GEN_NUM_TESTS=5

# è¿è¡Œç‰¹å®šåœºæ™¯
make corev-dv TEST=custom_random_test \
     SCENARIO=memory_stress
```

### ğŸ¯ é«˜çº§COREV-DVå®šåˆ¶

#### åˆ›å»ºè‡ªå®šä¹‰æŒ‡ä»¤æµ

```systemverilog
// custom_instruction_stream.sv - è‡ªå®šä¹‰æŒ‡ä»¤æµç”Ÿæˆå™¨
class cv32e40p_custom_instr_stream extends riscv_directed_instr_stream;
   
   `uvm_object_utils(cv32e40p_custom_instr_stream)
   
   // ğŸ”¹ PULPæ‰©å±•æŒ‡ä»¤å®šä¹‰
   riscv_instr_name_t pulp_instrs[] = {
      // PULPç®—æœ¯æŒ‡ä»¤
      P_ABS, P_SLET, P_SLETU, P_MIN, P_MINU, P_MAX, P_MAXU,
      // PULPä¹˜æ³•æŒ‡ä»¤  
      P_MUL, P_MULH, P_MULHSU, P_MULHU,
      // PULPä½æ“ä½œæŒ‡ä»¤
      P_FF1, P_FL1, P_CLB, P_CNT, P_ROR
   };
   
   // ğŸ”¹ çº¦æŸå®šä¹‰
   constraint instr_dist_c {
      // PULPæŒ‡ä»¤åˆ†å¸ƒ
      foreach(instr_list[i]) {
         if (instr_list[i].instr_name inside {pulp_instrs}) {
            instr_list[i].weight == 20;  // é«˜æƒé‡
         }
      }
      
      // æŒ‡ä»¤åºåˆ—é•¿åº¦
      instr_list.size() inside {[50:200]};
   }
   
   // ğŸ”¹ ç”Ÿæˆé€»è¾‘
   virtual function void gen_instr(bit no_branch = 1'b0, 
                                  bit no_load_store = 1'b0,
                                  bit is_debug_program = 1'b0);
      
      `uvm_info("CUSTOM_STREAM", "ç”Ÿæˆè‡ªå®šä¹‰PULPæŒ‡ä»¤æµ", UVM_MEDIUM)
      
      // åŸºç¡€æŒ‡ä»¤ç”Ÿæˆ
      super.gen_instr(no_branch, no_load_store, is_debug_program);
      
      // æ·»åŠ ç‰¹æ®Šçš„PULPæŒ‡ä»¤åºåˆ—
      add_pulp_specific_sequences();
      
      // æ·»åŠ é”™è¯¯æ³¨å…¥
      if ($urandom_range(0, 100) < 10) begin  // 10%æ¦‚ç‡
         inject_corner_cases();
      end
      
   endfunction
   
   // ğŸ”¹ PULPç‰¹å®šåºåˆ—
   virtual function void add_pulp_specific_sequences();
      riscv_instr instr;
      
      // PULPä¹˜æ³•æµ‹è¯•åºåˆ—
      repeat($urandom_range(5, 15)) begin
         instr = riscv_instr::type_id::create("pulp_mul_instr");
         instr.instr_name = pulp_instrs[$urandom_range(0, pulp_instrs.size()-1)];
         instr.randomize();
         instr_list.push_back(instr);
      end
      
      `uvm_info("CUSTOM_STREAM", 
               $sformatf("æ·»åŠ %0dæ¡PULPç‰¹å®šæŒ‡ä»¤", instr_list.size()), UVM_HIGH)
   endfunction
   
   // ğŸ”¹ è¾¹ç•Œæƒ…å†µæ³¨å…¥
   virtual function void inject_corner_cases();
      // é™¤é›¶æµ‹è¯•
      add_divide_by_zero_case();
      
      // æº¢å‡ºæµ‹è¯•  
      add_overflow_test_case();
      
      // éå¯¹é½è®¿é—®æµ‹è¯•
      add_unaligned_access_case();
   endfunction
   
endclass

// æ³¨å†Œè‡ªå®šä¹‰æŒ‡ä»¤æµ
`uvm_object_registry(cv32e40p_custom_instr_stream, "cv32e40p_custom_instr_stream")
```

#### é›†æˆè‡ªå®šä¹‰æŒ‡ä»¤æµ

```bash
# åˆ›å»ºä½¿ç”¨è‡ªå®šä¹‰æŒ‡ä»¤æµçš„é…ç½®
cat > pulp_custom_test.yaml << 'EOF'
name: pulp_custom_enhanced_test
uvm_test: $(CV_CORE_LC)_instr_base_test
description: >
    ä½¿ç”¨è‡ªå®šä¹‰PULPæŒ‡ä»¤æµçš„å¢å¼ºæµ‹è¯•

plusargs: >
    +instr_cnt=30000
    +directed_instr_0=cv32e40p_custom_instr_stream,10
    +boot_mode=m
    +enable_interrupt=1
EOF

# è¿è¡Œè‡ªå®šä¹‰æµ‹è¯•
make gen_corev-dv TEST=pulp_custom_enhanced_test
make test TEST=pulp_custom_enhanced_test
```

### ğŸ“Š COREV-DVç»“æœåˆ†æ

#### è‡ªåŠ¨åŒ–ç»“æœæ”¶é›†

```bash
#!/bin/bash
# corev_dv_analyzer.sh - COREV-DVç»“æœåˆ†æå·¥å…·

TEST_NAME=${1:-"corev_rand_base_test"}
NUM_TESTS=${2:-"10"}

echo "ğŸ² COREV-DVæµ‹è¯•åˆ†ææŠ¥å‘Š"
echo "======================="

# ğŸ”¹ æµ‹è¯•æ‰§è¡Œç»Ÿè®¡
echo "1. æ‰§è¡Œç»Ÿè®¡:"
PASSED=$(find . -name "*${TEST_NAME}*" -path "*/test_results/*" -exec grep -l "TEST PASSED" {} \; | wc -l)
FAILED=$(find . -name "*${TEST_NAME}*" -path "*/test_results/*" -exec grep -l "TEST FAILED" {} \; | wc -l)
TOTAL=$((PASSED + FAILED))

echo "   æ€»æµ‹è¯•æ•°: $TOTAL"
echo "   é€šè¿‡æ•°: $PASSED"  
echo "   å¤±è´¥æ•°: $FAILED"
echo "   é€šè¿‡ç‡: $(echo "scale=2; $PASSED*100/$TOTAL" | bc)%"

# ğŸ”¹ æŒ‡ä»¤è¦†ç›–ç‡åˆ†æ
echo "2. æŒ‡ä»¤è¦†ç›–ç‡:"
if command -v riscv32-unknown-elf-objdump &> /dev/null; then
    # åˆ†æç”Ÿæˆçš„æ±‡ç¼–ä»£ç 
    find . -name "*${TEST_NAME}*.S" | head -5 | while read asm_file; do
        echo "   æ–‡ä»¶: $(basename $asm_file)"
        grep -E "^\s*(add|sub|mul|div|lw|sw)" "$asm_file" | \
            awk '{print $1}' | sort | uniq -c | sort -nr | head -5
    done
fi

# ğŸ”¹ é”™è¯¯æ¨¡å¼åˆ†æ
echo "3. å¸¸è§é”™è¯¯:"
find . -name "*${TEST_NAME}*" -path "*/test_results/*" -exec grep -l "TEST FAILED" {} \; | \
    head -5 | while read log_file; do
        echo "   å¤±è´¥åŸå› :"
        grep -A5 -B5 "FAILED\|ERROR\|FATAL" "$log_file" | head -3
    done

# ğŸ”¹ æ€§èƒ½åˆ†æ
echo "4. æ€§èƒ½æŒ‡æ ‡:"
find . -name "*${TEST_NAME}*" -path "*/test_results/*" -exec grep "Simulation time" {} \; | \
    awk '{print $3}' | sort -n | \
    awk '
    {
        times[NR] = $1
        sum += $1
    }
    END {
        print "   å¹³å‡ä»¿çœŸæ—¶é—´: " sum/NR "s"
        print "   æœ€çŸ­æ—¶é—´: " times[1] "s"  
        print "   æœ€é•¿æ—¶é—´: " times[NR] "s"
    }'
```

---

## âš¡ Part 3: æ€§èƒ½åˆ†æå’Œä¼˜åŒ–

### ğŸ“ˆ ä»¿çœŸæ€§èƒ½ç›‘æ§

#### å®æ—¶æ€§èƒ½ç›‘æ§è„šæœ¬

```bash
#!/bin/bash
# sim_performance_monitor.sh - ä»¿çœŸæ€§èƒ½å®æ—¶ç›‘æ§

SIMULATOR=${CV_SIMULATOR:-"xrun"}
MONITOR_INTERVAL=${1:-"5"}  # 5ç§’é‡‡æ ·é—´éš”

echo "âš¡ ä»¿çœŸæ€§èƒ½å®æ—¶ç›‘æ§"
echo "=================="

# ğŸ”¹ åˆ›å»ºæ€§èƒ½æ—¥å¿—æ–‡ä»¶
PERF_LOG="sim_performance_$(date +%Y%m%d_%H%M%S).log"
echo "æ—¶é—´æˆ³,CPUä½¿ç”¨ç‡(%),å†…å­˜ä½¿ç”¨(MB),ä»¿çœŸæ—¶é—´(ns),å®é™…æ—¶é—´(s)" > $PERF_LOG

# ğŸ”¹ ç›‘æ§å¾ªç¯
while true; do
    TIMESTAMP=$(date +"%H:%M:%S")
    
    # è·å–ä»¿çœŸå™¨è¿›ç¨‹ä¿¡æ¯
    SIM_PID=$(pgrep -f $SIMULATOR | head -1)
    
    if [ -n "$SIM_PID" ]; then
        # CPUå’Œå†…å­˜ä½¿ç”¨ç‡
        CPU_USAGE=$(ps -p $SIM_PID -o %cpu --no-headers | tr -d ' ')
        MEM_USAGE=$(ps -p $SIM_PID -o rss --no-headers | tr -d ' ')
        MEM_MB=$((MEM_USAGE / 1024))
        
        # ä»¿çœŸæ—¶é—´ (ä»æ—¥å¿—æ–‡ä»¶æå–)
        SIM_TIME="N/A"
        if [ -f "$(ls -t *.log 2>/dev/null | head -1)" ]; then
            LATEST_LOG="$(ls -t *.log | head -1)"
            SIM_TIME=$(grep "Time:" "$LATEST_LOG" | tail -1 | awk '{print $2}' || echo "N/A")
        fi
        
        # å®é™…è¿è¡Œæ—¶é—´
        START_TIME=$(ps -p $SIM_PID -o etime --no-headers | tr -d ' ')
        
        # è¾“å‡ºåˆ°æ§åˆ¶å°
        printf "%-8s CPU:%-6s%% MEM:%-8sMB SIM:%-12s REAL:%-10s\n" \
               "$TIMESTAMP" "$CPU_USAGE" "$MEM_MB" "$SIM_TIME" "$START_TIME"
        
        # è®°å½•åˆ°æ—¥å¿—
        echo "$TIMESTAMP,$CPU_USAGE,$MEM_MB,$SIM_TIME,$START_TIME" >> $PERF_LOG
        
        # ğŸ”¹ æ€§èƒ½è­¦å‘Š
        if (( $(echo "$CPU_USAGE > 95" | bc -l) )); then
            echo "âš ï¸  è­¦å‘Š: CPUä½¿ç”¨ç‡è¿‡é«˜ ($CPU_USAGE%)"
        fi
        
        if (( MEM_MB > 8192 )); then
            echo "âš ï¸  è­¦å‘Š: å†…å­˜ä½¿ç”¨è¿‡é«˜ (${MEM_MB}MB)"
        fi
        
    else
        echo "$TIMESTAMP - æœªæ£€æµ‹åˆ°ä»¿çœŸè¿›ç¨‹"
    fi
    
    sleep $MONITOR_INTERVAL
done
```

#### æ€§èƒ½åŸºå‡†æµ‹è¯•

```bash
#!/bin/bash
# sim_benchmark.sh - ä»¿çœŸæ€§èƒ½åŸºå‡†æµ‹è¯•

BENCHMARK_TESTS=("hello-world" "arithmetic_test" "interrupt_test" "memory_stress")
ITERATIONS=3

echo "ğŸ“Š ä»¿çœŸæ€§èƒ½åŸºå‡†æµ‹è¯•"
echo "=================="

# ğŸ”¹ åˆ›å»ºåŸºå‡†æµ‹è¯•æŠ¥å‘Š
REPORT_FILE="benchmark_report_$(date +%Y%m%d_%H%M%S).txt"
{
    echo "CV32E40Pä»¿çœŸæ€§èƒ½åŸºå‡†æµ‹è¯•æŠ¥å‘Š"
    echo "æµ‹è¯•ç¯å¢ƒ: $(uname -a)"
    echo "ä»¿çœŸå™¨: $CV_SIMULATOR"
    echo "æµ‹è¯•æ—¶é—´: $(date)"
    echo "=================================="
    echo ""
} > $REPORT_FILE

# ğŸ”¹ æ‰§è¡ŒåŸºå‡†æµ‹è¯•
for test in "${BENCHMARK_TESTS[@]}"; do
    echo "ğŸ§ª æµ‹è¯•: $test"
    echo "æµ‹è¯•: $test" >> $REPORT_FILE
    
    total_time=0
    for i in $(seq 1 $ITERATIONS); do
        echo "  ç¬¬${i}æ¬¡è¿è¡Œ..."
        
        # æ¸…ç†ä¹‹å‰çš„ç»“æœ
        make clean_test TEST=$test >/dev/null 2>&1
        
        # æ‰§è¡Œæµ‹è¯•å¹¶è®¡æ—¶
        start_time=$(date +%s.%N)
        make test TEST=$test >/dev/null 2>&1
        end_time=$(date +%s.%N)
        
        # è®¡ç®—æ‰§è¡Œæ—¶é—´
        execution_time=$(echo "$end_time - $start_time" | bc)
        total_time=$(echo "$total_time + $execution_time" | bc)
        
        echo "    æ‰§è¡Œæ—¶é—´: ${execution_time}ç§’"
        echo "  è¿è¡Œ${i}: ${execution_time}ç§’" >> $REPORT_FILE
    done
    
    # è®¡ç®—å¹³å‡æ—¶é—´
    avg_time=$(echo "scale=3; $total_time / $ITERATIONS" | bc)
    echo "  å¹³å‡æ—¶é—´: ${avg_time}ç§’"
    echo "  å¹³å‡æ—¶é—´: ${avg_time}ç§’" >> $REPORT_FILE
    echo "" >> $REPORT_FILE
    echo ""
done

echo "ğŸ“‹ åŸºå‡†æµ‹è¯•å®Œæˆï¼ŒæŠ¥å‘Šä¿å­˜åœ¨: $REPORT_FILE"
```

### ğŸ”§ æ€§èƒ½ä¼˜åŒ–é…ç½®

#### ä»¿çœŸå™¨ç‰¹å®šä¼˜åŒ–

**Xceliumä¼˜åŒ–é…ç½®:**
```bash
# xcelium_performance.cfg - Xceliumæ€§èƒ½ä¼˜åŒ–é…ç½®
cat > xcelium_performance.cfg << 'EOF'
# ç¼–è¯‘ä¼˜åŒ–
set_compile_option -64bit
set_compile_option -O3
set_compile_option -nospecify
set_compile_option -notimingchecks

# è¿è¡Œæ—¶ä¼˜åŒ–  
set_runtime_option -64bit
set_runtime_option -noassert
set_runtime_option -nowarn CGDEFN
set_runtime_option -threads 4

# å†…å­˜ä¼˜åŒ–
set_memory_option -pool_size 2GB
set_memory_option -gc_interval 1000000
EOF

# ä½¿ç”¨ä¼˜åŒ–é…ç½®
export USER_RUN_FLAGS="+xmconfig+xcelium_performance.cfg"
make test TEST=performance_test
```

**VCSä¼˜åŒ–é…ç½®:**
```bash
# VCSæ€§èƒ½ä¼˜åŒ–é€‰é¡¹
export VCS_PERFORMANCE_FLAGS="\
    +vcs+lic+wait \
    -timescale=1ns/1ps \
    -debug_access+r \
    -kdb=common_elab,hgldd_all \
    +vcs64 \
    -j4"

export SV_CMP_FLAGS="$SV_CMP_FLAGS $VCS_PERFORMANCE_FLAGS"
make test TEST=vcs_performance_test
```

### ğŸ“Š å†…å­˜ä½¿ç”¨ä¼˜åŒ–

#### å†…å­˜ç›‘æ§å’Œä¼˜åŒ–

```bash
#!/bin/bash
# memory_optimizer.sh - å†…å­˜ä½¿ç”¨ä¼˜åŒ–å·¥å…·

TEST_NAME=${1:-"memory_stress"}

echo "ğŸ’¾ å†…å­˜ä½¿ç”¨ä¼˜åŒ–åˆ†æ"
echo "=================="

# ğŸ”¹ è¿è¡Œå‰å†…å­˜çŠ¶æ€
echo "1. ç³»ç»Ÿå†…å­˜çŠ¶æ€:"
free -h

# ğŸ”¹ ä»¿çœŸæœŸé—´å†…å­˜ç›‘æ§
echo "2. å¯åŠ¨å†…å­˜ç›‘æ§..."
(
    while true; do
        if pgrep -f $CV_SIMULATOR >/dev/null; then
            # è®°å½•ä»¿çœŸå™¨å†…å­˜ä½¿ç”¨
            SIM_PID=$(pgrep -f $CV_SIMULATOR | head -1)
            MEM_USAGE=$(ps -p $SIM_PID -o rss --no-headers)
            MEM_MB=$((MEM_USAGE / 1024))
            echo "$(date '+%H:%M:%S') ä»¿çœŸå™¨å†…å­˜: ${MEM_MB}MB"
            
            # å†…å­˜è¿‡é«˜æ—¶çš„ä¼˜åŒ–å»ºè®®
            if (( MEM_MB > 4096 )); then
                echo "âš ï¸  å†…å­˜ä½¿ç”¨è¿‡é«˜ï¼Œå»ºè®®:"
                echo "   - å‡å°‘æ³¢å½¢è®°å½•èŒƒå›´"
                echo "   - ç¦ç”¨ä¸å¿…è¦çš„debugä¿¡æ¯"  
                echo "   - ä½¿ç”¨+UVM_NO_RELNOTES"
            fi
        fi
        sleep 10
    done
) &
MONITOR_PID=$!

# ğŸ”¹ è¿è¡Œæµ‹è¯•
echo "3. è¿è¡Œæµ‹è¯•: $TEST_NAME"
make test TEST=$TEST_NAME USER_RUN_FLAGS="+UVM_NO_RELNOTES +define+NO_ASSERT"

# ğŸ”¹ åœæ­¢ç›‘æ§
kill $MONITOR_PID 2>/dev/null

echo "4. å†…å­˜ä¼˜åŒ–å»ºè®®:"
echo "   âœ… ä½¿ç”¨+UVM_NO_RELNOTESå‡å°‘UVMå¼€é”€"
echo "   âœ… ä½¿ç”¨+define+NO_ASSERTç¦ç”¨æ–­è¨€"
echo "   âœ… é™åˆ¶æ³¢å½¢æ–‡ä»¶å¤§å°"
echo "   âœ… å®šæœŸæ¸…ç†ä¸´æ—¶æ–‡ä»¶"
```

---

## ğŸ”§ Part 4: å¤šä»¿çœŸå™¨é«˜çº§é…ç½®

### ğŸ¯ ä»¿çœŸå™¨å¯¹æ¯”é…ç½®

#### ç»Ÿä¸€çš„ä»¿çœŸå™¨é…ç½®ç®¡ç†

```bash
#!/bin/bash
# simulator_manager.sh - å¤šä»¿çœŸå™¨ç®¡ç†å·¥å…·

SIMULATORS=("xrun" "vcs" "vsim" "riviera")
TEST_NAME=${1:-"hello-world"}

echo "ğŸ”§ å¤šä»¿çœŸå™¨é…ç½®ç®¡ç†"
echo "=================="

# ğŸ”¹ ä»¿çœŸå™¨å¯ç”¨æ€§æ£€æŸ¥
echo "1. ä»¿çœŸå™¨å¯ç”¨æ€§æ£€æŸ¥:"
for sim in "${SIMULATORS[@]}"; do
    if command -v $sim &> /dev/null; then
        echo "   âœ… $sim: å¯ç”¨"
    else
        echo "   âŒ $sim: ä¸å¯ç”¨"
    fi
done

# ğŸ”¹ è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜ä»¿çœŸå™¨
select_best_simulator() {
    # ä¼˜å…ˆçº§: xrun > vcs > vsim > riviera
    for sim in "xrun" "vcs" "vsim" "riviera"; do
        if command -v $sim &> /dev/null; then
            echo $sim
            return
        fi
    done
    echo "unsim"  # æœªæ‰¾åˆ°å¯ç”¨ä»¿çœŸå™¨
}

BEST_SIM=$(select_best_simulator)
echo "2. æ¨èä»¿çœŸå™¨: $BEST_SIM"

# ğŸ”¹ ä»¿çœŸå™¨ç‰¹å®šé…ç½®
configure_simulator() {
    local sim=$1
    case $sim in
        "xrun")
            export CV_SIMULATOR=xrun
            export USER_RUN_FLAGS="+nc64bit +access+rw +notimingchecks"
            echo "   Xceliumé…ç½®: 64ä½, å®Œå…¨è®¿é—®, æ— æ—¶åºæ£€æŸ¥"
            ;;
        "vcs")
            export CV_SIMULATOR=vcs  
            export USER_RUN_FLAGS="+vcs64 +ntb_random_seed_automatic"
            echo "   VCSé…ç½®: 64ä½, è‡ªåŠ¨ç§å­"
            ;;
        "vsim")
            export CV_SIMULATOR=vsim
            export USER_RUN_FLAGS="-64 -t 1ps +UVM_TESTNAME=$UVM_TESTNAME"
            echo "   Questaé…ç½®: 64ä½, 1psç²¾åº¦"
            ;;
        "riviera")
            export CV_SIMULATOR=riviera
            export USER_RUN_FLAGS="-64bit +UVM_TESTNAME=$UVM_TESTNAME"
            echo "   Rivieraé…ç½®: 64ä½"
            ;;
    esac
}

# ğŸ”¹ åº”ç”¨é…ç½®å¹¶è¿è¡Œæµ‹è¯•
if [ "$BEST_SIM" != "unsim" ]; then
    echo "3. é…ç½®å’Œè¿è¡Œæµ‹è¯•:"
    configure_simulator $BEST_SIM
    make test TEST=$TEST_NAME
else
    echo "âŒ æœªæ‰¾åˆ°å¯ç”¨çš„ä»¿çœŸå™¨"
    exit 1
fi
```

#### ä»¿çœŸå™¨æ€§èƒ½å¯¹æ¯”

```bash
#!/bin/bash
# simulator_benchmark.sh - ä»¿çœŸå™¨æ€§èƒ½å¯¹æ¯”

AVAILABLE_SIMS=()
TEST_CASE="hello-world"

# ğŸ”¹ æ£€æµ‹å¯ç”¨ä»¿çœŸå™¨
for sim in "xrun" "vcs" "vsim"; do
    if command -v $sim &> /dev/null; then
        AVAILABLE_SIMS+=($sim)
    fi
done

echo "ğŸ ä»¿çœŸå™¨æ€§èƒ½å¯¹æ¯”æµ‹è¯•"
echo "===================="
echo "æµ‹è¯•ç”¨ä¾‹: $TEST_CASE"
echo "å¯ç”¨ä»¿çœŸå™¨: ${AVAILABLE_SIMS[*]}"
echo ""

# ğŸ”¹ æ€§èƒ½å¯¹æ¯”ç»“æœå­˜å‚¨
RESULTS_FILE="simulator_benchmark_$(date +%Y%m%d_%H%M%S).csv"
echo "ä»¿çœŸå™¨,ç¼–è¯‘æ—¶é—´(s),è¿è¡Œæ—¶é—´(s),æ€»æ—¶é—´(s),å†…å­˜å³°å€¼(MB)" > $RESULTS_FILE

# ğŸ”¹ é€ä¸ªæµ‹è¯•ä»¿çœŸå™¨
for sim in "${AVAILABLE_SIMS[@]}"; do
    echo "ğŸ§ª æµ‹è¯•ä»¿çœŸå™¨: $sim"
    
    # æ¸…ç†ç¯å¢ƒ
    make clean_test TEST=$TEST_CASE >/dev/null 2>&1
    
    # é…ç½®ä»¿çœŸå™¨
    export CV_SIMULATOR=$sim
    
    # å¼€å§‹è®¡æ—¶
    start_time=$(date +%s.%N)
    
    # ç›‘æ§å†…å­˜ä½¿ç”¨
    (
        max_mem=0
        while true; do
            if pgrep -f $sim >/dev/null; then
                current_mem=$(ps -o rss -C $sim --no-headers | awk '{sum+=$1} END {print sum/1024}')
                if (( $(echo "$current_mem > $max_mem" | bc -l) )); then
                    max_mem=$current_mem
                fi
            fi
            sleep 1
        done
        echo $max_mem > /tmp/max_mem_$sim
    ) &
    MEM_MONITOR_PID=$!
    
    # è¿è¡Œæµ‹è¯•  
    make test TEST=$TEST_CASE >/dev/null 2>&1
    TEST_RESULT=$?
    
    # åœæ­¢è®¡æ—¶
    end_time=$(date +%s.%N)
    total_time=$(echo "$end_time - $start_time" | bc)
    
    # åœæ­¢å†…å­˜ç›‘æ§
    kill $MEM_MONITOR_PID 2>/dev/null
    max_memory=$(cat /tmp/max_mem_$sim 2>/dev/null || echo "0")
    
    # ç»“æœç»Ÿè®¡
    if [ $TEST_RESULT -eq 0 ]; then
        echo "   âœ… æµ‹è¯•é€šè¿‡"
        echo "   â±ï¸  æ€»æ—¶é—´: ${total_time}ç§’"
        echo "   ğŸ’¾ å†…å­˜å³°å€¼: ${max_memory}MB"
        
        # è®°å½•åˆ°CSV
        echo "$sim,N/A,$total_time,$total_time,$max_memory" >> $RESULTS_FILE
    else
        echo "   âŒ æµ‹è¯•å¤±è´¥"
        echo "$sim,FAILED,FAILED,FAILED,FAILED" >> $RESULTS_FILE
    fi
    
    echo ""
done

echo "ğŸ“Š æ€§èƒ½å¯¹æ¯”å®Œæˆï¼Œè¯¦ç»†ç»“æœä¿å­˜åœ¨: $RESULTS_FILE"
```

---

## ğŸ¯ Part 5: Step-and-Compareæ·±åº¦é…ç½®

### ğŸ” ISSé›†æˆé…ç½®

#### OVPsimé…ç½®ä¼˜åŒ–

```bash
# ovpsim_config.sh - OVPsimé…ç½®è„šæœ¬
#!/bin/bash

echo "ğŸ” OVPsim (ISS) é…ç½®ä¼˜åŒ–"
echo "======================"

# ğŸ”¹ æ£€æŸ¥OVPsimå®‰è£…
check_ovpsim() {
    if [ ! -d "$DV_OVPM_HOME" ]; then
        echo "âŒ OVPsimæœªå®‰è£…ï¼Œè·¯å¾„: $DV_OVPM_HOME"
        echo "è¯·è®¾ç½®æ­£ç¡®çš„DV_OVPM_HOMEç¯å¢ƒå˜é‡"
        return 1
    fi
    
    echo "âœ… OVPsimè·¯å¾„: $DV_OVPM_HOME"
    
    # æ£€æŸ¥æ¨¡å‹æ–‡ä»¶
    if [ -f "$DV_OVPM_HOME/imperas_DV_COREV/model/riscvOVPsim.exe" ]; then
        echo "âœ… OVPsimæ¨¡å‹å¯ç”¨"
    else
        echo "âŒ OVPsimæ¨¡å‹æœªæ‰¾åˆ°"
        return 1
    fi
    
    return 0
}

# ğŸ”¹ é…ç½®Step-and-Compareå‚æ•°
configure_step_compare() {
    # ISSé…ç½®å‚æ•°
    export ISS_PARAMS="\
        --variant RV32IMC \
        --cover INSTRUCTION \
        --showuncovered \
        --extensions XPULPV2"
    
    # Step-and-Compareé…ç½®
    export STEP_COMPARE_OPTS="\
        +step_compare_enable=1 \
        +iss_mode=lock_step \
        +mismatch_halt=1 \
        +compare_pc=1 \
        +compare_gpr=1 \
        +compare_csr=1"
    
    echo "âœ… Step-and-Compareé…ç½®å®Œæˆ"
    echo "   ISSå˜ä½“: RV32IMC + XPULPV2"
    echo "   æ¯”è¾ƒæ¨¡å¼: Lock-step"
    echo "   æ¯”è¾ƒå†…å®¹: PC + GPR + CSR"
}

# ğŸ”¹ è¿è¡ŒStep-and-Compareæµ‹è¯•
run_step_compare_test() {
    local test_name=${1:-"hello-world"}
    
    echo "ğŸ¯ è¿è¡ŒStep-and-Compareæµ‹è¯•: $test_name"
    
    # è®¾ç½®è¯¦ç»†è¾“å‡º
    export USER_RUN_FLAGS="$USER_RUN_FLAGS $STEP_COMPARE_OPTS +UVM_VERBOSITY=UVM_HIGH"
    
    # è¿è¡Œæµ‹è¯•
    make test TEST=$test_name USE_ISS=YES
    
    # æ£€æŸ¥æ¯”è¾ƒç»“æœ
    if grep -q "ISSæ¯”è¾ƒ: æ‰€æœ‰æ£€æŸ¥ç‚¹åŒ¹é…" *.log; then
        echo "âœ… Step-and-CompareéªŒè¯é€šè¿‡"
    elif grep -q "ISSä¸åŒ¹é…" *.log; then
        echo "âŒ Step-and-CompareéªŒè¯å¤±è´¥"
        echo "è¯¦ç»†ä¸åŒ¹é…ä¿¡æ¯:"
        grep -A10 "ISSä¸åŒ¹é…" *.log
    else
        echo "âš ï¸  æœªæ‰¾åˆ°æ˜ç¡®çš„æ¯”è¾ƒç»“æœ"
    fi
}

# æ‰§è¡Œé…ç½®å’Œæµ‹è¯•
if check_ovpsim; then
    configure_step_compare
    run_step_compare_test ${1:-"hello-world"}
fi
```

#### Step-and-Compareæ•…éšœæ’é™¤

```systemverilog
// step_compare_debug.sv - Step-and-Compareè°ƒè¯•å¢å¼º
class step_compare_debug_c extends uvm_component;
   
   // ğŸ”¹ æ¯”è¾ƒçŠ¶æ€è·Ÿè¸ª
   typedef struct {
      bit [31:0] rtl_pc;
      bit [31:0] iss_pc;
      bit [31:0] rtl_instr;
      bit [31:0] iss_instr;
      bit [31:0] rtl_gpr[32];
      bit [31:0] iss_gpr[32];
      realtime   timestamp;
   } compare_checkpoint_t;
   
   compare_checkpoint_t checkpoint_history[$];
   int mismatch_count = 0;
   
   // ğŸ”¹ ä¸åŒ¹é…æ£€æµ‹å’Œè®°å½•
   virtual function void check_step_compare(
      bit [31:0] rtl_pc, bit [31:0] iss_pc,
      bit [31:0] rtl_instr, bit [31:0] iss_instr
   );
      
      compare_checkpoint_t checkpoint;
      bit mismatch_detected = 0;
      
      // è®°å½•æ£€æŸ¥ç‚¹
      checkpoint.rtl_pc = rtl_pc;
      checkpoint.iss_pc = iss_pc;  
      checkpoint.rtl_instr = rtl_instr;
      checkpoint.iss_instr = iss_instr;
      checkpoint.timestamp = $realtime;
      
      // PCæ¯”è¾ƒ
      if (rtl_pc !== iss_pc) begin
         `uvm_error("STEP_COMPARE", 
                   $sformatf("PCä¸åŒ¹é…: RTL=0x%08x, ISS=0x%08x @%0t", 
                            rtl_pc, iss_pc, $realtime))
         mismatch_detected = 1;
      end
      
      // æŒ‡ä»¤æ¯”è¾ƒ
      if (rtl_instr !== iss_instr) begin
         `uvm_error("STEP_COMPARE",
                   $sformatf("æŒ‡ä»¤ä¸åŒ¹é…: RTL=0x%08x, ISS=0x%08x @%0t",
                            rtl_instr, iss_instr, $realtime))
         mismatch_detected = 1;
      end
      
      if (mismatch_detected) begin
         mismatch_count++;
         
         // ğŸ”¹ è¯¦ç»†è¯Šæ–­ä¿¡æ¯
         analyze_mismatch(checkpoint);
         
         // ğŸ”¹ ä¿å­˜å†å²ç”¨äºåˆ†æ
         checkpoint_history.push_back(checkpoint);
         
         // ğŸ”¹ å¦‚æœä¸åŒ¹é…è¿‡å¤šï¼Œåœæ­¢ä»¿çœŸ
         if (mismatch_count > 10) begin
            `uvm_fatal("STEP_COMPARE", "è¿ç»­ä¸åŒ¹é…è¿‡å¤šï¼Œåœæ­¢ä»¿çœŸ")
         end
      end else begin
         `uvm_info("STEP_COMPARE", 
                  $sformatf("æ£€æŸ¥ç‚¹åŒ¹é…: PC=0x%08x, INSTR=0x%08x", 
                           rtl_pc, rtl_instr), UVM_HIGH)
      end
      
   endfunction
   
   // ğŸ”¹ ä¸åŒ¹é…åŸå› åˆ†æ
   virtual function void analyze_mismatch(compare_checkpoint_t checkpoint);
      
      `uvm_info("STEP_COMPARE", "=== ä¸åŒ¹é…åˆ†æå¼€å§‹ ===", UVM_MEDIUM)
      
      // åˆ†æPCè·³è½¬
      if (checkpoint_history.size() > 0) begin
         compare_checkpoint_t prev = checkpoint_history[$];
         
         // æ£€æŸ¥æ˜¯å¦ä¸ºåˆ†æ”¯æŒ‡ä»¤
         if (is_branch_instruction(prev.rtl_instr)) begin
            `uvm_info("STEP_COMPARE", "æ£€æµ‹åˆ°åˆ†æ”¯æŒ‡ä»¤ï¼Œåˆ†æåˆ†æ”¯æ¡ä»¶", UVM_MEDIUM)
            analyze_branch_condition(prev, checkpoint);
         end
         
         // æ£€æŸ¥æ˜¯å¦ä¸ºè·³è½¬æŒ‡ä»¤
         if (is_jump_instruction(prev.rtl_instr)) begin
            `uvm_info("STEP_COMPARE", "æ£€æµ‹åˆ°è·³è½¬æŒ‡ä»¤ï¼Œåˆ†æè·³è½¬ç›®æ ‡", UVM_MEDIUM)  
            analyze_jump_target(prev, checkpoint);
         end
         
         // æ£€æŸ¥æ˜¯å¦ä¸ºä¸­æ–­/å¼‚å¸¸
         if (is_interrupt_or_exception(checkpoint.rtl_pc)) begin
            `uvm_info("STEP_COMPARE", "æ£€æµ‹åˆ°ä¸­æ–­/å¼‚å¸¸ï¼Œåˆ†æå¤„ç†æµç¨‹", UVM_MEDIUM)
            analyze_interrupt_exception(checkpoint);
         end
      end
      
      `uvm_info("STEP_COMPARE", "=== ä¸åŒ¹é…åˆ†æç»“æŸ ===", UVM_MEDIUM)
      
   endfunction
   
   // ğŸ”¹ ç”Ÿæˆè¯Šæ–­æŠ¥å‘Š
   virtual function void generate_debug_report();
      string report_file = $sformatf("step_compare_debug_%0t.txt", $realtime);
      int fd = $fopen(report_file, "w");
      
      $fdisplay(fd, "Step-and-Compareè°ƒè¯•æŠ¥å‘Š");
      $fdisplay(fd, "========================");
      $fdisplay(fd, "æ€»æ£€æŸ¥ç‚¹æ•°: %0d", checkpoint_history.size());
      $fdisplay(fd, "ä¸åŒ¹é…æ¬¡æ•°: %0d", mismatch_count);
      $fdisplay(fd, "åŒ¹é…ç‡: %.2f%%", 
               (checkpoint_history.size()-mismatch_count)*100.0/checkpoint_history.size());
      $fdisplay(fd, "");
      
      // è¯¦ç»†ä¸åŒ¹é…å†å²
      $fdisplay(fd, "ä¸åŒ¹é…å†å²:");
      foreach(checkpoint_history[i]) begin
         if (checkpoint_history[i].rtl_pc !== checkpoint_history[i].iss_pc) begin
            $fdisplay(fd, "[%0t] PC: RTL=0x%08x ISS=0x%08x",
                     checkpoint_history[i].timestamp,
                     checkpoint_history[i].rtl_pc,
                     checkpoint_history[i].iss_pc);
         end
      end
      
      $fclose(fd);
      `uvm_info("STEP_COMPARE", $sformatf("è°ƒè¯•æŠ¥å‘Šç”Ÿæˆ: %s", report_file), UVM_LOW)
   endfunction
   
endclass
```

---

## ğŸ“ˆ Part 6: å¤§è§„æ¨¡å›å½’æµ‹è¯•ç®¡ç†

### ğŸ”„ å¹¶è¡Œå›å½’æµ‹è¯•

#### æ™ºèƒ½ä»»åŠ¡è°ƒåº¦å™¨

```bash
#!/bin/bash
# regression_scheduler.sh - æ™ºèƒ½å›å½’æµ‹è¯•è°ƒåº¦å™¨

# ğŸ”¹ é…ç½®å‚æ•°
MAX_PARALLEL_JOBS=${MAX_PARALLEL_JOBS:-4}
REGRESSION_NAME=${1:-"cv32e40p_nightly"}
EMAIL_NOTIFY=${EMAIL_NOTIFY:-""}

# ğŸ”¹ æµ‹è¯•åˆ—è¡¨
REGRESSION_TESTS=(
    "hello-world"
    "arithmetic_test"
    "interrupt_test"
    "debug_test"
    "memory_stress"
    "corev_rand_arithmetic_base_test"
    "corev_rand_interrupt_test"
    "corev_rand_debug_test"
)

echo "ğŸ“ˆ å¤§è§„æ¨¡å›å½’æµ‹è¯•è°ƒåº¦å™¨"
echo "======================"
echo "å›å½’åç§°: $REGRESSION_NAME"
echo "å¹¶è¡Œä»»åŠ¡æ•°: $MAX_PARALLEL_JOBS"
echo "æµ‹è¯•æ€»æ•°: ${#REGRESSION_TESTS[@]}"
echo ""

# ğŸ”¹ åˆ›å»ºç»“æœç›®å½•
RESULTS_DIR="regression_results_$(date +%Y%m%d_%H%M%S)"
mkdir -p $RESULTS_DIR
cd $RESULTS_DIR

# ğŸ”¹ ä»»åŠ¡çŠ¶æ€è·Ÿè¸ª
declare -A job_status
declare -A job_pids
declare -A job_start_time
running_jobs=0

# ğŸ”¹ ä»»åŠ¡æ‰§è¡Œå‡½æ•°
run_test_job() {
    local test_name=$1
    local job_id=$2
    
    echo "[ä½œä¸š$job_id] å¼€å§‹æµ‹è¯•: $test_name"
    job_start_time[$job_id]=$(date +%s)
    
    # åˆ›å»ºä½œä¸šç‰¹å®šç›®å½•
    mkdir -p "job_${job_id}_${test_name}"
    cd "job_${job_id}_${test_name}"
    
    # è¿è¡Œæµ‹è¯•
    make test TEST=$test_name > "test_${test_name}.log" 2>&1
    test_result=$?
    
    # è®°å½•ç»“æœ
    end_time=$(date +%s)
    duration=$((end_time - job_start_time[$job_id]))
    
    if [ $test_result -eq 0 ]; then
        job_status[$job_id]="PASSED"
        echo "[ä½œä¸š$job_id] âœ… $test_name PASSED (${duration}s)"
    else
        job_status[$job_id]="FAILED"
        echo "[ä½œä¸š$job_id] âŒ $test_name FAILED (${duration}s)"
    fi
    
    # è¿”å›ä¸Šçº§ç›®å½•
    cd ..
    
    return $test_result
}

# ğŸ”¹ æ™ºèƒ½è°ƒåº¦é€»è¾‘
schedule_tests() {
    local job_id=0
    
    for test in "${REGRESSION_TESTS[@]}"; do
        # ç­‰å¾…ç©ºé—²æ§½ä½
        while [ $running_jobs -ge $MAX_PARALLEL_JOBS ]; do
            check_completed_jobs
            sleep 2
        done
        
        # å¯åŠ¨æ–°ä½œä¸š
        job_id=$((job_id + 1))
        echo "ğŸš€ è°ƒåº¦ä½œä¸š$job_id: $test"
        
        (run_test_job "$test" $job_id) &
        job_pids[$job_id]=$!
        running_jobs=$((running_jobs + 1))
    done
    
    # ç­‰å¾…æ‰€æœ‰ä½œä¸šå®Œæˆ
    echo "â³ ç­‰å¾…æ‰€æœ‰ä½œä¸šå®Œæˆ..."
    while [ $running_jobs -gt 0 ]; do
        check_completed_jobs
        sleep 5
    done
}

# ğŸ”¹ æ£€æŸ¥å·²å®Œæˆçš„ä½œä¸š
check_completed_jobs() {
    for job_id in "${!job_pids[@]}"; do
        local pid=${job_pids[$job_id]}
        
        if ! kill -0 $pid 2>/dev/null; then
            # ä½œä¸šå·²å®Œæˆ
            unset job_pids[$job_id]
            running_jobs=$((running_jobs - 1))
            
            echo "âœ… ä½œä¸š$job_id å®Œæˆ"
        fi
    done
}

# ğŸ”¹ ç”Ÿæˆå›å½’æŠ¥å‘Š
generate_regression_report() {
    local report_file="regression_report_${REGRESSION_NAME}.html"
    
    cat > $report_file << 'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>CV32E40På›å½’æµ‹è¯•æŠ¥å‘Š</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .passed { color: green; font-weight: bold; }
        .failed { color: red; font-weight: bold; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
    </style>
</head>
<body>
    <h1>CV32E40På›å½’æµ‹è¯•æŠ¥å‘Š</h1>
    <h2>æµ‹è¯•æ¦‚è§ˆ</h2>
EOF

    # ç»Ÿè®¡ç»“æœ
    local total_tests=${#REGRESSION_TESTS[@]}
    local passed_tests=0
    local failed_tests=0
    
    for status in "${job_status[@]}"; do
        if [ "$status" = "PASSED" ]; then
            passed_tests=$((passed_tests + 1))
        else
            failed_tests=$((failed_tests + 1))
        fi
    done
    
    # æ·»åŠ ç»Ÿè®¡åˆ°æŠ¥å‘Š
    cat >> $report_file << EOF
    <p><strong>æ€»æµ‹è¯•æ•°:</strong> $total_tests</p>
    <p><strong>é€šè¿‡:</strong> <span class="passed">$passed_tests</span></p>
    <p><strong>å¤±è´¥:</strong> <span class="failed">$failed_tests</span></p>
    <p><strong>é€šè¿‡ç‡:</strong> $(echo "scale=1; $passed_tests*100/$total_tests" | bc)%</p>
    
    <h2>è¯¦ç»†ç»“æœ</h2>
    <table>
        <tr><th>æµ‹è¯•åç§°</th><th>çŠ¶æ€</th><th>æ‰§è¡Œæ—¶é—´</th><th>æ—¥å¿—</th></tr>
EOF

    # æ·»åŠ è¯¦ç»†ç»“æœ
    local i=0
    for test in "${REGRESSION_TESTS[@]}"; do
        i=$((i + 1))
        local status=${job_status[$i]:-"UNKNOWN"}
        local duration_file="job_${i}_${test}/duration.txt"
        local duration="N/A"
        
        if [ -f "$duration_file" ]; then
            duration=$(cat "$duration_file")
        fi
        
        local status_class="failed"
        if [ "$status" = "PASSED" ]; then
            status_class="passed"
        fi
        
        cat >> $report_file << EOF
        <tr>
            <td>$test</td>
            <td><span class="$status_class">$status</span></td>
            <td>${duration}s</td>
            <td><a href="job_${i}_${test}/test_${test}.log">æŸ¥çœ‹æ—¥å¿—</a></td>
        </tr>
EOF
    done
    
    cat >> $report_file << 'EOF'
    </table>
    
    <h2>ç¯å¢ƒä¿¡æ¯</h2>
    <p><strong>æµ‹è¯•æ—¶é—´:</strong> $(date)</p>
    <p><strong>ä»¿çœŸå™¨:</strong> $CV_SIMULATOR</p>
    <p><strong>å¹¶è¡Œåº¦:</strong> $MAX_PARALLEL_JOBS</p>
    
</body>
</html>
EOF

    echo "ğŸ“‹ å›å½’æŠ¥å‘Šç”Ÿæˆ: $report_file"
    
    # å‘é€é‚®ä»¶é€šçŸ¥
    if [ -n "$EMAIL_NOTIFY" ]; then
        echo "ğŸ“§ å‘é€é‚®ä»¶é€šçŸ¥åˆ°: $EMAIL_NOTIFY"
        echo "CV32E40På›å½’æµ‹è¯•å®Œæˆ: $passed_tests/$total_tests é€šè¿‡" | \
            mail -s "å›å½’æµ‹è¯•æŠ¥å‘Š - $REGRESSION_NAME" -a $report_file $EMAIL_NOTIFY
    fi
}

# ğŸ”¹ ä¸»æ‰§è¡Œæµç¨‹
echo "ğŸš€ å¼€å§‹å›å½’æµ‹è¯•è°ƒåº¦..."
schedule_tests

echo "ğŸ“Š ç”Ÿæˆå›å½’æŠ¥å‘Š..."
generate_regression_report

echo "ğŸ‰ å›å½’æµ‹è¯•å®Œæˆ!"
echo "ç»“æœç›®å½•: $(pwd)"
```

### ğŸ“Š å›å½’ç»“æœåˆ†æ

#### è¶‹åŠ¿åˆ†æå·¥å…·

```python
#!/usr/bin/env python3
# regression_analyzer.py - å›å½’æµ‹è¯•è¶‹åŠ¿åˆ†æå·¥å…·

import json
import matplotlib.pyplot as plt
import pandas as pd
from datetime import datetime, timedelta
import argparse
import glob
import os

class RegressionAnalyzer:
    def __init__(self, results_dir="regression_results"):
        self.results_dir = results_dir
        self.data = []
        
    def collect_regression_data(self):
        """æ”¶é›†å†å²å›å½’æµ‹è¯•æ•°æ®"""
        print("ğŸ“Š æ”¶é›†å›å½’æµ‹è¯•æ•°æ®...")
        
        # æŸ¥æ‰¾æ‰€æœ‰å›å½’ç»“æœç›®å½•
        result_dirs = glob.glob(f"{self.results_dir}_*")
        result_dirs.sort()
        
        for result_dir in result_dirs:
            try:
                # è§£æç›®å½•åè·å–æ—¶é—´æˆ³
                timestamp_str = result_dir.split('_')[-2] + '_' + result_dir.split('_')[-1]
                timestamp = datetime.strptime(timestamp_str, "%Y%m%d_%H%M%S")
                
                # åˆ†æè¯¥æ¬¡å›å½’çš„ç»“æœ
                regression_data = self.analyze_single_regression(result_dir, timestamp)
                if regression_data:
                    self.data.append(regression_data)
                    
            except Exception as e:
                print(f"âš ï¸  è§£æ {result_dir} æ—¶å‡ºé”™: {e}")
        
        print(f"âœ… æ”¶é›†åˆ° {len(self.data)} æ¬¡å›å½’æ•°æ®")
        
    def analyze_single_regression(self, result_dir, timestamp):
        """åˆ†æå•æ¬¡å›å½’æµ‹è¯•ç»“æœ"""
        
        # ç»Ÿè®¡å„jobç›®å½•
        job_dirs = glob.glob(f"{result_dir}/job_*")
        
        passed = 0
        failed = 0
        total_time = 0
        test_details = []
        
        for job_dir in job_dirs:
            # è§£æjobä¿¡æ¯
            job_name = os.path.basename(job_dir)
            parts = job_name.split('_')
            if len(parts) >= 3:
                test_name = '_'.join(parts[2:])
                
                # æ£€æŸ¥æµ‹è¯•ç»“æœ
                log_file = f"{job_dir}/test_{test_name}.log"
                if os.path.exists(log_file):
                    with open(log_file, 'r') as f:
                        log_content = f.read()
                        
                    if "TEST PASSED" in log_content:
                        passed += 1
                        status = "PASSED"
                    else:
                        failed += 1
                        status = "FAILED"
                    
                    # æå–æ‰§è¡Œæ—¶é—´
                    duration = self.extract_test_duration(log_content)
                    total_time += duration
                    
                    test_details.append({
                        'name': test_name,
                        'status': status,
                        'duration': duration
                    })
        
        total_tests = passed + failed
        if total_tests == 0:
            return None
            
        return {
            'timestamp': timestamp,
            'total_tests': total_tests,
            'passed': passed,
            'failed': failed,
            'pass_rate': passed / total_tests * 100,
            'total_time': total_time,
            'avg_time': total_time / total_tests if total_tests > 0 else 0,
            'test_details': test_details
        }
    
    def extract_test_duration(self, log_content):
        """ä»æ—¥å¿—ä¸­æå–æµ‹è¯•æ‰§è¡Œæ—¶é—´"""
        # æŸ¥æ‰¾ä»¿çœŸæ—¶é—´ä¿¡æ¯
        lines = log_content.split('\n')
        for line in lines:
            if "Simulation time" in line and "seconds" in line:
                try:
                    # æå–æ—¶é—´æ•°å€¼
                    parts = line.split()
                    for i, part in enumerate(parts):
                        if "seconds" in part and i > 0:
                            return float(parts[i-1])
                except:
                    pass
        return 0.0
    
    def generate_trend_charts(self):
        """ç”Ÿæˆè¶‹åŠ¿åˆ†æå›¾è¡¨"""
        if not self.data:
            print("âŒ æ²¡æœ‰æ•°æ®å¯ä»¥åˆ†æ")
            return
            
        df = pd.DataFrame(self.data)
        
        # åˆ›å»ºå›¾è¡¨
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))
        fig.suptitle('CV32E40På›å½’æµ‹è¯•è¶‹åŠ¿åˆ†æ', fontsize=16)
        
        # 1. é€šè¿‡ç‡è¶‹åŠ¿
        ax1.plot(df['timestamp'], df['pass_rate'], marker='o', linewidth=2)
        ax1.set_title('æµ‹è¯•é€šè¿‡ç‡è¶‹åŠ¿')
        ax1.set_ylabel('é€šè¿‡ç‡ (%)')
        ax1.grid(True, alpha=0.3)
        ax1.set_ylim(0, 100)
        
        # 2. æµ‹è¯•æ•°é‡è¶‹åŠ¿
        ax2.plot(df['timestamp'], df['total_tests'], marker='s', color='orange', linewidth=2)
        ax2.set_title('æµ‹è¯•æ€»æ•°è¶‹åŠ¿')
        ax2.set_ylabel('æµ‹è¯•æ•°é‡')
        ax2.grid(True, alpha=0.3)
        
        # 3. æ‰§è¡Œæ—¶é—´è¶‹åŠ¿
        ax3.plot(df['timestamp'], df['avg_time'], marker='^', color='green', linewidth=2)
        ax3.set_title('å¹³å‡æ‰§è¡Œæ—¶é—´è¶‹åŠ¿')
        ax3.set_ylabel('å¹³å‡æ—¶é—´ (ç§’)')
        ax3.grid(True, alpha=0.3)
        
        # 4. å¤±è´¥ç‡åˆ†å¸ƒ
        ax4.bar(range(len(df)), df['failed'], color='red', alpha=0.7)
        ax4.set_title('å¤±è´¥æµ‹è¯•æ•°é‡')
        ax4.set_ylabel('å¤±è´¥æ•°é‡')
        ax4.set_xlabel('å›å½’æ¬¡æ•°')
        ax4.grid(True, alpha=0.3)
        
        # è°ƒæ•´å¸ƒå±€
        plt.tight_layout()
        
        # ä¿å­˜å›¾è¡¨
        chart_file = f"regression_trend_analysis_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
        plt.savefig(chart_file, dpi=300, bbox_inches='tight')
        print(f"ğŸ“ˆ è¶‹åŠ¿åˆ†æå›¾è¡¨å·²ä¿å­˜: {chart_file}")
        
        # æ˜¾ç¤ºå›¾è¡¨
        plt.show()
    
    def generate_quality_report(self):
        """ç”Ÿæˆè´¨é‡åˆ†ææŠ¥å‘Š"""
        if not self.data:
            return
            
        df = pd.DataFrame(self.data)
        
        # ç”Ÿæˆè´¨é‡æŠ¥å‘Š
        report = {
            'summary': {
                'total_regressions': len(df),
                'avg_pass_rate': df['pass_rate'].mean(),
                'min_pass_rate': df['pass_rate'].min(),
                'max_pass_rate': df['pass_rate'].max(),
                'avg_execution_time': df['total_time'].mean(),
                'total_tests_run': df['total_tests'].sum()
            },
            'recent_performance': {},
            'problematic_tests': []
        }
        
        # æœ€è¿‘7æ¬¡å›å½’çš„è¡¨ç°
        if len(df) >= 7:
            recent_df = df.tail(7)
            report['recent_performance'] = {
                'avg_pass_rate': recent_df['pass_rate'].mean(),
                'trend': 'improving' if recent_df['pass_rate'].iloc[-1] > recent_df['pass_rate'].iloc[0] else 'declining'
            }
        
        # è¯†åˆ«é—®é¢˜æµ‹è¯•
        test_failure_count = {}
        for regression in self.data:
            for test in regression['test_details']:
                if test['status'] == 'FAILED':
                    test_name = test['name']
                    test_failure_count[test_name] = test_failure_count.get(test_name, 0) + 1
        
        # æŒ‰å¤±è´¥æ¬¡æ•°æ’åº
        problematic_tests = sorted(test_failure_count.items(), 
                                 key=lambda x: x[1], reverse=True)[:10]
        report['problematic_tests'] = problematic_tests
        
        # ä¿å­˜æŠ¥å‘Š
        report_file = f"quality_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2, default=str)
        
        print(f"ğŸ“‹ è´¨é‡æŠ¥å‘Šå·²ç”Ÿæˆ: {report_file}")
        
        # æ‰“å°æ‘˜è¦
        print("\nğŸ“Š è´¨é‡åˆ†ææ‘˜è¦:")
        print(f"æ€»å›å½’æ¬¡æ•°: {report['summary']['total_regressions']}")
        print(f"å¹³å‡é€šè¿‡ç‡: {report['summary']['avg_pass_rate']:.1f}%")
        print(f"æœ€ä½é€šè¿‡ç‡: {report['summary']['min_pass_rate']:.1f}%")
        print(f"æœ€é«˜é€šè¿‡ç‡: {report['summary']['max_pass_rate']:.1f}%")
        
        if problematic_tests:
            print(f"\nğŸ” æœ€å¸¸å¤±è´¥çš„æµ‹è¯•:")
            for test_name, failure_count in problematic_tests[:5]:
                print(f"  {test_name}: {failure_count}æ¬¡å¤±è´¥")

def main():
    parser = argparse.ArgumentParser(description='CV32E40På›å½’æµ‹è¯•è¶‹åŠ¿åˆ†æå·¥å…·')
    parser.add_argument('--results-dir', default='regression_results',
                       help='å›å½’ç»“æœç›®å½•å‰ç¼€')
    parser.add_argument('--action', choices=['collect', 'chart', 'report', 'all'],
                       default='all', help='æ‰§è¡Œçš„æ“ä½œ')
    
    args = parser.parse_args()
    
    analyzer = RegressionAnalyzer(args.results_dir)
    
    if args.action in ['collect', 'all']:
        analyzer.collect_regression_data()
    
    if args.action in ['chart', 'all']:
        analyzer.generate_trend_charts()
    
    if args.action in ['report', 'all']:
        analyzer.generate_quality_report()

if __name__ == "__main__":
    main()
```

---

## ğŸ‰ æ€»ç»“å’Œæœ€ä½³å®è·µ

### âœ… é«˜çº§åŠŸèƒ½ä½¿ç”¨æ¸…å•

ä½¿ç”¨æœ¬æŒ‡å—åï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š

- [ ] âœ… é…ç½®å’Œåˆ†æå¤šç§ç±»å‹çš„è¦†ç›–ç‡
- [ ] âœ… ä½¿ç”¨COREV-DVç”Ÿæˆå®šåˆ¶åŒ–éšæœºæµ‹è¯•
- [ ] âœ… ç›‘æ§å’Œä¼˜åŒ–ä»¿çœŸæ€§èƒ½
- [ ] âœ… é…ç½®å¤šç§ä»¿çœŸå™¨å¹¶å¯¹æ¯”æ€§èƒ½
- [ ] âœ… è®¾ç½®Step-and-Compareè¿›è¡ŒISSéªŒè¯
- [ ] âœ… ç®¡ç†å¤§è§„æ¨¡å¹¶è¡Œå›å½’æµ‹è¯•
- [ ] âœ… åˆ†æå›å½’è¶‹åŠ¿å’Œè´¨é‡æŒ‡æ ‡

### ğŸ”§ å®è·µå»ºè®®

1. **æ¸è¿›å¼ä½¿ç”¨**: å…ˆæŒæ¡åŸºç¡€åŠŸèƒ½ï¼Œå†é€æ­¥ä½¿ç”¨é«˜çº§ç‰¹æ€§
2. **è‡ªåŠ¨åŒ–ä¼˜å…ˆ**: å°½å¯èƒ½ä½¿ç”¨è„šæœ¬è‡ªåŠ¨åŒ–é‡å¤æ€§å·¥ä½œ
3. **æ€§èƒ½ç›‘æ§**: å®šæœŸç›‘æ§ä»¿çœŸæ€§èƒ½ï¼ŒåŠæ—¶ä¼˜åŒ–é…ç½®
4. **è´¨é‡é—¨æ§**: å»ºç«‹è¦†ç›–ç‡å’Œé€šè¿‡ç‡çš„è´¨é‡æ ‡å‡†
5. **ç»éªŒç§¯ç´¯**: è®°å½•ä½¿ç”¨ç»éªŒï¼Œå»ºç«‹å›¢é˜ŸçŸ¥è¯†åº“

### ğŸ”— ä¸‹ä¸€æ­¥å­¦ä¹ 

- **[02-ç»„ä»¶æ‰©å±•å¼€å‘æŒ‡å—](./02-ç»„ä»¶æ‰©å±•å¼€å‘æŒ‡å—.md)** - å­¦ä¹ å¦‚ä½•æ‰©å±•å’Œå®šåˆ¶éªŒè¯ç»„ä»¶
- **[../07-æ¡ˆä¾‹å’Œç»éªŒ/01-çœŸå®é¡¹ç›®æ¡ˆä¾‹ç ”ç©¶.md](../07-æ¡ˆä¾‹å’Œç»éªŒ/01-çœŸå®é¡¹ç›®æ¡ˆä¾‹ç ”ç©¶.md)** - äº†è§£å®é™…é¡¹ç›®ä¸­çš„åº”ç”¨æ¡ˆä¾‹

---

> ğŸ’¡ **é«˜çº§åŠŸèƒ½ä½¿ç”¨å¿ƒå¾—**  
> CV32E40På¹³å°çš„é«˜çº§åŠŸèƒ½å¯ä»¥æ˜¾è‘—æå‡éªŒè¯æ•ˆç‡å’Œè´¨é‡ã€‚å»ºè®®æ ¹æ®é¡¹ç›®éœ€è¦é€‰æ‹©æ€§ä½¿ç”¨ï¼Œé¿å…ä¸€å¼€å§‹å°±ä½¿ç”¨æ‰€æœ‰åŠŸèƒ½è€Œå¢åŠ å¤æ‚æ€§ã€‚

> ğŸš€ **æ•ˆç‡æå‡å»ºè®®**  
> å»ºç«‹æ ‡å‡†åŒ–çš„é…ç½®æ¨¡æ¿å’Œè‡ªåŠ¨åŒ–è„šæœ¬ï¼Œè¿™æ ·å¯ä»¥ç¡®ä¿å›¢é˜Ÿæˆå‘˜éƒ½èƒ½ä¸€è‡´åœ°ä½¿ç”¨è¿™äº›é«˜çº§åŠŸèƒ½ï¼Œå¹¶ä¸”èƒ½å¤Ÿå¿«é€Ÿé€‚åº”é¡¹ç›®éœ€æ±‚çš„å˜åŒ–ã€‚