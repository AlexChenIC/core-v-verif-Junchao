# CV32E40P平台高级功能使用指南 🚀

> **发挥CV32E40P验证平台的全部潜力**  
> 覆盖率分析、COREV-DV生成器、性能优化等高级功能的完整使用指南

---

## 📋 本指南包含功能

- 📊 **覆盖率收集和分析** - 功能覆盖率、代码覆盖率的系统化使用
- 🎲 **COREV-DV测试生成** - Google riscv-dv的定制化随机测试生成
- ⚡ **性能分析工具** - 仿真性能监控和优化技巧  
- 🔧 **多仿真器支持** - Xcelium、VCS、Questa、Riviera等的高级配置
- 🎯 **Step-and-Compare机制** - ISS对比验证的深度配置
- 📈 **大规模回归测试** - 并行执行和结果管理

---

## 📊 Part 1: 覆盖率收集和分析

### 🎯 覆盖率类型概览

CV32E40P平台支持多种覆盖率类型：

```
覆盖率层次结构:
├── 功能覆盖率 (Functional Coverage)
│   ├── 指令覆盖率 - 各类RISC-V指令的执行情况
│   ├── 总线覆盖率 - OBI接口的各种访问模式
│   └── 场景覆盖率 - 中断、调试、异常等特殊场景
├── 代码覆盖率 (Code Coverage) 
│   ├── 行覆盖率 (Line Coverage)
│   ├── 分支覆盖率 (Branch Coverage)  
│   └── 条件覆盖率 (Condition Coverage)
└── 断言覆盖率 (Assertion Coverage)
    ├── SVA断言监控
    └── PSL属性检查
```

### 🔧 覆盖率收集配置

#### 基础覆盖率收集

```bash
# 🔹 运行带覆盖率的单个测试
make test TEST=hello-world COV=1

# 🔹 运行带覆盖率的回归测试
make regression COV=1 REGRESSION_NAME=cv32e40p_full

# 🔹 指定覆盖率类型
make test TEST=arithmetic_test COV=1 USER_RUN_FLAGS="+coverage_type=functional+code"
```

#### 高级覆盖率配置

**Xcelium覆盖率配置:**
```bash
# 创建覆盖率配置文件
cat > coverage_config.cfg << 'EOF'
# Xcelium覆盖率配置
set_cover -du cv32e40p_wrapper -all
set_cover -assert -du cv32e40p_wrapper

# 排除不需要覆盖的模块
set_cover -remove -du mem_model
set_cover -remove -du debug_agent

# 功能覆盖率采样点
set_fcover -du cv32e40p_wrapper -all
EOF

# 使用配置运行测试
make test TEST=comprehensive_test COV=1 \
     USER_RUN_FLAGS="+xmcovercfg+coverage_config.cfg"
```

**VCS覆盖率配置:**
```bash
# VCS覆盖率选项
export SV_CMP_FLAGS="$SV_CMP_FLAGS -cm line+cond+fsm+tgl+branch"
export USER_RUN_FLAGS="+coverage_type=all -cm_name test_coverage"

make test TEST=interrupt_test COV=1
```

### 📈 覆盖率分析工具

#### 覆盖率报告生成

```bash
# 🔹 生成覆盖率报告
make cov TEST=hello-world

# 🔹 合并多个测试的覆盖率
make merge_cov TESTS="test1,test2,test3" MERGED_COV_NAME="regression_coverage"

# 🔹 生成HTML报告
make cov_report COV_NAME=regression_coverage FORMAT=html
```

#### 覆盖率分析脚本

```bash
#!/bin/bash
# coverage_analyzer.sh - 覆盖率分析自动化工具

COV_DB_PATH=${1:-"coverage.vdb"}
TARGET_COVERAGE=${2:-"90"}

echo "📊 覆盖率分析报告"
echo "=================="

# 🔹 总体覆盖率统计
echo "1. 总体覆盖率:"
urg -dir $COV_DB_PATH -report summary | grep -E "(Overall|Total)" | head -5

# 🔹 模块级覆盖率分析
echo "2. 模块覆盖率:"
urg -dir $COV_DB_PATH -report hierarchy | grep -E "cv32e40p|core" | head -10

# 🔹 未覆盖的关键功能识别
echo "3. 覆盖率缺口分析:"
urg -dir $COV_DB_PATH -report uncovered | head -20

# 🔹 覆盖率趋势分析
if [ -f "coverage_history.log" ]; then
    echo "4. 覆盖率趋势:"
    tail -10 coverage_history.log
fi

# 🔹 质量门检查
CURRENT_COVERAGE=$(urg -dir $COV_DB_PATH -report summary | grep "Overall" | awk '{print $3}' | sed 's/%//')
if (( $(echo "$CURRENT_COVERAGE >= $TARGET_COVERAGE" | bc -l) )); then
    echo "✅ 覆盖率质量门检查通过: $CURRENT_COVERAGE% >= $TARGET_COVERAGE%"
else
    echo "❌ 覆盖率质量门检查失败: $CURRENT_COVERAGE% < $TARGET_COVERAGE%"
    exit 1
fi
```

#### 功能覆盖率自定义

```systemverilog
// 自定义功能覆盖率模型
class cv32e40p_custom_coverage extends uvm_component;
   
   // 🔹 指令类型覆盖率
   covergroup instr_type_cg @(posedge clk);
      INSTR_TYPE: coverpoint instr_type {
         bins arithmetic = {ADD, SUB, MUL, DIV};
         bins logical    = {AND, OR, XOR, NOT};
         bins memory     = {LW, SW, LB, SB};
         bins branch     = {BEQ, BNE, BLT, BGE};
         bins jump       = {JAL, JALR};
         
         // 非法指令覆盖
         illegal_bins illegal = {32'h0000_0000, 32'hFFFF_FFFF};
      }
   endgroup
   
   // 🔹 总线访问模式覆盖率
   covergroup obi_access_cg @(posedge clk);
      REQ_VALID: coverpoint obi_req iff(obi_req);
      
      ADDR_ALIGN: coverpoint obi_addr[1:0] {
         bins word_aligned = {2'b00};
         bins half_aligned = {2'b10}; 
         bins byte_aligned = {2'b01, 2'b11};
      }
      
      BURST_TYPE: coverpoint {obi_req, obi_gnt} {
         bins single_cycle = {2'b11};
         bins wait_grant   = {2'b10};
         bins back_to_back = {2'b11, 2'b11};
      }
      
      // 交叉覆盖：地址对齐 × 访问类型
      ADDR_ACCESS_CROSS: cross ADDR_ALIGN, REQ_VALID;
   endgroup
   
   // 🔹 中断和异常覆盖率
   covergroup interrupt_cg @(posedge clk);
      IRQ_TYPE: coverpoint irq_id {
         bins timer_irq    = {[0:7]};
         bins external_irq = {[8:15]};
         bins software_irq = {[16:23]};
      }
      
      IRQ_TIMING: coverpoint cpu_state {
         bins idle_state   = {IDLE};
         bins fetch_state  = {FETCH};
         bins decode_state = {DECODE};
         bins execute_state = {EXECUTE};
      }
      
      // 中断嵌套场景
      IRQ_NESTING: cross IRQ_TYPE, IRQ_TIMING;
   endgroup
   
   function new(string name, uvm_component parent);
      super.new(name, parent);
      instr_type_cg = new();
      obi_access_cg = new();  
      interrupt_cg = new();
   endfunction
   
   // 🔹 覆盖率采样
   task run_phase(uvm_phase phase);
      forever begin
         @(posedge clk);
         
         // 采样各种覆盖率
         if (instr_valid) instr_type_cg.sample();
         if (obi_req) obi_access_cg.sample();
         if (irq_valid) interrupt_cg.sample();
      end
   endtask
   
endclass
```

---

## 🎲 Part 2: COREV-DV随机测试生成

### 🏗️ COREV-DV架构概览

COREV-DV是基于Google riscv-dv的扩展测试生成器：

```
COREV-DV架构:
├── Google riscv-dv (基础框架)
│   ├── 指令序列生成器
│   ├── 约束随机化引擎  
│   └── 汇编代码生成
├── 通用COREV扩展 (/lib/corev-dv)
│   ├── OpenHW特定指令
│   ├── 验证场景扩展
│   └── 覆盖率增强
└── CV32E40P专用扩展 (/cv32e40p/env/corev-dv)
    ├── PULP指令支持
    ├── 中断测试增强
    └── 调试功能测试
```

### 🚀 COREV-DV基础使用

#### 生成和运行COREV-DV测试

```bash
# 🔹 生成单个随机测试
make gen_corev-dv TEST=corev_rand_arithmetic_base_test

# 🔹 生成并运行测试
make corev-dv TEST=corev_rand_interrupt_test

# 🔹 批量生成多个测试
make gen_corev-dv TEST=corev_rand_stress_test GEN_NUM_TESTS=10

# 🔹 使用特定配置生成
make gen_corev-dv TEST=corev_rand_pulp_test CFG=pulp
```

#### COREV-DV配置文件详解

创建自定义COREV-DV配置 `custom_corev_dv.yaml`:

```yaml
# custom_corev_dv.yaml - 自定义COREV-DV测试配置

# 🔹 基础测试信息
name: custom_random_test
uvm_test: $(CV_CORE_LC)_instr_base_test
description: >
    自定义随机指令测试，重点验证算术运算和内存访问

# 🔹 核心生成参数
plusargs: >
    +instr_cnt=50000                    # 指令数量
    +num_of_sub_program=5               # 子程序数量
    +directed_instr_0=riscv_int_numeric_corner_stream,8    # 算术边界测试
    +directed_instr_1=riscv_load_store_stress_instr_stream,4  # 内存访问压力测试
    +directed_instr_2=riscv_multi_page_load_store_instr_stream,2  # 跨页访问测试

# 🔹 约束配置
constraints: >
    +no_fence=0                         # 允许fence指令
    +no_data_page=0                     # 允许数据页
    +no_branch_jump=0                   # 允许分支跳转
    +boot_mode=m                        # 机器模式启动
    +no_csr_instr=0                     # 允许CSR指令
    +enable_interrupt=1                 # 启用中断
    +enable_nested_interrupt=1          # 启用中断嵌套

# 🔹 覆盖率增强
coverage: >
    +enable_inst_cov=1                  # 指令覆盖率
    +enable_branch_cov=1                # 分支覆盖率
    +enable_toggle_cov=1                # 信号翻转覆盖率

# 🔹 特殊场景配置
scenarios:
    arithmetic_focus:
        directed_instr_0: riscv_int_numeric_corner_stream,20
        no_branch_jump: 1
        
    memory_stress:
        directed_instr_0: riscv_load_store_stress_instr_stream,15
        enable_unaligned_load_store: 1
        
    interrupt_heavy:
        enable_interrupt: 1
        interrupt_rate: high
        enable_nested_interrupt: 1
```

#### 运行自定义配置

```bash
# 使用自定义配置生成测试
make gen_corev-dv TEST=custom_random_test \
     COREV_DV_CONFIG=custom_corev_dv.yaml \
     GEN_NUM_TESTS=5

# 运行特定场景
make corev-dv TEST=custom_random_test \
     SCENARIO=memory_stress
```

### 🎯 高级COREV-DV定制

#### 创建自定义指令流

```systemverilog
// custom_instruction_stream.sv - 自定义指令流生成器
class cv32e40p_custom_instr_stream extends riscv_directed_instr_stream;
   
   `uvm_object_utils(cv32e40p_custom_instr_stream)
   
   // 🔹 PULP扩展指令定义
   riscv_instr_name_t pulp_instrs[] = {
      // PULP算术指令
      P_ABS, P_SLET, P_SLETU, P_MIN, P_MINU, P_MAX, P_MAXU,
      // PULP乘法指令  
      P_MUL, P_MULH, P_MULHSU, P_MULHU,
      // PULP位操作指令
      P_FF1, P_FL1, P_CLB, P_CNT, P_ROR
   };
   
   // 🔹 约束定义
   constraint instr_dist_c {
      // PULP指令分布
      foreach(instr_list[i]) {
         if (instr_list[i].instr_name inside {pulp_instrs}) {
            instr_list[i].weight == 20;  // 高权重
         }
      }
      
      // 指令序列长度
      instr_list.size() inside {[50:200]};
   }
   
   // 🔹 生成逻辑
   virtual function void gen_instr(bit no_branch = 1'b0, 
                                  bit no_load_store = 1'b0,
                                  bit is_debug_program = 1'b0);
      
      `uvm_info("CUSTOM_STREAM", "生成自定义PULP指令流", UVM_MEDIUM)
      
      // 基础指令生成
      super.gen_instr(no_branch, no_load_store, is_debug_program);
      
      // 添加特殊的PULP指令序列
      add_pulp_specific_sequences();
      
      // 添加错误注入
      if ($urandom_range(0, 100) < 10) begin  // 10%概率
         inject_corner_cases();
      end
      
   endfunction
   
   // 🔹 PULP特定序列
   virtual function void add_pulp_specific_sequences();
      riscv_instr instr;
      
      // PULP乘法测试序列
      repeat($urandom_range(5, 15)) begin
         instr = riscv_instr::type_id::create("pulp_mul_instr");
         instr.instr_name = pulp_instrs[$urandom_range(0, pulp_instrs.size()-1)];
         instr.randomize();
         instr_list.push_back(instr);
      end
      
      `uvm_info("CUSTOM_STREAM", 
               $sformatf("添加%0d条PULP特定指令", instr_list.size()), UVM_HIGH)
   endfunction
   
   // 🔹 边界情况注入
   virtual function void inject_corner_cases();
      // 除零测试
      add_divide_by_zero_case();
      
      // 溢出测试  
      add_overflow_test_case();
      
      // 非对齐访问测试
      add_unaligned_access_case();
   endfunction
   
endclass

// 注册自定义指令流
`uvm_object_registry(cv32e40p_custom_instr_stream, "cv32e40p_custom_instr_stream")
```

#### 集成自定义指令流

```bash
# 创建使用自定义指令流的配置
cat > pulp_custom_test.yaml << 'EOF'
name: pulp_custom_enhanced_test
uvm_test: $(CV_CORE_LC)_instr_base_test
description: >
    使用自定义PULP指令流的增强测试

plusargs: >
    +instr_cnt=30000
    +directed_instr_0=cv32e40p_custom_instr_stream,10
    +boot_mode=m
    +enable_interrupt=1
EOF

# 运行自定义测试
make gen_corev-dv TEST=pulp_custom_enhanced_test
make test TEST=pulp_custom_enhanced_test
```

### 📊 COREV-DV结果分析

#### 自动化结果收集

```bash
#!/bin/bash
# corev_dv_analyzer.sh - COREV-DV结果分析工具

TEST_NAME=${1:-"corev_rand_base_test"}
NUM_TESTS=${2:-"10"}

echo "🎲 COREV-DV测试分析报告"
echo "======================="

# 🔹 测试执行统计
echo "1. 执行统计:"
PASSED=$(find . -name "*${TEST_NAME}*" -path "*/test_results/*" -exec grep -l "TEST PASSED" {} \; | wc -l)
FAILED=$(find . -name "*${TEST_NAME}*" -path "*/test_results/*" -exec grep -l "TEST FAILED" {} \; | wc -l)
TOTAL=$((PASSED + FAILED))

echo "   总测试数: $TOTAL"
echo "   通过数: $PASSED"  
echo "   失败数: $FAILED"
echo "   通过率: $(echo "scale=2; $PASSED*100/$TOTAL" | bc)%"

# 🔹 指令覆盖率分析
echo "2. 指令覆盖率:"
if command -v riscv32-unknown-elf-objdump &> /dev/null; then
    # 分析生成的汇编代码
    find . -name "*${TEST_NAME}*.S" | head -5 | while read asm_file; do
        echo "   文件: $(basename $asm_file)"
        grep -E "^\s*(add|sub|mul|div|lw|sw)" "$asm_file" | \
            awk '{print $1}' | sort | uniq -c | sort -nr | head -5
    done
fi

# 🔹 错误模式分析
echo "3. 常见错误:"
find . -name "*${TEST_NAME}*" -path "*/test_results/*" -exec grep -l "TEST FAILED" {} \; | \
    head -5 | while read log_file; do
        echo "   失败原因:"
        grep -A5 -B5 "FAILED\|ERROR\|FATAL" "$log_file" | head -3
    done

# 🔹 性能分析
echo "4. 性能指标:"
find . -name "*${TEST_NAME}*" -path "*/test_results/*" -exec grep "Simulation time" {} \; | \
    awk '{print $3}' | sort -n | \
    awk '
    {
        times[NR] = $1
        sum += $1
    }
    END {
        print "   平均仿真时间: " sum/NR "s"
        print "   最短时间: " times[1] "s"  
        print "   最长时间: " times[NR] "s"
    }'
```

---

## ⚡ Part 3: 性能分析和优化

### 📈 仿真性能监控

#### 实时性能监控脚本

```bash
#!/bin/bash
# sim_performance_monitor.sh - 仿真性能实时监控

SIMULATOR=${CV_SIMULATOR:-"xrun"}
MONITOR_INTERVAL=${1:-"5"}  # 5秒采样间隔

echo "⚡ 仿真性能实时监控"
echo "=================="

# 🔹 创建性能日志文件
PERF_LOG="sim_performance_$(date +%Y%m%d_%H%M%S).log"
echo "时间戳,CPU使用率(%),内存使用(MB),仿真时间(ns),实际时间(s)" > $PERF_LOG

# 🔹 监控循环
while true; do
    TIMESTAMP=$(date +"%H:%M:%S")
    
    # 获取仿真器进程信息
    SIM_PID=$(pgrep -f $SIMULATOR | head -1)
    
    if [ -n "$SIM_PID" ]; then
        # CPU和内存使用率
        CPU_USAGE=$(ps -p $SIM_PID -o %cpu --no-headers | tr -d ' ')
        MEM_USAGE=$(ps -p $SIM_PID -o rss --no-headers | tr -d ' ')
        MEM_MB=$((MEM_USAGE / 1024))
        
        # 仿真时间 (从日志文件提取)
        SIM_TIME="N/A"
        if [ -f "$(ls -t *.log 2>/dev/null | head -1)" ]; then
            LATEST_LOG="$(ls -t *.log | head -1)"
            SIM_TIME=$(grep "Time:" "$LATEST_LOG" | tail -1 | awk '{print $2}' || echo "N/A")
        fi
        
        # 实际运行时间
        START_TIME=$(ps -p $SIM_PID -o etime --no-headers | tr -d ' ')
        
        # 输出到控制台
        printf "%-8s CPU:%-6s%% MEM:%-8sMB SIM:%-12s REAL:%-10s\n" \
               "$TIMESTAMP" "$CPU_USAGE" "$MEM_MB" "$SIM_TIME" "$START_TIME"
        
        # 记录到日志
        echo "$TIMESTAMP,$CPU_USAGE,$MEM_MB,$SIM_TIME,$START_TIME" >> $PERF_LOG
        
        # 🔹 性能警告
        if (( $(echo "$CPU_USAGE > 95" | bc -l) )); then
            echo "⚠️  警告: CPU使用率过高 ($CPU_USAGE%)"
        fi
        
        if (( MEM_MB > 8192 )); then
            echo "⚠️  警告: 内存使用过高 (${MEM_MB}MB)"
        fi
        
    else
        echo "$TIMESTAMP - 未检测到仿真进程"
    fi
    
    sleep $MONITOR_INTERVAL
done
```

#### 性能基准测试

```bash
#!/bin/bash
# sim_benchmark.sh - 仿真性能基准测试

BENCHMARK_TESTS=("hello-world" "arithmetic_test" "interrupt_test" "memory_stress")
ITERATIONS=3

echo "📊 仿真性能基准测试"
echo "=================="

# 🔹 创建基准测试报告
REPORT_FILE="benchmark_report_$(date +%Y%m%d_%H%M%S).txt"
{
    echo "CV32E40P仿真性能基准测试报告"
    echo "测试环境: $(uname -a)"
    echo "仿真器: $CV_SIMULATOR"
    echo "测试时间: $(date)"
    echo "=================================="
    echo ""
} > $REPORT_FILE

# 🔹 执行基准测试
for test in "${BENCHMARK_TESTS[@]}"; do
    echo "🧪 测试: $test"
    echo "测试: $test" >> $REPORT_FILE
    
    total_time=0
    for i in $(seq 1 $ITERATIONS); do
        echo "  第${i}次运行..."
        
        # 清理之前的结果
        make clean_test TEST=$test >/dev/null 2>&1
        
        # 执行测试并计时
        start_time=$(date +%s.%N)
        make test TEST=$test >/dev/null 2>&1
        end_time=$(date +%s.%N)
        
        # 计算执行时间
        execution_time=$(echo "$end_time - $start_time" | bc)
        total_time=$(echo "$total_time + $execution_time" | bc)
        
        echo "    执行时间: ${execution_time}秒"
        echo "  运行${i}: ${execution_time}秒" >> $REPORT_FILE
    done
    
    # 计算平均时间
    avg_time=$(echo "scale=3; $total_time / $ITERATIONS" | bc)
    echo "  平均时间: ${avg_time}秒"
    echo "  平均时间: ${avg_time}秒" >> $REPORT_FILE
    echo "" >> $REPORT_FILE
    echo ""
done

echo "📋 基准测试完成，报告保存在: $REPORT_FILE"
```

### 🔧 性能优化配置

#### 仿真器特定优化

**Xcelium优化配置:**
```bash
# xcelium_performance.cfg - Xcelium性能优化配置
cat > xcelium_performance.cfg << 'EOF'
# 编译优化
set_compile_option -64bit
set_compile_option -O3
set_compile_option -nospecify
set_compile_option -notimingchecks

# 运行时优化  
set_runtime_option -64bit
set_runtime_option -noassert
set_runtime_option -nowarn CGDEFN
set_runtime_option -threads 4

# 内存优化
set_memory_option -pool_size 2GB
set_memory_option -gc_interval 1000000
EOF

# 使用优化配置
export USER_RUN_FLAGS="+xmconfig+xcelium_performance.cfg"
make test TEST=performance_test
```

**VCS优化配置:**
```bash
# VCS性能优化选项
export VCS_PERFORMANCE_FLAGS="\
    +vcs+lic+wait \
    -timescale=1ns/1ps \
    -debug_access+r \
    -kdb=common_elab,hgldd_all \
    +vcs64 \
    -j4"

export SV_CMP_FLAGS="$SV_CMP_FLAGS $VCS_PERFORMANCE_FLAGS"
make test TEST=vcs_performance_test
```

### 📊 内存使用优化

#### 内存监控和优化

```bash
#!/bin/bash
# memory_optimizer.sh - 内存使用优化工具

TEST_NAME=${1:-"memory_stress"}

echo "💾 内存使用优化分析"
echo "=================="

# 🔹 运行前内存状态
echo "1. 系统内存状态:"
free -h

# 🔹 仿真期间内存监控
echo "2. 启动内存监控..."
(
    while true; do
        if pgrep -f $CV_SIMULATOR >/dev/null; then
            # 记录仿真器内存使用
            SIM_PID=$(pgrep -f $CV_SIMULATOR | head -1)
            MEM_USAGE=$(ps -p $SIM_PID -o rss --no-headers)
            MEM_MB=$((MEM_USAGE / 1024))
            echo "$(date '+%H:%M:%S') 仿真器内存: ${MEM_MB}MB"
            
            # 内存过高时的优化建议
            if (( MEM_MB > 4096 )); then
                echo "⚠️  内存使用过高，建议:"
                echo "   - 减少波形记录范围"
                echo "   - 禁用不必要的debug信息"  
                echo "   - 使用+UVM_NO_RELNOTES"
            fi
        fi
        sleep 10
    done
) &
MONITOR_PID=$!

# 🔹 运行测试
echo "3. 运行测试: $TEST_NAME"
make test TEST=$TEST_NAME USER_RUN_FLAGS="+UVM_NO_RELNOTES +define+NO_ASSERT"

# 🔹 停止监控
kill $MONITOR_PID 2>/dev/null

echo "4. 内存优化建议:"
echo "   ✅ 使用+UVM_NO_RELNOTES减少UVM开销"
echo "   ✅ 使用+define+NO_ASSERT禁用断言"
echo "   ✅ 限制波形文件大小"
echo "   ✅ 定期清理临时文件"
```

---

## 🔧 Part 4: 多仿真器高级配置

### 🎯 仿真器对比配置

#### 统一的仿真器配置管理

```bash
#!/bin/bash
# simulator_manager.sh - 多仿真器管理工具

SIMULATORS=("xrun" "vcs" "vsim" "riviera")
TEST_NAME=${1:-"hello-world"}

echo "🔧 多仿真器配置管理"
echo "=================="

# 🔹 仿真器可用性检查
echo "1. 仿真器可用性检查:"
for sim in "${SIMULATORS[@]}"; do
    if command -v $sim &> /dev/null; then
        echo "   ✅ $sim: 可用"
    else
        echo "   ❌ $sim: 不可用"
    fi
done

# 🔹 自动选择最优仿真器
select_best_simulator() {
    # 优先级: xrun > vcs > vsim > riviera
    for sim in "xrun" "vcs" "vsim" "riviera"; do
        if command -v $sim &> /dev/null; then
            echo $sim
            return
        fi
    done
    echo "unsim"  # 未找到可用仿真器
}

BEST_SIM=$(select_best_simulator)
echo "2. 推荐仿真器: $BEST_SIM"

# 🔹 仿真器特定配置
configure_simulator() {
    local sim=$1
    case $sim in
        "xrun")
            export CV_SIMULATOR=xrun
            export USER_RUN_FLAGS="+nc64bit +access+rw +notimingchecks"
            echo "   Xcelium配置: 64位, 完全访问, 无时序检查"
            ;;
        "vcs")
            export CV_SIMULATOR=vcs  
            export USER_RUN_FLAGS="+vcs64 +ntb_random_seed_automatic"
            echo "   VCS配置: 64位, 自动种子"
            ;;
        "vsim")
            export CV_SIMULATOR=vsim
            export USER_RUN_FLAGS="-64 -t 1ps +UVM_TESTNAME=$UVM_TESTNAME"
            echo "   Questa配置: 64位, 1ps精度"
            ;;
        "riviera")
            export CV_SIMULATOR=riviera
            export USER_RUN_FLAGS="-64bit +UVM_TESTNAME=$UVM_TESTNAME"
            echo "   Riviera配置: 64位"
            ;;
    esac
}

# 🔹 应用配置并运行测试
if [ "$BEST_SIM" != "unsim" ]; then
    echo "3. 配置和运行测试:"
    configure_simulator $BEST_SIM
    make test TEST=$TEST_NAME
else
    echo "❌ 未找到可用的仿真器"
    exit 1
fi
```

#### 仿真器性能对比

```bash
#!/bin/bash
# simulator_benchmark.sh - 仿真器性能对比

AVAILABLE_SIMS=()
TEST_CASE="hello-world"

# 🔹 检测可用仿真器
for sim in "xrun" "vcs" "vsim"; do
    if command -v $sim &> /dev/null; then
        AVAILABLE_SIMS+=($sim)
    fi
done

echo "🏁 仿真器性能对比测试"
echo "===================="
echo "测试用例: $TEST_CASE"
echo "可用仿真器: ${AVAILABLE_SIMS[*]}"
echo ""

# 🔹 性能对比结果存储
RESULTS_FILE="simulator_benchmark_$(date +%Y%m%d_%H%M%S).csv"
echo "仿真器,编译时间(s),运行时间(s),总时间(s),内存峰值(MB)" > $RESULTS_FILE

# 🔹 逐个测试仿真器
for sim in "${AVAILABLE_SIMS[@]}"; do
    echo "🧪 测试仿真器: $sim"
    
    # 清理环境
    make clean_test TEST=$TEST_CASE >/dev/null 2>&1
    
    # 配置仿真器
    export CV_SIMULATOR=$sim
    
    # 开始计时
    start_time=$(date +%s.%N)
    
    # 监控内存使用
    (
        max_mem=0
        while true; do
            if pgrep -f $sim >/dev/null; then
                current_mem=$(ps -o rss -C $sim --no-headers | awk '{sum+=$1} END {print sum/1024}')
                if (( $(echo "$current_mem > $max_mem" | bc -l) )); then
                    max_mem=$current_mem
                fi
            fi
            sleep 1
        done
        echo $max_mem > /tmp/max_mem_$sim
    ) &
    MEM_MONITOR_PID=$!
    
    # 运行测试  
    make test TEST=$TEST_CASE >/dev/null 2>&1
    TEST_RESULT=$?
    
    # 停止计时
    end_time=$(date +%s.%N)
    total_time=$(echo "$end_time - $start_time" | bc)
    
    # 停止内存监控
    kill $MEM_MONITOR_PID 2>/dev/null
    max_memory=$(cat /tmp/max_mem_$sim 2>/dev/null || echo "0")
    
    # 结果统计
    if [ $TEST_RESULT -eq 0 ]; then
        echo "   ✅ 测试通过"
        echo "   ⏱️  总时间: ${total_time}秒"
        echo "   💾 内存峰值: ${max_memory}MB"
        
        # 记录到CSV
        echo "$sim,N/A,$total_time,$total_time,$max_memory" >> $RESULTS_FILE
    else
        echo "   ❌ 测试失败"
        echo "$sim,FAILED,FAILED,FAILED,FAILED" >> $RESULTS_FILE
    fi
    
    echo ""
done

echo "📊 性能对比完成，详细结果保存在: $RESULTS_FILE"
```

---

## 🎯 Part 5: Step-and-Compare深度配置

### 🔍 ISS集成配置

#### OVPsim配置优化

```bash
# ovpsim_config.sh - OVPsim配置脚本
#!/bin/bash

echo "🔍 OVPsim (ISS) 配置优化"
echo "======================"

# 🔹 检查OVPsim安装
check_ovpsim() {
    if [ ! -d "$DV_OVPM_HOME" ]; then
        echo "❌ OVPsim未安装，路径: $DV_OVPM_HOME"
        echo "请设置正确的DV_OVPM_HOME环境变量"
        return 1
    fi
    
    echo "✅ OVPsim路径: $DV_OVPM_HOME"
    
    # 检查模型文件
    if [ -f "$DV_OVPM_HOME/imperas_DV_COREV/model/riscvOVPsim.exe" ]; then
        echo "✅ OVPsim模型可用"
    else
        echo "❌ OVPsim模型未找到"
        return 1
    fi
    
    return 0
}

# 🔹 配置Step-and-Compare参数
configure_step_compare() {
    # ISS配置参数
    export ISS_PARAMS="\
        --variant RV32IMC \
        --cover INSTRUCTION \
        --showuncovered \
        --extensions XPULPV2"
    
    # Step-and-Compare配置
    export STEP_COMPARE_OPTS="\
        +step_compare_enable=1 \
        +iss_mode=lock_step \
        +mismatch_halt=1 \
        +compare_pc=1 \
        +compare_gpr=1 \
        +compare_csr=1"
    
    echo "✅ Step-and-Compare配置完成"
    echo "   ISS变体: RV32IMC + XPULPV2"
    echo "   比较模式: Lock-step"
    echo "   比较内容: PC + GPR + CSR"
}

# 🔹 运行Step-and-Compare测试
run_step_compare_test() {
    local test_name=${1:-"hello-world"}
    
    echo "🎯 运行Step-and-Compare测试: $test_name"
    
    # 设置详细输出
    export USER_RUN_FLAGS="$USER_RUN_FLAGS $STEP_COMPARE_OPTS +UVM_VERBOSITY=UVM_HIGH"
    
    # 运行测试
    make test TEST=$test_name USE_ISS=YES
    
    # 检查比较结果
    if grep -q "ISS比较: 所有检查点匹配" *.log; then
        echo "✅ Step-and-Compare验证通过"
    elif grep -q "ISS不匹配" *.log; then
        echo "❌ Step-and-Compare验证失败"
        echo "详细不匹配信息:"
        grep -A10 "ISS不匹配" *.log
    else
        echo "⚠️  未找到明确的比较结果"
    fi
}

# 执行配置和测试
if check_ovpsim; then
    configure_step_compare
    run_step_compare_test ${1:-"hello-world"}
fi
```

#### Step-and-Compare故障排除

```systemverilog
// step_compare_debug.sv - Step-and-Compare调试增强
class step_compare_debug_c extends uvm_component;
   
   // 🔹 比较状态跟踪
   typedef struct {
      bit [31:0] rtl_pc;
      bit [31:0] iss_pc;
      bit [31:0] rtl_instr;
      bit [31:0] iss_instr;
      bit [31:0] rtl_gpr[32];
      bit [31:0] iss_gpr[32];
      realtime   timestamp;
   } compare_checkpoint_t;
   
   compare_checkpoint_t checkpoint_history[$];
   int mismatch_count = 0;
   
   // 🔹 不匹配检测和记录
   virtual function void check_step_compare(
      bit [31:0] rtl_pc, bit [31:0] iss_pc,
      bit [31:0] rtl_instr, bit [31:0] iss_instr
   );
      
      compare_checkpoint_t checkpoint;
      bit mismatch_detected = 0;
      
      // 记录检查点
      checkpoint.rtl_pc = rtl_pc;
      checkpoint.iss_pc = iss_pc;  
      checkpoint.rtl_instr = rtl_instr;
      checkpoint.iss_instr = iss_instr;
      checkpoint.timestamp = $realtime;
      
      // PC比较
      if (rtl_pc !== iss_pc) begin
         `uvm_error("STEP_COMPARE", 
                   $sformatf("PC不匹配: RTL=0x%08x, ISS=0x%08x @%0t", 
                            rtl_pc, iss_pc, $realtime))
         mismatch_detected = 1;
      end
      
      // 指令比较
      if (rtl_instr !== iss_instr) begin
         `uvm_error("STEP_COMPARE",
                   $sformatf("指令不匹配: RTL=0x%08x, ISS=0x%08x @%0t",
                            rtl_instr, iss_instr, $realtime))
         mismatch_detected = 1;
      end
      
      if (mismatch_detected) begin
         mismatch_count++;
         
         // 🔹 详细诊断信息
         analyze_mismatch(checkpoint);
         
         // 🔹 保存历史用于分析
         checkpoint_history.push_back(checkpoint);
         
         // 🔹 如果不匹配过多，停止仿真
         if (mismatch_count > 10) begin
            `uvm_fatal("STEP_COMPARE", "连续不匹配过多，停止仿真")
         end
      end else begin
         `uvm_info("STEP_COMPARE", 
                  $sformatf("检查点匹配: PC=0x%08x, INSTR=0x%08x", 
                           rtl_pc, rtl_instr), UVM_HIGH)
      end
      
   endfunction
   
   // 🔹 不匹配原因分析
   virtual function void analyze_mismatch(compare_checkpoint_t checkpoint);
      
      `uvm_info("STEP_COMPARE", "=== 不匹配分析开始 ===", UVM_MEDIUM)
      
      // 分析PC跳转
      if (checkpoint_history.size() > 0) begin
         compare_checkpoint_t prev = checkpoint_history[$];
         
         // 检查是否为分支指令
         if (is_branch_instruction(prev.rtl_instr)) begin
            `uvm_info("STEP_COMPARE", "检测到分支指令，分析分支条件", UVM_MEDIUM)
            analyze_branch_condition(prev, checkpoint);
         end
         
         // 检查是否为跳转指令
         if (is_jump_instruction(prev.rtl_instr)) begin
            `uvm_info("STEP_COMPARE", "检测到跳转指令，分析跳转目标", UVM_MEDIUM)  
            analyze_jump_target(prev, checkpoint);
         end
         
         // 检查是否为中断/异常
         if (is_interrupt_or_exception(checkpoint.rtl_pc)) begin
            `uvm_info("STEP_COMPARE", "检测到中断/异常，分析处理流程", UVM_MEDIUM)
            analyze_interrupt_exception(checkpoint);
         end
      end
      
      `uvm_info("STEP_COMPARE", "=== 不匹配分析结束 ===", UVM_MEDIUM)
      
   endfunction
   
   // 🔹 生成诊断报告
   virtual function void generate_debug_report();
      string report_file = $sformatf("step_compare_debug_%0t.txt", $realtime);
      int fd = $fopen(report_file, "w");
      
      $fdisplay(fd, "Step-and-Compare调试报告");
      $fdisplay(fd, "========================");
      $fdisplay(fd, "总检查点数: %0d", checkpoint_history.size());
      $fdisplay(fd, "不匹配次数: %0d", mismatch_count);
      $fdisplay(fd, "匹配率: %.2f%%", 
               (checkpoint_history.size()-mismatch_count)*100.0/checkpoint_history.size());
      $fdisplay(fd, "");
      
      // 详细不匹配历史
      $fdisplay(fd, "不匹配历史:");
      foreach(checkpoint_history[i]) begin
         if (checkpoint_history[i].rtl_pc !== checkpoint_history[i].iss_pc) begin
            $fdisplay(fd, "[%0t] PC: RTL=0x%08x ISS=0x%08x",
                     checkpoint_history[i].timestamp,
                     checkpoint_history[i].rtl_pc,
                     checkpoint_history[i].iss_pc);
         end
      end
      
      $fclose(fd);
      `uvm_info("STEP_COMPARE", $sformatf("调试报告生成: %s", report_file), UVM_LOW)
   endfunction
   
endclass
```

---

## 📈 Part 6: 大规模回归测试管理

### 🔄 并行回归测试

#### 智能任务调度器

```bash
#!/bin/bash
# regression_scheduler.sh - 智能回归测试调度器

# 🔹 配置参数
MAX_PARALLEL_JOBS=${MAX_PARALLEL_JOBS:-4}
REGRESSION_NAME=${1:-"cv32e40p_nightly"}
EMAIL_NOTIFY=${EMAIL_NOTIFY:-""}

# 🔹 测试列表
REGRESSION_TESTS=(
    "hello-world"
    "arithmetic_test"
    "interrupt_test"
    "debug_test"
    "memory_stress"
    "corev_rand_arithmetic_base_test"
    "corev_rand_interrupt_test"
    "corev_rand_debug_test"
)

echo "📈 大规模回归测试调度器"
echo "======================"
echo "回归名称: $REGRESSION_NAME"
echo "并行任务数: $MAX_PARALLEL_JOBS"
echo "测试总数: ${#REGRESSION_TESTS[@]}"
echo ""

# 🔹 创建结果目录
RESULTS_DIR="regression_results_$(date +%Y%m%d_%H%M%S)"
mkdir -p $RESULTS_DIR
cd $RESULTS_DIR

# 🔹 任务状态跟踪
declare -A job_status
declare -A job_pids
declare -A job_start_time
running_jobs=0

# 🔹 任务执行函数
run_test_job() {
    local test_name=$1
    local job_id=$2
    
    echo "[作业$job_id] 开始测试: $test_name"
    job_start_time[$job_id]=$(date +%s)
    
    # 创建作业特定目录
    mkdir -p "job_${job_id}_${test_name}"
    cd "job_${job_id}_${test_name}"
    
    # 运行测试
    make test TEST=$test_name > "test_${test_name}.log" 2>&1
    test_result=$?
    
    # 记录结果
    end_time=$(date +%s)
    duration=$((end_time - job_start_time[$job_id]))
    
    if [ $test_result -eq 0 ]; then
        job_status[$job_id]="PASSED"
        echo "[作业$job_id] ✅ $test_name PASSED (${duration}s)"
    else
        job_status[$job_id]="FAILED"
        echo "[作业$job_id] ❌ $test_name FAILED (${duration}s)"
    fi
    
    # 返回上级目录
    cd ..
    
    return $test_result
}

# 🔹 智能调度逻辑
schedule_tests() {
    local job_id=0
    
    for test in "${REGRESSION_TESTS[@]}"; do
        # 等待空闲槽位
        while [ $running_jobs -ge $MAX_PARALLEL_JOBS ]; do
            check_completed_jobs
            sleep 2
        done
        
        # 启动新作业
        job_id=$((job_id + 1))
        echo "🚀 调度作业$job_id: $test"
        
        (run_test_job "$test" $job_id) &
        job_pids[$job_id]=$!
        running_jobs=$((running_jobs + 1))
    done
    
    # 等待所有作业完成
    echo "⏳ 等待所有作业完成..."
    while [ $running_jobs -gt 0 ]; do
        check_completed_jobs
        sleep 5
    done
}

# 🔹 检查已完成的作业
check_completed_jobs() {
    for job_id in "${!job_pids[@]}"; do
        local pid=${job_pids[$job_id]}
        
        if ! kill -0 $pid 2>/dev/null; then
            # 作业已完成
            unset job_pids[$job_id]
            running_jobs=$((running_jobs - 1))
            
            echo "✅ 作业$job_id 完成"
        fi
    done
}

# 🔹 生成回归报告
generate_regression_report() {
    local report_file="regression_report_${REGRESSION_NAME}.html"
    
    cat > $report_file << 'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>CV32E40P回归测试报告</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .passed { color: green; font-weight: bold; }
        .failed { color: red; font-weight: bold; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
    </style>
</head>
<body>
    <h1>CV32E40P回归测试报告</h1>
    <h2>测试概览</h2>
EOF

    # 统计结果
    local total_tests=${#REGRESSION_TESTS[@]}
    local passed_tests=0
    local failed_tests=0
    
    for status in "${job_status[@]}"; do
        if [ "$status" = "PASSED" ]; then
            passed_tests=$((passed_tests + 1))
        else
            failed_tests=$((failed_tests + 1))
        fi
    done
    
    # 添加统计到报告
    cat >> $report_file << EOF
    <p><strong>总测试数:</strong> $total_tests</p>
    <p><strong>通过:</strong> <span class="passed">$passed_tests</span></p>
    <p><strong>失败:</strong> <span class="failed">$failed_tests</span></p>
    <p><strong>通过率:</strong> $(echo "scale=1; $passed_tests*100/$total_tests" | bc)%</p>
    
    <h2>详细结果</h2>
    <table>
        <tr><th>测试名称</th><th>状态</th><th>执行时间</th><th>日志</th></tr>
EOF

    # 添加详细结果
    local i=0
    for test in "${REGRESSION_TESTS[@]}"; do
        i=$((i + 1))
        local status=${job_status[$i]:-"UNKNOWN"}
        local duration_file="job_${i}_${test}/duration.txt"
        local duration="N/A"
        
        if [ -f "$duration_file" ]; then
            duration=$(cat "$duration_file")
        fi
        
        local status_class="failed"
        if [ "$status" = "PASSED" ]; then
            status_class="passed"
        fi
        
        cat >> $report_file << EOF
        <tr>
            <td>$test</td>
            <td><span class="$status_class">$status</span></td>
            <td>${duration}s</td>
            <td><a href="job_${i}_${test}/test_${test}.log">查看日志</a></td>
        </tr>
EOF
    done
    
    cat >> $report_file << 'EOF'
    </table>
    
    <h2>环境信息</h2>
    <p><strong>测试时间:</strong> $(date)</p>
    <p><strong>仿真器:</strong> $CV_SIMULATOR</p>
    <p><strong>并行度:</strong> $MAX_PARALLEL_JOBS</p>
    
</body>
</html>
EOF

    echo "📋 回归报告生成: $report_file"
    
    # 发送邮件通知
    if [ -n "$EMAIL_NOTIFY" ]; then
        echo "📧 发送邮件通知到: $EMAIL_NOTIFY"
        echo "CV32E40P回归测试完成: $passed_tests/$total_tests 通过" | \
            mail -s "回归测试报告 - $REGRESSION_NAME" -a $report_file $EMAIL_NOTIFY
    fi
}

# 🔹 主执行流程
echo "🚀 开始回归测试调度..."
schedule_tests

echo "📊 生成回归报告..."
generate_regression_report

echo "🎉 回归测试完成!"
echo "结果目录: $(pwd)"
```

### 📊 回归结果分析

#### 趋势分析工具

```python
#!/usr/bin/env python3
# regression_analyzer.py - 回归测试趋势分析工具

import json
import matplotlib.pyplot as plt
import pandas as pd
from datetime import datetime, timedelta
import argparse
import glob
import os

class RegressionAnalyzer:
    def __init__(self, results_dir="regression_results"):
        self.results_dir = results_dir
        self.data = []
        
    def collect_regression_data(self):
        """收集历史回归测试数据"""
        print("📊 收集回归测试数据...")
        
        # 查找所有回归结果目录
        result_dirs = glob.glob(f"{self.results_dir}_*")
        result_dirs.sort()
        
        for result_dir in result_dirs:
            try:
                # 解析目录名获取时间戳
                timestamp_str = result_dir.split('_')[-2] + '_' + result_dir.split('_')[-1]
                timestamp = datetime.strptime(timestamp_str, "%Y%m%d_%H%M%S")
                
                # 分析该次回归的结果
                regression_data = self.analyze_single_regression(result_dir, timestamp)
                if regression_data:
                    self.data.append(regression_data)
                    
            except Exception as e:
                print(f"⚠️  解析 {result_dir} 时出错: {e}")
        
        print(f"✅ 收集到 {len(self.data)} 次回归数据")
        
    def analyze_single_regression(self, result_dir, timestamp):
        """分析单次回归测试结果"""
        
        # 统计各job目录
        job_dirs = glob.glob(f"{result_dir}/job_*")
        
        passed = 0
        failed = 0
        total_time = 0
        test_details = []
        
        for job_dir in job_dirs:
            # 解析job信息
            job_name = os.path.basename(job_dir)
            parts = job_name.split('_')
            if len(parts) >= 3:
                test_name = '_'.join(parts[2:])
                
                # 检查测试结果
                log_file = f"{job_dir}/test_{test_name}.log"
                if os.path.exists(log_file):
                    with open(log_file, 'r') as f:
                        log_content = f.read()
                        
                    if "TEST PASSED" in log_content:
                        passed += 1
                        status = "PASSED"
                    else:
                        failed += 1
                        status = "FAILED"
                    
                    # 提取执行时间
                    duration = self.extract_test_duration(log_content)
                    total_time += duration
                    
                    test_details.append({
                        'name': test_name,
                        'status': status,
                        'duration': duration
                    })
        
        total_tests = passed + failed
        if total_tests == 0:
            return None
            
        return {
            'timestamp': timestamp,
            'total_tests': total_tests,
            'passed': passed,
            'failed': failed,
            'pass_rate': passed / total_tests * 100,
            'total_time': total_time,
            'avg_time': total_time / total_tests if total_tests > 0 else 0,
            'test_details': test_details
        }
    
    def extract_test_duration(self, log_content):
        """从日志中提取测试执行时间"""
        # 查找仿真时间信息
        lines = log_content.split('\n')
        for line in lines:
            if "Simulation time" in line and "seconds" in line:
                try:
                    # 提取时间数值
                    parts = line.split()
                    for i, part in enumerate(parts):
                        if "seconds" in part and i > 0:
                            return float(parts[i-1])
                except:
                    pass
        return 0.0
    
    def generate_trend_charts(self):
        """生成趋势分析图表"""
        if not self.data:
            print("❌ 没有数据可以分析")
            return
            
        df = pd.DataFrame(self.data)
        
        # 创建图表
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))
        fig.suptitle('CV32E40P回归测试趋势分析', fontsize=16)
        
        # 1. 通过率趋势
        ax1.plot(df['timestamp'], df['pass_rate'], marker='o', linewidth=2)
        ax1.set_title('测试通过率趋势')
        ax1.set_ylabel('通过率 (%)')
        ax1.grid(True, alpha=0.3)
        ax1.set_ylim(0, 100)
        
        # 2. 测试数量趋势
        ax2.plot(df['timestamp'], df['total_tests'], marker='s', color='orange', linewidth=2)
        ax2.set_title('测试总数趋势')
        ax2.set_ylabel('测试数量')
        ax2.grid(True, alpha=0.3)
        
        # 3. 执行时间趋势
        ax3.plot(df['timestamp'], df['avg_time'], marker='^', color='green', linewidth=2)
        ax3.set_title('平均执行时间趋势')
        ax3.set_ylabel('平均时间 (秒)')
        ax3.grid(True, alpha=0.3)
        
        # 4. 失败率分布
        ax4.bar(range(len(df)), df['failed'], color='red', alpha=0.7)
        ax4.set_title('失败测试数量')
        ax4.set_ylabel('失败数量')
        ax4.set_xlabel('回归次数')
        ax4.grid(True, alpha=0.3)
        
        # 调整布局
        plt.tight_layout()
        
        # 保存图表
        chart_file = f"regression_trend_analysis_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
        plt.savefig(chart_file, dpi=300, bbox_inches='tight')
        print(f"📈 趋势分析图表已保存: {chart_file}")
        
        # 显示图表
        plt.show()
    
    def generate_quality_report(self):
        """生成质量分析报告"""
        if not self.data:
            return
            
        df = pd.DataFrame(self.data)
        
        # 生成质量报告
        report = {
            'summary': {
                'total_regressions': len(df),
                'avg_pass_rate': df['pass_rate'].mean(),
                'min_pass_rate': df['pass_rate'].min(),
                'max_pass_rate': df['pass_rate'].max(),
                'avg_execution_time': df['total_time'].mean(),
                'total_tests_run': df['total_tests'].sum()
            },
            'recent_performance': {},
            'problematic_tests': []
        }
        
        # 最近7次回归的表现
        if len(df) >= 7:
            recent_df = df.tail(7)
            report['recent_performance'] = {
                'avg_pass_rate': recent_df['pass_rate'].mean(),
                'trend': 'improving' if recent_df['pass_rate'].iloc[-1] > recent_df['pass_rate'].iloc[0] else 'declining'
            }
        
        # 识别问题测试
        test_failure_count = {}
        for regression in self.data:
            for test in regression['test_details']:
                if test['status'] == 'FAILED':
                    test_name = test['name']
                    test_failure_count[test_name] = test_failure_count.get(test_name, 0) + 1
        
        # 按失败次数排序
        problematic_tests = sorted(test_failure_count.items(), 
                                 key=lambda x: x[1], reverse=True)[:10]
        report['problematic_tests'] = problematic_tests
        
        # 保存报告
        report_file = f"quality_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2, default=str)
        
        print(f"📋 质量报告已生成: {report_file}")
        
        # 打印摘要
        print("\n📊 质量分析摘要:")
        print(f"总回归次数: {report['summary']['total_regressions']}")
        print(f"平均通过率: {report['summary']['avg_pass_rate']:.1f}%")
        print(f"最低通过率: {report['summary']['min_pass_rate']:.1f}%")
        print(f"最高通过率: {report['summary']['max_pass_rate']:.1f}%")
        
        if problematic_tests:
            print(f"\n🔍 最常失败的测试:")
            for test_name, failure_count in problematic_tests[:5]:
                print(f"  {test_name}: {failure_count}次失败")

def main():
    parser = argparse.ArgumentParser(description='CV32E40P回归测试趋势分析工具')
    parser.add_argument('--results-dir', default='regression_results',
                       help='回归结果目录前缀')
    parser.add_argument('--action', choices=['collect', 'chart', 'report', 'all'],
                       default='all', help='执行的操作')
    
    args = parser.parse_args()
    
    analyzer = RegressionAnalyzer(args.results_dir)
    
    if args.action in ['collect', 'all']:
        analyzer.collect_regression_data()
    
    if args.action in ['chart', 'all']:
        analyzer.generate_trend_charts()
    
    if args.action in ['report', 'all']:
        analyzer.generate_quality_report()

if __name__ == "__main__":
    main()
```

---

## 🎉 总结和最佳实践

### ✅ 高级功能使用清单

使用本指南后，你应该能够：

- [ ] ✅ 配置和分析多种类型的覆盖率
- [ ] ✅ 使用COREV-DV生成定制化随机测试
- [ ] ✅ 监控和优化仿真性能
- [ ] ✅ 配置多种仿真器并对比性能
- [ ] ✅ 设置Step-and-Compare进行ISS验证
- [ ] ✅ 管理大规模并行回归测试
- [ ] ✅ 分析回归趋势和质量指标

### 🔧 实践建议

1. **渐进式使用**: 先掌握基础功能，再逐步使用高级特性
2. **自动化优先**: 尽可能使用脚本自动化重复性工作
3. **性能监控**: 定期监控仿真性能，及时优化配置
4. **质量门控**: 建立覆盖率和通过率的质量标准
5. **经验积累**: 记录使用经验，建立团队知识库

### 🔗 下一步学习

- **[02-组件扩展开发指南](./02-组件扩展开发指南.md)** - 学习如何扩展和定制验证组件
- **[../07-案例和经验/01-真实项目案例研究.md](../07-案例和经验/01-真实项目案例研究.md)** - 了解实际项目中的应用案例

---

> 💡 **高级功能使用心得**  
> CV32E40P平台的高级功能可以显著提升验证效率和质量。建议根据项目需要选择性使用，避免一开始就使用所有功能而增加复杂性。

> 🚀 **效率提升建议**  
> 建立标准化的配置模板和自动化脚本，这样可以确保团队成员都能一致地使用这些高级功能，并且能够快速适应项目需求的变化。