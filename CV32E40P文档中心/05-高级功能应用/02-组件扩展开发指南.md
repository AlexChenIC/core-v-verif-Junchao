# CV32E40P组件扩展开发指南 🛠️

> **系统化的验证组件扩展和定制方法**  
> 从新Agent开发到第三方IP集成的完整实战指南

---

## 📋 本指南适用场景

- 🏗️ **新协议支持** - 添加自定义总线协议的验证支持
- 🔧 **功能扩展** - 为现有Agent添加新功能和特性
- 🎯 **第三方IP集成** - 集成外部IP的验证环境
- 📊 **自定义监控** - 开发特定的监控和分析组件
- 🎮 **测试增强** - 创建专用的测试组件和序列

---

## 🏗️ Part 1: 新Agent开发完整流程

### 📁 Agent开发标准目录结构

按照CV32E40P项目约定创建Agent目录：

```bash
# 🔹 创建新Agent目录结构
AGENT_NAME="uvma_my_protocol"
BASE_DIR="lib/uvm_agents/$AGENT_NAME"

mkdir -p $BASE_DIR/{src/{comps,obj,seq},doc,examples}
mkdir -p $BASE_DIR/src/comps  # 组件实现
mkdir -p $BASE_DIR/src/obj    # 对象定义  
mkdir -p $BASE_DIR/src/seq    # 序列库

echo "✅ Agent目录结构创建完成: $BASE_DIR"
```

### 🔧 Step 1: 接口定义

创建协议接口 `uvma_my_protocol_if.sv`:

```systemverilog
// lib/uvm_agents/uvma_my_protocol/src/uvma_my_protocol_if.sv

/**
 * 自定义协议接口定义
 * 遵循CV32E40P项目的接口设计模式
 */
interface uvma_my_protocol_if (
   input logic clk,
   input logic rst_n
);
   
   // 🔹 协议信号定义
   logic         req;           // 请求信号
   logic         gnt;           // 授权信号
   logic [31:0]  addr;          // 地址信号
   logic [31:0]  wdata;         // 写数据
   logic [31:0]  rdata;         // 读数据
   logic         we;            // 写使能
   logic [3:0]   be;            // 字节使能
   logic         valid;         // 数据有效
   logic         ready;         // 准备就绪
   
   // 🔹 时钟域定义 (遵循项目约定)
   clocking mst_cb @(posedge clk);
      default input #1step output #1step;
      output req, addr, wdata, we, be;
      input  gnt, rdata, valid, ready;
   endclocking
   
   clocking slv_cb @(posedge clk);
      default input #1step output #1step;
      input  req, addr, wdata, we, be;
      output gnt, rdata, valid, ready;
   endclocking
   
   clocking mon_cb @(posedge clk);
      default input #1step;
      input req, gnt, addr, wdata, rdata, we, be, valid, ready;
   endclocking
   
   // 🔹 模块端口定义
   modport mst_mp (clocking mst_cb, input clk, rst_n);
   modport slv_mp (clocking slv_cb, input clk, rst_n);  
   modport mon_mp (clocking mon_cb, input clk, rst_n);
   
   // 🔹 协议断言 (确保时序正确性)
   property req_gnt_handshake;
      @(posedge clk) disable iff (!rst_n)
      req |-> ##[1:10] gnt;
   endproperty
   
   property valid_after_gnt;
      @(posedge clk) disable iff (!rst_n)
      (req && gnt) |-> ##[1:5] valid;
   endproperty
   
   assert property (req_gnt_handshake) 
      else `uvm_error("MY_PROTOCOL_IF", "Request/Grant handshake violation");
   
   assert property (valid_after_gnt)
      else `uvm_error("MY_PROTOCOL_IF", "Valid signal timing violation");
   
   // 🔹 覆盖率采样点
   covergroup protocol_cg @(posedge clk);
      REQ_GNT: coverpoint {req, gnt} {
         bins idle        = {2'b00};
         bins requesting  = {2'b10};
         bins granted     = {2'b11};
      }
      
      ADDR_RANGE: coverpoint addr {
         bins low_addr  = {[32'h0000_0000:32'h3FFF_FFFF]};
         bins mid_addr  = {[32'h4000_0000:32'h7FFF_FFFF]};
         bins high_addr = {[32'h8000_0000:32'hFFFF_FFFF]};
      }
      
      ACCESS_TYPE: coverpoint we;
      
      // 交叉覆盖率
      ADDR_ACCESS_CROSS: cross ADDR_RANGE, ACCESS_TYPE;
   endgroup
   
   initial begin
      protocol_cg cg = new();
   end

endinterface : uvma_my_protocol_if
```

### 🎯 Step 2: 配置对象

创建配置类 `uvma_my_protocol_cfg.sv`:

```systemverilog
// lib/uvm_agents/uvma_my_protocol/src/obj/uvma_my_protocol_cfg.sv

/**
 * 自定义协议Agent配置类
 * 遵循CV32E40P项目的配置模式
 */
class uvma_my_protocol_cfg_c extends uvm_object;
   
   // 🔹 基础配置项
   rand bit                      enabled;              // Agent使能
   rand uvm_active_passive_enum  is_active;            // 主动/被动模式
   rand bit                      cov_model_enabled;    // 覆盖率模型使能
   rand bit                      trn_log_enabled;      // 事务日志使能
   
   // 🔹 协议特定配置
   rand int unsigned             max_outstanding_req;  // 最大未完成请求数
   rand int unsigned             req_timeout_cycles;   // 请求超时周期
   rand bit                      enable_backpressure; // 背压使能
   rand int unsigned             backpressure_chance;  // 背压概率
   
   // 🔹 时序配置
   rand int unsigned             req_to_gnt_delay_min; // 最小授权延迟
   rand int unsigned             req_to_gnt_delay_max; // 最大授权延迟
   rand int unsigned             gnt_to_valid_delay;   // 授权到有效延迟
   
   // 🔹 地址映射配置
   rand bit [31:0]               addr_base;           // 基地址
   rand bit [31:0]               addr_mask;           // 地址掩码
   
   // 🔹 约束定义
   constraint reasonable_values_c {
      max_outstanding_req inside {[1:16]};
      req_timeout_cycles inside {[100:10000]};
      backpressure_chance inside {[0:50]};
      req_to_gnt_delay_min <= req_to_gnt_delay_max;
      req_to_gnt_delay_max inside {[1:20]};
      gnt_to_valid_delay inside {[1:10]};
   }
   
   constraint addr_alignment_c {
      addr_base[1:0] == 2'b00;  // 字对齐
   }
   
   // 🔹 UVM标准宏
   `uvm_object_utils_begin(uvma_my_protocol_cfg_c)
      `uvm_field_int (enabled             , UVM_DEFAULT)
      `uvm_field_enum(uvm_active_passive_enum, is_active, UVM_DEFAULT)
      `uvm_field_int (cov_model_enabled   , UVM_DEFAULT)
      `uvm_field_int (trn_log_enabled     , UVM_DEFAULT)
      `uvm_field_int (max_outstanding_req , UVM_DEFAULT)
      `uvm_field_int (req_timeout_cycles  , UVM_DEFAULT)
      `uvm_field_int (enable_backpressure , UVM_DEFAULT)
      `uvm_field_int (backpressure_chance , UVM_DEFAULT)
      `uvm_field_int (req_to_gnt_delay_min, UVM_DEFAULT)
      `uvm_field_int (req_to_gnt_delay_max, UVM_DEFAULT)
      `uvm_field_int (gnt_to_valid_delay  , UVM_DEFAULT)
      `uvm_field_int (addr_base           , UVM_DEFAULT)
      `uvm_field_int (addr_mask           , UVM_DEFAULT)
   `uvm_object_utils_end
   
   /**
    * 构造函数
    */
   function new(string name = "uvma_my_protocol_cfg");
      super.new(name);
   endfunction
   
   /**
    * 配置验证函数
    */
   virtual function bit is_valid();
      if (req_to_gnt_delay_min > req_to_gnt_delay_max) begin
         `uvm_error("CFG", "Invalid delay configuration")
         return 0;
      end
      
      if (max_outstanding_req == 0) begin
         `uvm_error("CFG", "Outstanding requests must be > 0")
         return 0;
      end
      
      return 1;
   endfunction
   
   /**
    * 配置调试打印
    */
   virtual function void do_print(uvm_printer printer);
      super.do_print(printer);
      printer.print_string("protocol_config", "MY_PROTOCOL");
   endfunction

endclass : uvma_my_protocol_cfg_c
```

### 📊 Step 3: 上下文对象

创建上下文类 `uvma_my_protocol_cntxt.sv`:

```systemverilog
// lib/uvm_agents/uvma_my_protocol/src/obj/uvma_my_protocol_cntxt.sv

/**
 * 自定义协议Agent上下文类
 * 存储运行时状态和共享数据
 */
class uvma_my_protocol_cntxt_c extends uvm_object;
   
   // 🔹 虚拟接口句柄
   virtual uvma_my_protocol_if  vif;
   
   // 🔹 运行时状态
   bit                          agent_enabled;
   bit                          reset_state;
   int unsigned                 outstanding_req_count;
   
   // 🔹 事务历史记录
   uvma_my_protocol_mon_trn_c   mon_trns[$];        // 监控事务队列
   uvma_my_protocol_seq_item_c  seq_items[$];       // 序列项队列
   
   // 🔹 统计信息
   int unsigned                 total_requests;
   int unsigned                 total_responses;
   int unsigned                 error_count;
   realtime                     last_activity_time;
   
   // 🔹 性能指标
   realtime                     avg_request_latency;
   int unsigned                 max_outstanding_reached;
   
   // 🔹 同步对象
   semaphore                    req_sem;            // 请求信号量
   event                        reset_done;         // 复位完成事件
   
   `uvm_object_utils_begin(uvma_my_protocol_cntxt_c)
      `uvm_field_int(agent_enabled        , UVM_DEFAULT)
      `uvm_field_int(reset_state          , UVM_DEFAULT)
      `uvm_field_int(outstanding_req_count, UVM_DEFAULT)
      `uvm_field_int(total_requests       , UVM_DEFAULT)
      `uvm_field_int(total_responses      , UVM_DEFAULT)
      `uvm_field_int(error_count          , UVM_DEFAULT)
   `uvm_object_utils_end
   
   /**
    * 构造函数
    */
   function new(string name = "uvma_my_protocol_cntxt");
      super.new(name);
      req_sem = new(16);  // 最大16个并发请求
   endfunction
   
   /**
    * 复位上下文状态
    */
   virtual function void reset();
      outstanding_req_count = 0;
      total_requests = 0;
      total_responses = 0;
      error_count = 0;
      reset_state = 1;
      
      // 清空历史记录
      mon_trns.delete();
      seq_items.delete();
      
      // 重置同步对象
      req_sem = new(16);
      
      `uvm_info("CNTXT", "Context reset completed", UVM_MEDIUM)
   endfunction
   
   /**
    * 更新统计信息
    */
   virtual function void update_stats(uvma_my_protocol_mon_trn_c trn);
      if (trn.is_request()) begin
         total_requests++;
         outstanding_req_count++;
         if (outstanding_req_count > max_outstanding_reached) begin
            max_outstanding_reached = outstanding_req_count;
         end
      end else if (trn.is_response()) begin
         total_responses++;
         if (outstanding_req_count > 0) begin
            outstanding_req_count--;
         end
      end
      
      last_activity_time = $realtime;
   endfunction
   
   /**
    * 检查健康状态
    */
   virtual function bit is_healthy();
      // 检查是否有超时的请求
      if (outstanding_req_count > 0 && 
          ($realtime - last_activity_time) > 100000) begin  // 100us超时
         `uvm_warning("CNTXT", "Potential timeout detected")
         return 0;
      end
      
      // 检查错误率
      if (total_requests > 0 && 
          (error_count * 100 / total_requests) > 5) begin  // 5%错误率阈值
         `uvm_warning("CNTXT", "High error rate detected")
         return 0;
      end
      
      return 1;
   endfunction
   
   /**
    * 生成状态报告
    */
   virtual function string get_status_report();
      string report;
      report = $sformatf("Protocol Status Report:\n");
      report = {report, $sformatf("  Total Requests: %0d\n", total_requests)};
      report = {report, $sformatf("  Total Responses: %0d\n", total_responses)};
      report = {report, $sformatf("  Outstanding: %0d\n", outstanding_req_count)};
      report = {report, $sformatf("  Error Count: %0d\n", error_count)};
      report = {report, $sformatf("  Max Outstanding: %0d\n", max_outstanding_reached)};
      return report;
   endfunction

endclass : uvma_my_protocol_cntxt_c
```

### 🎭 Step 4: 序列项定义

创建序列项 `uvma_my_protocol_seq_item.sv`:

```systemverilog
// lib/uvm_agents/uvma_my_protocol/src/obj/uvma_my_protocol_seq_item.sv

/**
 * 自定义协议序列项类
 * 定义驱动器和序列器之间传递的数据结构
 */
class uvma_my_protocol_seq_item_c extends uvm_sequence_item;
   
   // 🔹 事务类型枚举
   typedef enum {
      MY_PROTOCOL_READ,
      MY_PROTOCOL_WRITE,
      MY_PROTOCOL_BURST_READ,
      MY_PROTOCOL_BURST_WRITE
   } my_protocol_access_type_e;
   
   // 🔹 核心事务字段
   rand my_protocol_access_type_e  access_type;     // 访问类型
   rand bit [31:0]                 address;         // 地址
   rand bit [31:0]                 data;            // 数据
   rand bit [3:0]                  byte_enable;     // 字节使能
   rand int unsigned               burst_length;    // 突发长度
   
   // 🔹 控制字段
   rand int unsigned               req_delay;       // 请求前延迟
   rand int unsigned               ack_delay;       // 响应延迟
   rand bit                        insert_error;    // 错误注入
   
   // 🔹 响应字段 (由驱动器填充)
   bit                             success;         // 操作成功标志
   bit [31:0]                      rdata;           // 读取数据
   realtime                        start_time;      // 开始时间
   realtime                        end_time;        // 结束时间
   
   // 🔹 约束定义
   constraint address_alignment_c {
      // 根据访问类型约束地址对齐
      if (access_type inside {MY_PROTOCOL_READ, MY_PROTOCOL_WRITE}) {
         if (byte_enable == 4'b1111) address[1:0] == 2'b00;      // 字访问
         else if (byte_enable inside {4'b0011, 4'b1100}) address[0] == 1'b0;  // 半字访问
      }
   }
   
   constraint burst_length_c {
      if (access_type inside {MY_PROTOCOL_BURST_READ, MY_PROTOCOL_BURST_WRITE}) {
         burst_length inside {[2:16]};
      } else {
         burst_length == 1;
      }
   }
   
   constraint reasonable_delays_c {
      req_delay inside {[0:20]};
      ack_delay inside {[0:10]};
      insert_error dist {0 := 95, 1 := 5};  // 5%错误注入概率
   }
   
   // 🔹 UVM标准宏
   `uvm_object_utils_begin(uvma_my_protocol_seq_item_c)
      `uvm_field_enum(my_protocol_access_type_e, access_type, UVM_DEFAULT)
      `uvm_field_int (address      , UVM_DEFAULT)
      `uvm_field_int (data         , UVM_DEFAULT)
      `uvm_field_int (byte_enable  , UVM_DEFAULT)
      `uvm_field_int (burst_length , UVM_DEFAULT)
      `uvm_field_int (req_delay    , UVM_DEFAULT)
      `uvm_field_int (ack_delay    , UVM_DEFAULT)
      `uvm_field_int (insert_error , UVM_DEFAULT)
      `uvm_field_int (success      , UVM_DEFAULT)
      `uvm_field_int (rdata        , UVM_DEFAULT)
   `uvm_object_utils_end
   
   /**
    * 构造函数
    */
   function new(string name = "uvma_my_protocol_seq_item");
      super.new(name);
   endfunction
   
   /**
    * 事务类型检查函数
    */
   virtual function bit is_read();
      return (access_type inside {MY_PROTOCOL_READ, MY_PROTOCOL_BURST_READ});
   endfunction
   
   virtual function bit is_write();
      return (access_type inside {MY_PROTOCOL_WRITE, MY_PROTOCOL_BURST_WRITE});
   endfunction
   
   virtual function bit is_burst();
      return (access_type inside {MY_PROTOCOL_BURST_READ, MY_PROTOCOL_BURST_WRITE});
   endfunction
   
   /**
    * 计算执行时间
    */
   virtual function realtime get_execution_time();
      return end_time - start_time;
   endfunction
   
   /**
    * 自定义比较函数
    */
   virtual function bit do_compare(uvm_object rhs, uvm_comparer comparer);
      uvma_my_protocol_seq_item_c rhs_item;
      
      if (!$cast(rhs_item, rhs)) begin
         return 0;
      end
      
      return (access_type == rhs_item.access_type &&
              address == rhs_item.address &&
              data == rhs_item.data &&
              byte_enable == rhs_item.byte_enable);
   endfunction
   
   /**
    * 自定义打印函数
    */
   virtual function void do_print(uvm_printer printer);
      super.do_print(printer);
      printer.print_string("transaction_type", access_type.name());
      printer.print_string("execution_time", 
                          $sformatf("%.2f ns", get_execution_time()));
   endfunction

endclass : uvma_my_protocol_seq_item_c
```

### 🚗 Step 5: 驱动器实现

创建驱动器 `uvma_my_protocol_drv.sv`:

```systemverilog
// lib/uvm_agents/uvma_my_protocol/src/comps/uvma_my_protocol_drv.sv

/**
 * 自定义协议驱动器
 * 将序列项转换为实际的接口信号
 */
class uvma_my_protocol_drv_c extends uvm_driver#(uvma_my_protocol_seq_item_c);
   
   // 🔹 组件句柄
   virtual uvma_my_protocol_if      vif;
   uvma_my_protocol_cfg_c           cfg;
   uvma_my_protocol_cntxt_c         cntxt;
   
   // 🔹 分析端口
   uvm_analysis_port#(uvma_my_protocol_seq_item_c)  ap;
   
   // 🔹 内部状态
   bit                              driving_enabled;
   uvma_my_protocol_seq_item_c      req_queue[$];
   
   `uvm_component_utils_begin(uvma_my_protocol_drv_c)
      `uvm_field_object(cfg  , UVM_DEFAULT)
      `uvm_field_object(cntxt, UVM_DEFAULT)
   `uvm_component_utils_end
   
   /**
    * 构造函数
    */
   function new(string name = "uvma_my_protocol_drv", uvm_component parent = null);
      super.new(name, parent);
      ap = new("ap", this);
   endfunction
   
   /**
    * 构建阶段
    */
   virtual function void build_phase(uvm_phase phase);
      super.build_phase(phase);
      
      // 获取配置和上下文
      void'(uvm_config_db#(uvma_my_protocol_cfg_c)::get(this, "", "cfg", cfg));
      if (cfg == null) begin
         `uvm_fatal("CFG", "Configuration object is null")
      end
      
      void'(uvm_config_db#(uvma_my_protocol_cntxt_c)::get(this, "", "cntxt", cntxt));
      if (cntxt == null) begin
         `uvm_fatal("CNTXT", "Context object is null")
      end
   endfunction
   
   /**
    * 连接阶段
    */
   virtual function void connect_phase(uvm_phase phase);
      super.connect_phase(phase);
      
      // 获取虚拟接口
      vif = cntxt.vif;
      if (vif == null) begin
         `uvm_fatal("VIF", "Virtual interface is null")
      end
   endfunction
   
   /**
    * 运行阶段
    */
   virtual task run_phase(uvm_phase phase);
      
      // 初始化接口
      initialize_interface();
      
      // 等待复位完成
      wait_for_reset_release();
      
      // 并行启动驱动任务
      fork
         get_and_drive_items();    // 主驱动循环
         monitor_reset();          // 复位监控
      join_none
      
   endtask
   
   /**
    * 初始化接口信号
    */
   virtual task initialize_interface();
      `uvm_info("DRV", "Initializing interface signals", UVM_MEDIUM)
      
      vif.req   <= 1'b0;
      vif.addr  <= 32'h0;
      vif.wdata <= 32'h0;
      vif.we    <= 1'b0;
      vif.be    <= 4'h0;
      
   endtask
   
   /**
    * 等待复位释放
    */
   virtual task wait_for_reset_release();
      `uvm_info("DRV", "Waiting for reset release", UVM_MEDIUM)
      wait(vif.rst_n === 1'b1);
      repeat(5) @(vif.mst_cb);  // 稳定等待
      `uvm_info("DRV", "Reset released, starting to drive", UVM_MEDIUM)
   endtask
   
   /**
    * 主驱动循环
    */
   virtual task get_and_drive_items();
      uvma_my_protocol_seq_item_c req_item;
      
      forever begin
         // 获取下一个序列项
         seq_item_port.get_next_item(req_item);
         
         // 记录开始时间
         req_item.start_time = $realtime;
         
         // 执行驱动
         drive_item(req_item);
         
         // 记录结束时间
         req_item.end_time = $realtime;
         
         // 发送到分析端口
         ap.write(req_item);
         
         // 通知序列器完成
         seq_item_port.item_done();
         
         `uvm_info("DRV", $sformatf("Completed item: %s", req_item.sprint()), UVM_HIGH)
      end
   endtask
   
   /**
    * 驱动单个序列项
    */
   virtual task drive_item(uvma_my_protocol_seq_item_c item);
      
      `uvm_info("DRV", $sformatf("Driving item: %s @ 0x%08x", 
                                item.access_type.name(), item.address), UVM_MEDIUM)
      
      // 请求前延迟
      if (item.req_delay > 0) begin
         repeat(item.req_delay) @(vif.mst_cb);
      end
      
      // 根据访问类型执行相应操作
      case (item.access_type)
         MY_PROTOCOL_READ:        drive_read(item);
         MY_PROTOCOL_WRITE:       drive_write(item);
         MY_PROTOCOL_BURST_READ:  drive_burst_read(item);
         MY_PROTOCOL_BURST_WRITE: drive_burst_write(item);
         default: `uvm_error("DRV", $sformatf("Unsupported access type: %s", 
                                             item.access_type.name()));
      endcase
      
   endtask
   
   /**
    * 驱动读操作
    */
   virtual task drive_read(uvma_my_protocol_seq_item_c item);
      
      // 🔹 第1步：发起读请求
      vif.mst_cb.req   <= 1'b1;
      vif.mst_cb.addr  <= item.address;
      vif.mst_cb.we    <= 1'b0;
      vif.mst_cb.be    <= item.byte_enable;
      vif.mst_cb.wdata <= 32'h0;
      
      // 🔹 第2步：等待授权
      do begin
         @(vif.mst_cb);
      end while (vif.mst_cb.gnt !== 1'b1);
      
      // 🔹 第3步：清除请求
      vif.mst_cb.req <= 1'b0;
      
      // 🔹 第4步：等待数据有效
      do begin
         @(vif.mst_cb);
      end while (vif.mst_cb.valid !== 1'b1);
      
      // 🔹 第5步：采样读取数据
      item.rdata = vif.mst_cb.rdata;
      item.success = 1'b1;
      
      `uvm_info("DRV", $sformatf("Read completed: addr=0x%08x, data=0x%08x", 
                                item.address, item.rdata), UVM_HIGH)
      
   endtask
   
   /**
    * 驱动写操作
    */
   virtual task drive_write(uvma_my_protocol_seq_item_c item);
      
      // 🔹 第1步：发起写请求
      vif.mst_cb.req   <= 1'b1;
      vif.mst_cb.addr  <= item.address;
      vif.mst_cb.we    <= 1'b1;
      vif.mst_cb.be    <= item.byte_enable;
      vif.mst_cb.wdata <= item.data;
      
      // 🔹 第2步：等待授权
      do begin
         @(vif.mst_cb);
      end while (vif.mst_cb.gnt !== 1'b1);
      
      // 🔹 第3步：清除请求
      vif.mst_cb.req <= 1'b0;
      
      // 🔹 第4步：等待写完成确认
      if (vif.mst_cb.ready === 1'b1) begin
         item.success = 1'b1;
      end else begin
         // 等待ready信号
         do begin
            @(vif.mst_cb);
         end while (vif.mst_cb.ready !== 1'b1);
         item.success = 1'b1;
      end
      
      `uvm_info("DRV", $sformatf("Write completed: addr=0x%08x, data=0x%08x", 
                                item.address, item.data), UVM_HIGH)
      
   endtask
   
   /**
    * 驱动突发读操作
    */
   virtual task drive_burst_read(uvma_my_protocol_seq_item_c item);
      bit [31:0] current_addr;
      bit [31:0] read_data[$];
      
      current_addr = item.address;
      
      for (int i = 0; i < item.burst_length; i++) begin
         
         // 发起读请求
         vif.mst_cb.req  <= 1'b1;
         vif.mst_cb.addr <= current_addr;
         vif.mst_cb.we   <= 1'b0;
         vif.mst_cb.be   <= item.byte_enable;
         
         // 等待授权
         do begin
            @(vif.mst_cb);
         end while (vif.mst_cb.gnt !== 1'b1);
         
         // 清除请求
         vif.mst_cb.req <= 1'b0;
         
         // 等待数据
         do begin
            @(vif.mst_cb);
         end while (vif.mst_cb.valid !== 1'b1);
         
         // 采样数据
         read_data.push_back(vif.mst_cb.rdata);
         
         // 递增地址
         current_addr += 4;
      end
      
      // 记录第一个数据到item中
      if (read_data.size() > 0) begin
         item.rdata = read_data[0];
      end
      
      item.success = 1'b1;
      
      `uvm_info("DRV", $sformatf("Burst read completed: %0d transfers", 
                                item.burst_length), UVM_MEDIUM)
      
   endtask
   
   /**
    * 驱动突发写操作
    */
   virtual task drive_burst_write(uvma_my_protocol_seq_item_c item);
      bit [31:0] current_addr;
      bit [31:0] write_data;
      
      current_addr = item.address;
      write_data = item.data;
      
      for (int i = 0; i < item.burst_length; i++) begin
         
         // 发起写请求
         vif.mst_cb.req   <= 1'b1;
         vif.mst_cb.addr  <= current_addr;
         vif.mst_cb.we    <= 1'b1;
         vif.mst_cb.be    <= item.byte_enable;
         vif.mst_cb.wdata <= write_data;
         
         // 等待授权
         do begin
            @(vif.mst_cb);
         end while (vif.mst_cb.gnt !== 1'b1);
         
         // 清除请求
         vif.mst_cb.req <= 1'b0;
         
         // 等待写完成
         do begin
            @(vif.mst_cb);
         end while (vif.mst_cb.ready !== 1'b1);
         
         // 递增地址和数据
         current_addr += 4;
         write_data += 1;  // 简单的数据模式
      end
      
      item.success = 1'b1;
      
      `uvm_info("DRV", $sformatf("Burst write completed: %0d transfers", 
                                item.burst_length), UVM_MEDIUM)
      
   endtask
   
   /**
    * 复位监控任务
    */
   virtual task monitor_reset();
      forever begin
         @(negedge vif.rst_n);
         `uvm_info("DRV", "Reset asserted, stopping driving", UVM_MEDIUM)
         driving_enabled = 0;
         
         // 初始化接口
         initialize_interface();
         
         // 等待复位释放
         @(posedge vif.rst_n);
         `uvm_info("DRV", "Reset released, resuming driving", UVM_MEDIUM)
         driving_enabled = 1;
      end
   endtask

endclass : uvma_my_protocol_drv_c
```

### 👁️ Step 6: 监控器实现

创建监控器 `uvma_my_protocol_mon.sv`:

```systemverilog
// lib/uvm_agents/uvma_my_protocol/src/comps/uvma_my_protocol_mon.sv

/**
 * 自定义协议监控器
 * 被动观察接口活动并生成事务
 */
class uvma_my_protocol_mon_c extends uvm_monitor;
   
   // 🔹 组件句柄
   virtual uvma_my_protocol_if      vif;
   uvma_my_protocol_cfg_c           cfg;
   uvma_my_protocol_cntxt_c         cntxt;
   
   // 🔹 分析端口
   uvm_analysis_port#(uvma_my_protocol_mon_trn_c)  ap;
   
   // 🔹 内部状态
   bit                              monitoring_enabled;
   uvma_my_protocol_mon_trn_c       pending_transactions[$];
   
   `uvm_component_utils_begin(uvma_my_protocol_mon_c)
      `uvm_field_object(cfg  , UVM_DEFAULT)
      `uvm_field_object(cntxt, UVM_DEFAULT)
   `uvm_component_utils_end
   
   /**
    * 构造函数
    */
   function new(string name = "uvma_my_protocol_mon", uvm_component parent = null);
      super.new(name, parent);
      ap = new("ap", this);
   endfunction
   
   /**
    * 构建阶段
    */
   virtual function void build_phase(uvm_phase phase);
      super.build_phase(phase);
      
      void'(uvm_config_db#(uvma_my_protocol_cfg_c)::get(this, "", "cfg", cfg));
      if (cfg == null) begin
         `uvm_fatal("CFG", "Configuration object is null")
      end
      
      void'(uvm_config_db#(uvma_my_protocol_cntxt_c)::get(this, "", "cntxt", cntxt));
      if (cntxt == null) begin
         `uvm_fatal("CNTXT", "Context object is null")
      end
   endfunction
   
   /**
    * 连接阶段
    */
   virtual function void connect_phase(uvm_phase phase);
      super.connect_phase(phase);
      
      vif = cntxt.vif;
      if (vif == null) begin
         `uvm_fatal("VIF", "Virtual interface is null")
      end
   endfunction
   
   /**
    * 运行阶段
    */
   virtual task run_phase(uvm_phase phase);
      
      // 等待复位完成
      wait_for_reset_release();
      
      // 并行启动监控任务
      fork
         monitor_transactions();   // 主监控循环
         monitor_reset();         // 复位监控
         monitor_protocol_violations(); // 协议违规检查
      join_none
      
   endtask
   
   /**
    * 等待复位释放
    */
   virtual task wait_for_reset_release();
      wait(vif.rst_n === 1'b1);
      repeat(2) @(vif.mon_cb);
      monitoring_enabled = 1;
      `uvm_info("MON", "Reset released, starting monitoring", UVM_MEDIUM)
   endtask
   
   /**
    * 主监控循环
    */
   virtual task monitor_transactions();
      
      forever begin
         uvma_my_protocol_mon_trn_c trn;
         
         // 等待事务开始
         wait_for_transaction_start();
         
         // 创建监控事务
         trn = uvma_my_protocol_mon_trn_c::type_id::create("mon_trn");
         trn.start_time = $realtime;
         
         // 监控事务
         monitor_transaction(trn);
         
         // 完成事务
         trn.end_time = $realtime;
         
         // 发送到分析端口
         ap.write(trn);
         
         // 更新上下文统计
         cntxt.update_stats(trn);
         
         `uvm_info("MON", $sformatf("Monitored transaction: %s", trn.sprint()), UVM_HIGH)
      end
      
   endtask
   
   /**
    * 等待事务开始
    */
   virtual task wait_for_transaction_start();
      
      // 等待请求信号
      do begin
         @(vif.mon_cb);
      end while (!(vif.mon_cb.req === 1'b1 && monitoring_enabled));
      
   endtask
   
   /**
    * 监控单个事务
    */
   virtual task monitor_transaction(uvma_my_protocol_mon_trn_c trn);
      
      // 🔹 采样请求阶段
      sample_request_phase(trn);
      
      // 🔹 等待和采样授权
      wait_and_sample_grant(trn);
      
      // 🔹 等待和采样响应
      wait_and_sample_response(trn);
      
      // 🔹 计算性能指标
      calculate_performance_metrics(trn);
      
   endtask
   
   /**
    * 采样请求阶段
    */
   virtual task sample_request_phase(uvma_my_protocol_mon_trn_c trn);
      
      // 采样请求信号
      trn.address = vif.mon_cb.addr;
      trn.write_enable = vif.mon_cb.we;
      trn.byte_enable = vif.mon_cb.be;
      
      if (trn.write_enable) begin
         trn.access_type = MY_PROTOCOL_WRITE;
         trn.write_data = vif.mon_cb.wdata;
      end else begin
         trn.access_type = MY_PROTOCOL_READ;
      end
      
      `uvm_info("MON", $sformatf("Request phase: %s @ 0x%08x", 
                                trn.access_type.name(), trn.address), UVM_HIGH)
      
   endtask
   
   /**
    * 等待和采样授权
    */
   virtual task wait_and_sample_grant(uvma_my_protocol_mon_trn_c trn);
      int grant_wait_cycles = 0;
      
      // 等待授权信号
      while (vif.mon_cb.gnt !== 1'b1) begin
         @(vif.mon_cb);
         grant_wait_cycles++;
         
         // 检查超时
         if (grant_wait_cycles > cfg.req_timeout_cycles) begin
            `uvm_error("MON", $sformatf("Grant timeout after %0d cycles", grant_wait_cycles))
            trn.has_error = 1;
            return;
         end
      end
      
      trn.grant_latency = grant_wait_cycles;
      trn.grant_time = $realtime;
      
      `uvm_info("MON", $sformatf("Grant received after %0d cycles", grant_wait_cycles), UVM_HIGH)
      
   endtask
   
   /**
    * 等待和采样响应
    */
   virtual task wait_and_sample_response(uvma_my_protocol_mon_trn_c trn);
      int response_wait_cycles = 0;
      
      // 对于读操作，等待valid信号
      if (trn.access_type == MY_PROTOCOL_READ) begin
         while (vif.mon_cb.valid !== 1'b1) begin
            @(vif.mon_cb);
            response_wait_cycles++;
            
            if (response_wait_cycles > cfg.req_timeout_cycles) begin
               `uvm_error("MON", "Valid timeout")
               trn.has_error = 1;
               return;
            end
         end
         
         // 采样读取数据
         trn.read_data = vif.mon_cb.rdata;
      end else begin
         // 对于写操作，等待ready信号
         while (vif.mon_cb.ready !== 1'b1) begin
            @(vif.mon_cb);
            response_wait_cycles++;
            
            if (response_wait_cycles > cfg.req_timeout_cycles) begin
               `uvm_error("MON", "Ready timeout")
               trn.has_error = 1;
               return;
            end
         end
      end
      
      trn.response_latency = response_wait_cycles;
      trn.success = !trn.has_error;
      
      `uvm_info("MON", $sformatf("Response received after %0d cycles", response_wait_cycles), UVM_HIGH)
      
   endtask
   
   /**
    * 计算性能指标
    */
   virtual task calculate_performance_metrics(uvma_my_protocol_mon_trn_c trn);
      
      trn.total_latency = trn.grant_latency + trn.response_latency;
      trn.execution_time = trn.end_time - trn.start_time;
      
      // 更新平均延迟
      if (cntxt.total_requests > 0) begin
         real total_lat = cntxt.avg_request_latency * (cntxt.total_requests - 1) + trn.total_latency;
         cntxt.avg_request_latency = total_lat / cntxt.total_requests;
      end else begin
         cntxt.avg_request_latency = trn.total_latency;
      end
      
   endtask
   
   /**
    * 协议违规监控
    */
   virtual task monitor_protocol_violations();
      
      forever begin
         @(vif.mon_cb);
         
         if (!monitoring_enabled) continue;
         
         // 检查基本协议违规
         check_basic_protocol_violations();
         
         // 检查时序违规  
         check_timing_violations();
         
         // 检查数据完整性
         check_data_integrity();
      end
      
   endtask
   
   /**
    * 检查基本协议违规
    */
   virtual function void check_basic_protocol_violations();
      
      // 检查：req信号保持时间
      if (vif.mon_cb.req && !vif.mon_cb.gnt) begin
         // req应该保持直到gnt
      end
      
      // 检查：地址对齐
      if (vif.mon_cb.req) begin
         case (vif.mon_cb.be)
            4'b1111: begin  // 字访问
               if (vif.mon_cb.addr[1:0] != 2'b00) begin
                  `uvm_error("MON", $sformatf("Word access misaligned: addr=0x%08x", vif.mon_cb.addr))
               end
            end
            4'b0011, 4'b1100: begin  // 半字访问
               if (vif.mon_cb.addr[0] != 1'b0) begin
                  `uvm_error("MON", $sformatf("Halfword access misaligned: addr=0x%08x", vif.mon_cb.addr))
               end
            end
         endcase
      end
      
   endfunction
   
   /**
    * 检查时序违规
    */
   virtual function void check_timing_violations();
      
      // 检查建立时间和保持时间
      // (在实际应用中，这里会有更复杂的时序检查)
      
   endfunction
   
   /**
    * 检查数据完整性
    */
   virtual function void check_data_integrity();
      
      // 检查X/Z值
      if (vif.mon_cb.req === 1'b1) begin
         if ($isunknown(vif.mon_cb.addr)) begin
            `uvm_error("MON", "Address contains X/Z values")
         end
         
         if (vif.mon_cb.we === 1'b1 && $isunknown(vif.mon_cb.wdata)) begin
            `uvm_error("MON", "Write data contains X/Z values")
         end
      end
      
   endfunction
   
   /**
    * 复位监控
    */
   virtual task monitor_reset();
      forever begin
         @(negedge vif.rst_n);
         `uvm_info("MON", "Reset asserted, stopping monitoring", UVM_MEDIUM)
         monitoring_enabled = 0;
         
         // 清空待处理事务
         pending_transactions.delete();
         
         // 重置上下文
         cntxt.reset();
         
         @(posedge vif.rst_n);
         repeat(2) @(vif.mon_cb);
         `uvm_info("MON", "Reset released, resuming monitoring", UVM_MEDIUM)
         monitoring_enabled = 1;
      end
   endtask

endclass : uvma_my_protocol_mon_c
```

Alex，我创建了非常详细的新Agent开发流程，包括接口定义、配置对象、上下文对象、序列项、驱动器和监控器的完整实现。

让我继续完成剩余的重要文档（监控事务类、序列器、Agent主类），然后继续其他文档的创建。由于文档内容非常详细，我会继续完善这个组件扩展开发指南。