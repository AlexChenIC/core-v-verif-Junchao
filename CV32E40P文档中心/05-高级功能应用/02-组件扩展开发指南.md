# CV32E40Pç»„ä»¶æ‰©å±•å¼€å‘æŒ‡å— ğŸ› ï¸

> **ç³»ç»ŸåŒ–çš„éªŒè¯ç»„ä»¶æ‰©å±•å’Œå®šåˆ¶æ–¹æ³•**  
> ä»æ–°Agentå¼€å‘åˆ°ç¬¬ä¸‰æ–¹IPé›†æˆçš„å®Œæ•´å®æˆ˜æŒ‡å—

---

## ğŸ“‹ æœ¬æŒ‡å—é€‚ç”¨åœºæ™¯

- ğŸ—ï¸ **æ–°åè®®æ”¯æŒ** - æ·»åŠ è‡ªå®šä¹‰æ€»çº¿åè®®çš„éªŒè¯æ”¯æŒ
- ğŸ”§ **åŠŸèƒ½æ‰©å±•** - ä¸ºç°æœ‰Agentæ·»åŠ æ–°åŠŸèƒ½å’Œç‰¹æ€§
- ğŸ¯ **ç¬¬ä¸‰æ–¹IPé›†æˆ** - é›†æˆå¤–éƒ¨IPçš„éªŒè¯ç¯å¢ƒ
- ğŸ“Š **è‡ªå®šä¹‰ç›‘æ§** - å¼€å‘ç‰¹å®šçš„ç›‘æ§å’Œåˆ†æç»„ä»¶
- ğŸ® **æµ‹è¯•å¢å¼º** - åˆ›å»ºä¸“ç”¨çš„æµ‹è¯•ç»„ä»¶å’Œåºåˆ—

---

## ğŸ—ï¸ Part 1: æ–°Agentå¼€å‘å®Œæ•´æµç¨‹

### ğŸ“ Agentå¼€å‘æ ‡å‡†ç›®å½•ç»“æ„

æŒ‰ç…§CV32E40Pé¡¹ç›®çº¦å®šåˆ›å»ºAgentç›®å½•ï¼š

```bash
# ğŸ”¹ åˆ›å»ºæ–°Agentç›®å½•ç»“æ„
AGENT_NAME="uvma_my_protocol"
BASE_DIR="lib/uvm_agents/$AGENT_NAME"

mkdir -p $BASE_DIR/{src/{comps,obj,seq},doc,examples}
mkdir -p $BASE_DIR/src/comps  # ç»„ä»¶å®ç°
mkdir -p $BASE_DIR/src/obj    # å¯¹è±¡å®šä¹‰  
mkdir -p $BASE_DIR/src/seq    # åºåˆ—åº“

echo "âœ… Agentç›®å½•ç»“æ„åˆ›å»ºå®Œæˆ: $BASE_DIR"
```

### ğŸ”§ Step 1: æ¥å£å®šä¹‰

åˆ›å»ºåè®®æ¥å£ `uvma_my_protocol_if.sv`:

```systemverilog
// lib/uvm_agents/uvma_my_protocol/src/uvma_my_protocol_if.sv

/**
 * è‡ªå®šä¹‰åè®®æ¥å£å®šä¹‰
 * éµå¾ªCV32E40Pé¡¹ç›®çš„æ¥å£è®¾è®¡æ¨¡å¼
 */
interface uvma_my_protocol_if (
   input logic clk,
   input logic rst_n
);
   
   // ğŸ”¹ åè®®ä¿¡å·å®šä¹‰
   logic         req;           // è¯·æ±‚ä¿¡å·
   logic         gnt;           // æˆæƒä¿¡å·
   logic [31:0]  addr;          // åœ°å€ä¿¡å·
   logic [31:0]  wdata;         // å†™æ•°æ®
   logic [31:0]  rdata;         // è¯»æ•°æ®
   logic         we;            // å†™ä½¿èƒ½
   logic [3:0]   be;            // å­—èŠ‚ä½¿èƒ½
   logic         valid;         // æ•°æ®æœ‰æ•ˆ
   logic         ready;         // å‡†å¤‡å°±ç»ª
   
   // ğŸ”¹ æ—¶é’ŸåŸŸå®šä¹‰ (éµå¾ªé¡¹ç›®çº¦å®š)
   clocking mst_cb @(posedge clk);
      default input #1step output #1step;
      output req, addr, wdata, we, be;
      input  gnt, rdata, valid, ready;
   endclocking
   
   clocking slv_cb @(posedge clk);
      default input #1step output #1step;
      input  req, addr, wdata, we, be;
      output gnt, rdata, valid, ready;
   endclocking
   
   clocking mon_cb @(posedge clk);
      default input #1step;
      input req, gnt, addr, wdata, rdata, we, be, valid, ready;
   endclocking
   
   // ğŸ”¹ æ¨¡å—ç«¯å£å®šä¹‰
   modport mst_mp (clocking mst_cb, input clk, rst_n);
   modport slv_mp (clocking slv_cb, input clk, rst_n);  
   modport mon_mp (clocking mon_cb, input clk, rst_n);
   
   // ğŸ”¹ åè®®æ–­è¨€ (ç¡®ä¿æ—¶åºæ­£ç¡®æ€§)
   property req_gnt_handshake;
      @(posedge clk) disable iff (!rst_n)
      req |-> ##[1:10] gnt;
   endproperty
   
   property valid_after_gnt;
      @(posedge clk) disable iff (!rst_n)
      (req && gnt) |-> ##[1:5] valid;
   endproperty
   
   assert property (req_gnt_handshake) 
      else `uvm_error("MY_PROTOCOL_IF", "Request/Grant handshake violation");
   
   assert property (valid_after_gnt)
      else `uvm_error("MY_PROTOCOL_IF", "Valid signal timing violation");
   
   // ğŸ”¹ è¦†ç›–ç‡é‡‡æ ·ç‚¹
   covergroup protocol_cg @(posedge clk);
      REQ_GNT: coverpoint {req, gnt} {
         bins idle        = {2'b00};
         bins requesting  = {2'b10};
         bins granted     = {2'b11};
      }
      
      ADDR_RANGE: coverpoint addr {
         bins low_addr  = {[32'h0000_0000:32'h3FFF_FFFF]};
         bins mid_addr  = {[32'h4000_0000:32'h7FFF_FFFF]};
         bins high_addr = {[32'h8000_0000:32'hFFFF_FFFF]};
      }
      
      ACCESS_TYPE: coverpoint we;
      
      // äº¤å‰è¦†ç›–ç‡
      ADDR_ACCESS_CROSS: cross ADDR_RANGE, ACCESS_TYPE;
   endgroup
   
   initial begin
      protocol_cg cg = new();
   end

endinterface : uvma_my_protocol_if
```

### ğŸ¯ Step 2: é…ç½®å¯¹è±¡

åˆ›å»ºé…ç½®ç±» `uvma_my_protocol_cfg.sv`:

```systemverilog
// lib/uvm_agents/uvma_my_protocol/src/obj/uvma_my_protocol_cfg.sv

/**
 * è‡ªå®šä¹‰åè®®Agenté…ç½®ç±»
 * éµå¾ªCV32E40Pé¡¹ç›®çš„é…ç½®æ¨¡å¼
 */
class uvma_my_protocol_cfg_c extends uvm_object;
   
   // ğŸ”¹ åŸºç¡€é…ç½®é¡¹
   rand bit                      enabled;              // Agentä½¿èƒ½
   rand uvm_active_passive_enum  is_active;            // ä¸»åŠ¨/è¢«åŠ¨æ¨¡å¼
   rand bit                      cov_model_enabled;    // è¦†ç›–ç‡æ¨¡å‹ä½¿èƒ½
   rand bit                      trn_log_enabled;      // äº‹åŠ¡æ—¥å¿—ä½¿èƒ½
   
   // ğŸ”¹ åè®®ç‰¹å®šé…ç½®
   rand int unsigned             max_outstanding_req;  // æœ€å¤§æœªå®Œæˆè¯·æ±‚æ•°
   rand int unsigned             req_timeout_cycles;   // è¯·æ±‚è¶…æ—¶å‘¨æœŸ
   rand bit                      enable_backpressure; // èƒŒå‹ä½¿èƒ½
   rand int unsigned             backpressure_chance;  // èƒŒå‹æ¦‚ç‡
   
   // ğŸ”¹ æ—¶åºé…ç½®
   rand int unsigned             req_to_gnt_delay_min; // æœ€å°æˆæƒå»¶è¿Ÿ
   rand int unsigned             req_to_gnt_delay_max; // æœ€å¤§æˆæƒå»¶è¿Ÿ
   rand int unsigned             gnt_to_valid_delay;   // æˆæƒåˆ°æœ‰æ•ˆå»¶è¿Ÿ
   
   // ğŸ”¹ åœ°å€æ˜ å°„é…ç½®
   rand bit [31:0]               addr_base;           // åŸºåœ°å€
   rand bit [31:0]               addr_mask;           // åœ°å€æ©ç 
   
   // ğŸ”¹ çº¦æŸå®šä¹‰
   constraint reasonable_values_c {
      max_outstanding_req inside {[1:16]};
      req_timeout_cycles inside {[100:10000]};
      backpressure_chance inside {[0:50]};
      req_to_gnt_delay_min <= req_to_gnt_delay_max;
      req_to_gnt_delay_max inside {[1:20]};
      gnt_to_valid_delay inside {[1:10]};
   }
   
   constraint addr_alignment_c {
      addr_base[1:0] == 2'b00;  // å­—å¯¹é½
   }
   
   // ğŸ”¹ UVMæ ‡å‡†å®
   `uvm_object_utils_begin(uvma_my_protocol_cfg_c)
      `uvm_field_int (enabled             , UVM_DEFAULT)
      `uvm_field_enum(uvm_active_passive_enum, is_active, UVM_DEFAULT)
      `uvm_field_int (cov_model_enabled   , UVM_DEFAULT)
      `uvm_field_int (trn_log_enabled     , UVM_DEFAULT)
      `uvm_field_int (max_outstanding_req , UVM_DEFAULT)
      `uvm_field_int (req_timeout_cycles  , UVM_DEFAULT)
      `uvm_field_int (enable_backpressure , UVM_DEFAULT)
      `uvm_field_int (backpressure_chance , UVM_DEFAULT)
      `uvm_field_int (req_to_gnt_delay_min, UVM_DEFAULT)
      `uvm_field_int (req_to_gnt_delay_max, UVM_DEFAULT)
      `uvm_field_int (gnt_to_valid_delay  , UVM_DEFAULT)
      `uvm_field_int (addr_base           , UVM_DEFAULT)
      `uvm_field_int (addr_mask           , UVM_DEFAULT)
   `uvm_object_utils_end
   
   /**
    * æ„é€ å‡½æ•°
    */
   function new(string name = "uvma_my_protocol_cfg");
      super.new(name);
   endfunction
   
   /**
    * é…ç½®éªŒè¯å‡½æ•°
    */
   virtual function bit is_valid();
      if (req_to_gnt_delay_min > req_to_gnt_delay_max) begin
         `uvm_error("CFG", "Invalid delay configuration")
         return 0;
      end
      
      if (max_outstanding_req == 0) begin
         `uvm_error("CFG", "Outstanding requests must be > 0")
         return 0;
      end
      
      return 1;
   endfunction
   
   /**
    * é…ç½®è°ƒè¯•æ‰“å°
    */
   virtual function void do_print(uvm_printer printer);
      super.do_print(printer);
      printer.print_string("protocol_config", "MY_PROTOCOL");
   endfunction

endclass : uvma_my_protocol_cfg_c
```

### ğŸ“Š Step 3: ä¸Šä¸‹æ–‡å¯¹è±¡

åˆ›å»ºä¸Šä¸‹æ–‡ç±» `uvma_my_protocol_cntxt.sv`:

```systemverilog
// lib/uvm_agents/uvma_my_protocol/src/obj/uvma_my_protocol_cntxt.sv

/**
 * è‡ªå®šä¹‰åè®®Agentä¸Šä¸‹æ–‡ç±»
 * å­˜å‚¨è¿è¡Œæ—¶çŠ¶æ€å’Œå…±äº«æ•°æ®
 */
class uvma_my_protocol_cntxt_c extends uvm_object;
   
   // ğŸ”¹ è™šæ‹Ÿæ¥å£å¥æŸ„
   virtual uvma_my_protocol_if  vif;
   
   // ğŸ”¹ è¿è¡Œæ—¶çŠ¶æ€
   bit                          agent_enabled;
   bit                          reset_state;
   int unsigned                 outstanding_req_count;
   
   // ğŸ”¹ äº‹åŠ¡å†å²è®°å½•
   uvma_my_protocol_mon_trn_c   mon_trns[$];        // ç›‘æ§äº‹åŠ¡é˜Ÿåˆ—
   uvma_my_protocol_seq_item_c  seq_items[$];       // åºåˆ—é¡¹é˜Ÿåˆ—
   
   // ğŸ”¹ ç»Ÿè®¡ä¿¡æ¯
   int unsigned                 total_requests;
   int unsigned                 total_responses;
   int unsigned                 error_count;
   realtime                     last_activity_time;
   
   // ğŸ”¹ æ€§èƒ½æŒ‡æ ‡
   realtime                     avg_request_latency;
   int unsigned                 max_outstanding_reached;
   
   // ğŸ”¹ åŒæ­¥å¯¹è±¡
   semaphore                    req_sem;            // è¯·æ±‚ä¿¡å·é‡
   event                        reset_done;         // å¤ä½å®Œæˆäº‹ä»¶
   
   `uvm_object_utils_begin(uvma_my_protocol_cntxt_c)
      `uvm_field_int(agent_enabled        , UVM_DEFAULT)
      `uvm_field_int(reset_state          , UVM_DEFAULT)
      `uvm_field_int(outstanding_req_count, UVM_DEFAULT)
      `uvm_field_int(total_requests       , UVM_DEFAULT)
      `uvm_field_int(total_responses      , UVM_DEFAULT)
      `uvm_field_int(error_count          , UVM_DEFAULT)
   `uvm_object_utils_end
   
   /**
    * æ„é€ å‡½æ•°
    */
   function new(string name = "uvma_my_protocol_cntxt");
      super.new(name);
      req_sem = new(16);  // æœ€å¤§16ä¸ªå¹¶å‘è¯·æ±‚
   endfunction
   
   /**
    * å¤ä½ä¸Šä¸‹æ–‡çŠ¶æ€
    */
   virtual function void reset();
      outstanding_req_count = 0;
      total_requests = 0;
      total_responses = 0;
      error_count = 0;
      reset_state = 1;
      
      // æ¸…ç©ºå†å²è®°å½•
      mon_trns.delete();
      seq_items.delete();
      
      // é‡ç½®åŒæ­¥å¯¹è±¡
      req_sem = new(16);
      
      `uvm_info("CNTXT", "Context reset completed", UVM_MEDIUM)
   endfunction
   
   /**
    * æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    */
   virtual function void update_stats(uvma_my_protocol_mon_trn_c trn);
      if (trn.is_request()) begin
         total_requests++;
         outstanding_req_count++;
         if (outstanding_req_count > max_outstanding_reached) begin
            max_outstanding_reached = outstanding_req_count;
         end
      end else if (trn.is_response()) begin
         total_responses++;
         if (outstanding_req_count > 0) begin
            outstanding_req_count--;
         end
      end
      
      last_activity_time = $realtime;
   endfunction
   
   /**
    * æ£€æŸ¥å¥åº·çŠ¶æ€
    */
   virtual function bit is_healthy();
      // æ£€æŸ¥æ˜¯å¦æœ‰è¶…æ—¶çš„è¯·æ±‚
      if (outstanding_req_count > 0 && 
          ($realtime - last_activity_time) > 100000) begin  // 100usè¶…æ—¶
         `uvm_warning("CNTXT", "Potential timeout detected")
         return 0;
      end
      
      // æ£€æŸ¥é”™è¯¯ç‡
      if (total_requests > 0 && 
          (error_count * 100 / total_requests) > 5) begin  // 5%é”™è¯¯ç‡é˜ˆå€¼
         `uvm_warning("CNTXT", "High error rate detected")
         return 0;
      end
      
      return 1;
   endfunction
   
   /**
    * ç”ŸæˆçŠ¶æ€æŠ¥å‘Š
    */
   virtual function string get_status_report();
      string report;
      report = $sformatf("Protocol Status Report:\n");
      report = {report, $sformatf("  Total Requests: %0d\n", total_requests)};
      report = {report, $sformatf("  Total Responses: %0d\n", total_responses)};
      report = {report, $sformatf("  Outstanding: %0d\n", outstanding_req_count)};
      report = {report, $sformatf("  Error Count: %0d\n", error_count)};
      report = {report, $sformatf("  Max Outstanding: %0d\n", max_outstanding_reached)};
      return report;
   endfunction

endclass : uvma_my_protocol_cntxt_c
```

### ğŸ­ Step 4: åºåˆ—é¡¹å®šä¹‰

åˆ›å»ºåºåˆ—é¡¹ `uvma_my_protocol_seq_item.sv`:

```systemverilog
// lib/uvm_agents/uvma_my_protocol/src/obj/uvma_my_protocol_seq_item.sv

/**
 * è‡ªå®šä¹‰åè®®åºåˆ—é¡¹ç±»
 * å®šä¹‰é©±åŠ¨å™¨å’Œåºåˆ—å™¨ä¹‹é—´ä¼ é€’çš„æ•°æ®ç»“æ„
 */
class uvma_my_protocol_seq_item_c extends uvm_sequence_item;
   
   // ğŸ”¹ äº‹åŠ¡ç±»å‹æšä¸¾
   typedef enum {
      MY_PROTOCOL_READ,
      MY_PROTOCOL_WRITE,
      MY_PROTOCOL_BURST_READ,
      MY_PROTOCOL_BURST_WRITE
   } my_protocol_access_type_e;
   
   // ğŸ”¹ æ ¸å¿ƒäº‹åŠ¡å­—æ®µ
   rand my_protocol_access_type_e  access_type;     // è®¿é—®ç±»å‹
   rand bit [31:0]                 address;         // åœ°å€
   rand bit [31:0]                 data;            // æ•°æ®
   rand bit [3:0]                  byte_enable;     // å­—èŠ‚ä½¿èƒ½
   rand int unsigned               burst_length;    // çªå‘é•¿åº¦
   
   // ğŸ”¹ æ§åˆ¶å­—æ®µ
   rand int unsigned               req_delay;       // è¯·æ±‚å‰å»¶è¿Ÿ
   rand int unsigned               ack_delay;       // å“åº”å»¶è¿Ÿ
   rand bit                        insert_error;    // é”™è¯¯æ³¨å…¥
   
   // ğŸ”¹ å“åº”å­—æ®µ (ç”±é©±åŠ¨å™¨å¡«å……)
   bit                             success;         // æ“ä½œæˆåŠŸæ ‡å¿—
   bit [31:0]                      rdata;           // è¯»å–æ•°æ®
   realtime                        start_time;      // å¼€å§‹æ—¶é—´
   realtime                        end_time;        // ç»“æŸæ—¶é—´
   
   // ğŸ”¹ çº¦æŸå®šä¹‰
   constraint address_alignment_c {
      // æ ¹æ®è®¿é—®ç±»å‹çº¦æŸåœ°å€å¯¹é½
      if (access_type inside {MY_PROTOCOL_READ, MY_PROTOCOL_WRITE}) {
         if (byte_enable == 4'b1111) address[1:0] == 2'b00;      // å­—è®¿é—®
         else if (byte_enable inside {4'b0011, 4'b1100}) address[0] == 1'b0;  // åŠå­—è®¿é—®
      }
   }
   
   constraint burst_length_c {
      if (access_type inside {MY_PROTOCOL_BURST_READ, MY_PROTOCOL_BURST_WRITE}) {
         burst_length inside {[2:16]};
      } else {
         burst_length == 1;
      }
   }
   
   constraint reasonable_delays_c {
      req_delay inside {[0:20]};
      ack_delay inside {[0:10]};
      insert_error dist {0 := 95, 1 := 5};  // 5%é”™è¯¯æ³¨å…¥æ¦‚ç‡
   }
   
   // ğŸ”¹ UVMæ ‡å‡†å®
   `uvm_object_utils_begin(uvma_my_protocol_seq_item_c)
      `uvm_field_enum(my_protocol_access_type_e, access_type, UVM_DEFAULT)
      `uvm_field_int (address      , UVM_DEFAULT)
      `uvm_field_int (data         , UVM_DEFAULT)
      `uvm_field_int (byte_enable  , UVM_DEFAULT)
      `uvm_field_int (burst_length , UVM_DEFAULT)
      `uvm_field_int (req_delay    , UVM_DEFAULT)
      `uvm_field_int (ack_delay    , UVM_DEFAULT)
      `uvm_field_int (insert_error , UVM_DEFAULT)
      `uvm_field_int (success      , UVM_DEFAULT)
      `uvm_field_int (rdata        , UVM_DEFAULT)
   `uvm_object_utils_end
   
   /**
    * æ„é€ å‡½æ•°
    */
   function new(string name = "uvma_my_protocol_seq_item");
      super.new(name);
   endfunction
   
   /**
    * äº‹åŠ¡ç±»å‹æ£€æŸ¥å‡½æ•°
    */
   virtual function bit is_read();
      return (access_type inside {MY_PROTOCOL_READ, MY_PROTOCOL_BURST_READ});
   endfunction
   
   virtual function bit is_write();
      return (access_type inside {MY_PROTOCOL_WRITE, MY_PROTOCOL_BURST_WRITE});
   endfunction
   
   virtual function bit is_burst();
      return (access_type inside {MY_PROTOCOL_BURST_READ, MY_PROTOCOL_BURST_WRITE});
   endfunction
   
   /**
    * è®¡ç®—æ‰§è¡Œæ—¶é—´
    */
   virtual function realtime get_execution_time();
      return end_time - start_time;
   endfunction
   
   /**
    * è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°
    */
   virtual function bit do_compare(uvm_object rhs, uvm_comparer comparer);
      uvma_my_protocol_seq_item_c rhs_item;
      
      if (!$cast(rhs_item, rhs)) begin
         return 0;
      end
      
      return (access_type == rhs_item.access_type &&
              address == rhs_item.address &&
              data == rhs_item.data &&
              byte_enable == rhs_item.byte_enable);
   endfunction
   
   /**
    * è‡ªå®šä¹‰æ‰“å°å‡½æ•°
    */
   virtual function void do_print(uvm_printer printer);
      super.do_print(printer);
      printer.print_string("transaction_type", access_type.name());
      printer.print_string("execution_time", 
                          $sformatf("%.2f ns", get_execution_time()));
   endfunction

endclass : uvma_my_protocol_seq_item_c
```

### ğŸš— Step 5: é©±åŠ¨å™¨å®ç°

åˆ›å»ºé©±åŠ¨å™¨ `uvma_my_protocol_drv.sv`:

```systemverilog
// lib/uvm_agents/uvma_my_protocol/src/comps/uvma_my_protocol_drv.sv

/**
 * è‡ªå®šä¹‰åè®®é©±åŠ¨å™¨
 * å°†åºåˆ—é¡¹è½¬æ¢ä¸ºå®é™…çš„æ¥å£ä¿¡å·
 */
class uvma_my_protocol_drv_c extends uvm_driver#(uvma_my_protocol_seq_item_c);
   
   // ğŸ”¹ ç»„ä»¶å¥æŸ„
   virtual uvma_my_protocol_if      vif;
   uvma_my_protocol_cfg_c           cfg;
   uvma_my_protocol_cntxt_c         cntxt;
   
   // ğŸ”¹ åˆ†æç«¯å£
   uvm_analysis_port#(uvma_my_protocol_seq_item_c)  ap;
   
   // ğŸ”¹ å†…éƒ¨çŠ¶æ€
   bit                              driving_enabled;
   uvma_my_protocol_seq_item_c      req_queue[$];
   
   `uvm_component_utils_begin(uvma_my_protocol_drv_c)
      `uvm_field_object(cfg  , UVM_DEFAULT)
      `uvm_field_object(cntxt, UVM_DEFAULT)
   `uvm_component_utils_end
   
   /**
    * æ„é€ å‡½æ•°
    */
   function new(string name = "uvma_my_protocol_drv", uvm_component parent = null);
      super.new(name, parent);
      ap = new("ap", this);
   endfunction
   
   /**
    * æ„å»ºé˜¶æ®µ
    */
   virtual function void build_phase(uvm_phase phase);
      super.build_phase(phase);
      
      // è·å–é…ç½®å’Œä¸Šä¸‹æ–‡
      void'(uvm_config_db#(uvma_my_protocol_cfg_c)::get(this, "", "cfg", cfg));
      if (cfg == null) begin
         `uvm_fatal("CFG", "Configuration object is null")
      end
      
      void'(uvm_config_db#(uvma_my_protocol_cntxt_c)::get(this, "", "cntxt", cntxt));
      if (cntxt == null) begin
         `uvm_fatal("CNTXT", "Context object is null")
      end
   endfunction
   
   /**
    * è¿æ¥é˜¶æ®µ
    */
   virtual function void connect_phase(uvm_phase phase);
      super.connect_phase(phase);
      
      // è·å–è™šæ‹Ÿæ¥å£
      vif = cntxt.vif;
      if (vif == null) begin
         `uvm_fatal("VIF", "Virtual interface is null")
      end
   endfunction
   
   /**
    * è¿è¡Œé˜¶æ®µ
    */
   virtual task run_phase(uvm_phase phase);
      
      // åˆå§‹åŒ–æ¥å£
      initialize_interface();
      
      // ç­‰å¾…å¤ä½å®Œæˆ
      wait_for_reset_release();
      
      // å¹¶è¡Œå¯åŠ¨é©±åŠ¨ä»»åŠ¡
      fork
         get_and_drive_items();    // ä¸»é©±åŠ¨å¾ªç¯
         monitor_reset();          // å¤ä½ç›‘æ§
      join_none
      
   endtask
   
   /**
    * åˆå§‹åŒ–æ¥å£ä¿¡å·
    */
   virtual task initialize_interface();
      `uvm_info("DRV", "Initializing interface signals", UVM_MEDIUM)
      
      vif.req   <= 1'b0;
      vif.addr  <= 32'h0;
      vif.wdata <= 32'h0;
      vif.we    <= 1'b0;
      vif.be    <= 4'h0;
      
   endtask
   
   /**
    * ç­‰å¾…å¤ä½é‡Šæ”¾
    */
   virtual task wait_for_reset_release();
      `uvm_info("DRV", "Waiting for reset release", UVM_MEDIUM)
      wait(vif.rst_n === 1'b1);
      repeat(5) @(vif.mst_cb);  // ç¨³å®šç­‰å¾…
      `uvm_info("DRV", "Reset released, starting to drive", UVM_MEDIUM)
   endtask
   
   /**
    * ä¸»é©±åŠ¨å¾ªç¯
    */
   virtual task get_and_drive_items();
      uvma_my_protocol_seq_item_c req_item;
      
      forever begin
         // è·å–ä¸‹ä¸€ä¸ªåºåˆ—é¡¹
         seq_item_port.get_next_item(req_item);
         
         // è®°å½•å¼€å§‹æ—¶é—´
         req_item.start_time = $realtime;
         
         // æ‰§è¡Œé©±åŠ¨
         drive_item(req_item);
         
         // è®°å½•ç»“æŸæ—¶é—´
         req_item.end_time = $realtime;
         
         // å‘é€åˆ°åˆ†æç«¯å£
         ap.write(req_item);
         
         // é€šçŸ¥åºåˆ—å™¨å®Œæˆ
         seq_item_port.item_done();
         
         `uvm_info("DRV", $sformatf("Completed item: %s", req_item.sprint()), UVM_HIGH)
      end
   endtask
   
   /**
    * é©±åŠ¨å•ä¸ªåºåˆ—é¡¹
    */
   virtual task drive_item(uvma_my_protocol_seq_item_c item);
      
      `uvm_info("DRV", $sformatf("Driving item: %s @ 0x%08x", 
                                item.access_type.name(), item.address), UVM_MEDIUM)
      
      // è¯·æ±‚å‰å»¶è¿Ÿ
      if (item.req_delay > 0) begin
         repeat(item.req_delay) @(vif.mst_cb);
      end
      
      // æ ¹æ®è®¿é—®ç±»å‹æ‰§è¡Œç›¸åº”æ“ä½œ
      case (item.access_type)
         MY_PROTOCOL_READ:        drive_read(item);
         MY_PROTOCOL_WRITE:       drive_write(item);
         MY_PROTOCOL_BURST_READ:  drive_burst_read(item);
         MY_PROTOCOL_BURST_WRITE: drive_burst_write(item);
         default: `uvm_error("DRV", $sformatf("Unsupported access type: %s", 
                                             item.access_type.name()));
      endcase
      
   endtask
   
   /**
    * é©±åŠ¨è¯»æ“ä½œ
    */
   virtual task drive_read(uvma_my_protocol_seq_item_c item);
      
      // ğŸ”¹ ç¬¬1æ­¥ï¼šå‘èµ·è¯»è¯·æ±‚
      vif.mst_cb.req   <= 1'b1;
      vif.mst_cb.addr  <= item.address;
      vif.mst_cb.we    <= 1'b0;
      vif.mst_cb.be    <= item.byte_enable;
      vif.mst_cb.wdata <= 32'h0;
      
      // ğŸ”¹ ç¬¬2æ­¥ï¼šç­‰å¾…æˆæƒ
      do begin
         @(vif.mst_cb);
      end while (vif.mst_cb.gnt !== 1'b1);
      
      // ğŸ”¹ ç¬¬3æ­¥ï¼šæ¸…é™¤è¯·æ±‚
      vif.mst_cb.req <= 1'b0;
      
      // ğŸ”¹ ç¬¬4æ­¥ï¼šç­‰å¾…æ•°æ®æœ‰æ•ˆ
      do begin
         @(vif.mst_cb);
      end while (vif.mst_cb.valid !== 1'b1);
      
      // ğŸ”¹ ç¬¬5æ­¥ï¼šé‡‡æ ·è¯»å–æ•°æ®
      item.rdata = vif.mst_cb.rdata;
      item.success = 1'b1;
      
      `uvm_info("DRV", $sformatf("Read completed: addr=0x%08x, data=0x%08x", 
                                item.address, item.rdata), UVM_HIGH)
      
   endtask
   
   /**
    * é©±åŠ¨å†™æ“ä½œ
    */
   virtual task drive_write(uvma_my_protocol_seq_item_c item);
      
      // ğŸ”¹ ç¬¬1æ­¥ï¼šå‘èµ·å†™è¯·æ±‚
      vif.mst_cb.req   <= 1'b1;
      vif.mst_cb.addr  <= item.address;
      vif.mst_cb.we    <= 1'b1;
      vif.mst_cb.be    <= item.byte_enable;
      vif.mst_cb.wdata <= item.data;
      
      // ğŸ”¹ ç¬¬2æ­¥ï¼šç­‰å¾…æˆæƒ
      do begin
         @(vif.mst_cb);
      end while (vif.mst_cb.gnt !== 1'b1);
      
      // ğŸ”¹ ç¬¬3æ­¥ï¼šæ¸…é™¤è¯·æ±‚
      vif.mst_cb.req <= 1'b0;
      
      // ğŸ”¹ ç¬¬4æ­¥ï¼šç­‰å¾…å†™å®Œæˆç¡®è®¤
      if (vif.mst_cb.ready === 1'b1) begin
         item.success = 1'b1;
      end else begin
         // ç­‰å¾…readyä¿¡å·
         do begin
            @(vif.mst_cb);
         end while (vif.mst_cb.ready !== 1'b1);
         item.success = 1'b1;
      end
      
      `uvm_info("DRV", $sformatf("Write completed: addr=0x%08x, data=0x%08x", 
                                item.address, item.data), UVM_HIGH)
      
   endtask
   
   /**
    * é©±åŠ¨çªå‘è¯»æ“ä½œ
    */
   virtual task drive_burst_read(uvma_my_protocol_seq_item_c item);
      bit [31:0] current_addr;
      bit [31:0] read_data[$];
      
      current_addr = item.address;
      
      for (int i = 0; i < item.burst_length; i++) begin
         
         // å‘èµ·è¯»è¯·æ±‚
         vif.mst_cb.req  <= 1'b1;
         vif.mst_cb.addr <= current_addr;
         vif.mst_cb.we   <= 1'b0;
         vif.mst_cb.be   <= item.byte_enable;
         
         // ç­‰å¾…æˆæƒ
         do begin
            @(vif.mst_cb);
         end while (vif.mst_cb.gnt !== 1'b1);
         
         // æ¸…é™¤è¯·æ±‚
         vif.mst_cb.req <= 1'b0;
         
         // ç­‰å¾…æ•°æ®
         do begin
            @(vif.mst_cb);
         end while (vif.mst_cb.valid !== 1'b1);
         
         // é‡‡æ ·æ•°æ®
         read_data.push_back(vif.mst_cb.rdata);
         
         // é€’å¢åœ°å€
         current_addr += 4;
      end
      
      // è®°å½•ç¬¬ä¸€ä¸ªæ•°æ®åˆ°itemä¸­
      if (read_data.size() > 0) begin
         item.rdata = read_data[0];
      end
      
      item.success = 1'b1;
      
      `uvm_info("DRV", $sformatf("Burst read completed: %0d transfers", 
                                item.burst_length), UVM_MEDIUM)
      
   endtask
   
   /**
    * é©±åŠ¨çªå‘å†™æ“ä½œ
    */
   virtual task drive_burst_write(uvma_my_protocol_seq_item_c item);
      bit [31:0] current_addr;
      bit [31:0] write_data;
      
      current_addr = item.address;
      write_data = item.data;
      
      for (int i = 0; i < item.burst_length; i++) begin
         
         // å‘èµ·å†™è¯·æ±‚
         vif.mst_cb.req   <= 1'b1;
         vif.mst_cb.addr  <= current_addr;
         vif.mst_cb.we    <= 1'b1;
         vif.mst_cb.be    <= item.byte_enable;
         vif.mst_cb.wdata <= write_data;
         
         // ç­‰å¾…æˆæƒ
         do begin
            @(vif.mst_cb);
         end while (vif.mst_cb.gnt !== 1'b1);
         
         // æ¸…é™¤è¯·æ±‚
         vif.mst_cb.req <= 1'b0;
         
         // ç­‰å¾…å†™å®Œæˆ
         do begin
            @(vif.mst_cb);
         end while (vif.mst_cb.ready !== 1'b1);
         
         // é€’å¢åœ°å€å’Œæ•°æ®
         current_addr += 4;
         write_data += 1;  // ç®€å•çš„æ•°æ®æ¨¡å¼
      end
      
      item.success = 1'b1;
      
      `uvm_info("DRV", $sformatf("Burst write completed: %0d transfers", 
                                item.burst_length), UVM_MEDIUM)
      
   endtask
   
   /**
    * å¤ä½ç›‘æ§ä»»åŠ¡
    */
   virtual task monitor_reset();
      forever begin
         @(negedge vif.rst_n);
         `uvm_info("DRV", "Reset asserted, stopping driving", UVM_MEDIUM)
         driving_enabled = 0;
         
         // åˆå§‹åŒ–æ¥å£
         initialize_interface();
         
         // ç­‰å¾…å¤ä½é‡Šæ”¾
         @(posedge vif.rst_n);
         `uvm_info("DRV", "Reset released, resuming driving", UVM_MEDIUM)
         driving_enabled = 1;
      end
   endtask

endclass : uvma_my_protocol_drv_c
```

### ğŸ‘ï¸ Step 6: ç›‘æ§å™¨å®ç°

åˆ›å»ºç›‘æ§å™¨ `uvma_my_protocol_mon.sv`:

```systemverilog
// lib/uvm_agents/uvma_my_protocol/src/comps/uvma_my_protocol_mon.sv

/**
 * è‡ªå®šä¹‰åè®®ç›‘æ§å™¨
 * è¢«åŠ¨è§‚å¯Ÿæ¥å£æ´»åŠ¨å¹¶ç”Ÿæˆäº‹åŠ¡
 */
class uvma_my_protocol_mon_c extends uvm_monitor;
   
   // ğŸ”¹ ç»„ä»¶å¥æŸ„
   virtual uvma_my_protocol_if      vif;
   uvma_my_protocol_cfg_c           cfg;
   uvma_my_protocol_cntxt_c         cntxt;
   
   // ğŸ”¹ åˆ†æç«¯å£
   uvm_analysis_port#(uvma_my_protocol_mon_trn_c)  ap;
   
   // ğŸ”¹ å†…éƒ¨çŠ¶æ€
   bit                              monitoring_enabled;
   uvma_my_protocol_mon_trn_c       pending_transactions[$];
   
   `uvm_component_utils_begin(uvma_my_protocol_mon_c)
      `uvm_field_object(cfg  , UVM_DEFAULT)
      `uvm_field_object(cntxt, UVM_DEFAULT)
   `uvm_component_utils_end
   
   /**
    * æ„é€ å‡½æ•°
    */
   function new(string name = "uvma_my_protocol_mon", uvm_component parent = null);
      super.new(name, parent);
      ap = new("ap", this);
   endfunction
   
   /**
    * æ„å»ºé˜¶æ®µ
    */
   virtual function void build_phase(uvm_phase phase);
      super.build_phase(phase);
      
      void'(uvm_config_db#(uvma_my_protocol_cfg_c)::get(this, "", "cfg", cfg));
      if (cfg == null) begin
         `uvm_fatal("CFG", "Configuration object is null")
      end
      
      void'(uvm_config_db#(uvma_my_protocol_cntxt_c)::get(this, "", "cntxt", cntxt));
      if (cntxt == null) begin
         `uvm_fatal("CNTXT", "Context object is null")
      end
   endfunction
   
   /**
    * è¿æ¥é˜¶æ®µ
    */
   virtual function void connect_phase(uvm_phase phase);
      super.connect_phase(phase);
      
      vif = cntxt.vif;
      if (vif == null) begin
         `uvm_fatal("VIF", "Virtual interface is null")
      end
   endfunction
   
   /**
    * è¿è¡Œé˜¶æ®µ
    */
   virtual task run_phase(uvm_phase phase);
      
      // ç­‰å¾…å¤ä½å®Œæˆ
      wait_for_reset_release();
      
      // å¹¶è¡Œå¯åŠ¨ç›‘æ§ä»»åŠ¡
      fork
         monitor_transactions();   // ä¸»ç›‘æ§å¾ªç¯
         monitor_reset();         // å¤ä½ç›‘æ§
         monitor_protocol_violations(); // åè®®è¿è§„æ£€æŸ¥
      join_none
      
   endtask
   
   /**
    * ç­‰å¾…å¤ä½é‡Šæ”¾
    */
   virtual task wait_for_reset_release();
      wait(vif.rst_n === 1'b1);
      repeat(2) @(vif.mon_cb);
      monitoring_enabled = 1;
      `uvm_info("MON", "Reset released, starting monitoring", UVM_MEDIUM)
   endtask
   
   /**
    * ä¸»ç›‘æ§å¾ªç¯
    */
   virtual task monitor_transactions();
      
      forever begin
         uvma_my_protocol_mon_trn_c trn;
         
         // ç­‰å¾…äº‹åŠ¡å¼€å§‹
         wait_for_transaction_start();
         
         // åˆ›å»ºç›‘æ§äº‹åŠ¡
         trn = uvma_my_protocol_mon_trn_c::type_id::create("mon_trn");
         trn.start_time = $realtime;
         
         // ç›‘æ§äº‹åŠ¡
         monitor_transaction(trn);
         
         // å®Œæˆäº‹åŠ¡
         trn.end_time = $realtime;
         
         // å‘é€åˆ°åˆ†æç«¯å£
         ap.write(trn);
         
         // æ›´æ–°ä¸Šä¸‹æ–‡ç»Ÿè®¡
         cntxt.update_stats(trn);
         
         `uvm_info("MON", $sformatf("Monitored transaction: %s", trn.sprint()), UVM_HIGH)
      end
      
   endtask
   
   /**
    * ç­‰å¾…äº‹åŠ¡å¼€å§‹
    */
   virtual task wait_for_transaction_start();
      
      // ç­‰å¾…è¯·æ±‚ä¿¡å·
      do begin
         @(vif.mon_cb);
      end while (!(vif.mon_cb.req === 1'b1 && monitoring_enabled));
      
   endtask
   
   /**
    * ç›‘æ§å•ä¸ªäº‹åŠ¡
    */
   virtual task monitor_transaction(uvma_my_protocol_mon_trn_c trn);
      
      // ğŸ”¹ é‡‡æ ·è¯·æ±‚é˜¶æ®µ
      sample_request_phase(trn);
      
      // ğŸ”¹ ç­‰å¾…å’Œé‡‡æ ·æˆæƒ
      wait_and_sample_grant(trn);
      
      // ğŸ”¹ ç­‰å¾…å’Œé‡‡æ ·å“åº”
      wait_and_sample_response(trn);
      
      // ğŸ”¹ è®¡ç®—æ€§èƒ½æŒ‡æ ‡
      calculate_performance_metrics(trn);
      
   endtask
   
   /**
    * é‡‡æ ·è¯·æ±‚é˜¶æ®µ
    */
   virtual task sample_request_phase(uvma_my_protocol_mon_trn_c trn);
      
      // é‡‡æ ·è¯·æ±‚ä¿¡å·
      trn.address = vif.mon_cb.addr;
      trn.write_enable = vif.mon_cb.we;
      trn.byte_enable = vif.mon_cb.be;
      
      if (trn.write_enable) begin
         trn.access_type = MY_PROTOCOL_WRITE;
         trn.write_data = vif.mon_cb.wdata;
      end else begin
         trn.access_type = MY_PROTOCOL_READ;
      end
      
      `uvm_info("MON", $sformatf("Request phase: %s @ 0x%08x", 
                                trn.access_type.name(), trn.address), UVM_HIGH)
      
   endtask
   
   /**
    * ç­‰å¾…å’Œé‡‡æ ·æˆæƒ
    */
   virtual task wait_and_sample_grant(uvma_my_protocol_mon_trn_c trn);
      int grant_wait_cycles = 0;
      
      // ç­‰å¾…æˆæƒä¿¡å·
      while (vif.mon_cb.gnt !== 1'b1) begin
         @(vif.mon_cb);
         grant_wait_cycles++;
         
         // æ£€æŸ¥è¶…æ—¶
         if (grant_wait_cycles > cfg.req_timeout_cycles) begin
            `uvm_error("MON", $sformatf("Grant timeout after %0d cycles", grant_wait_cycles))
            trn.has_error = 1;
            return;
         end
      end
      
      trn.grant_latency = grant_wait_cycles;
      trn.grant_time = $realtime;
      
      `uvm_info("MON", $sformatf("Grant received after %0d cycles", grant_wait_cycles), UVM_HIGH)
      
   endtask
   
   /**
    * ç­‰å¾…å’Œé‡‡æ ·å“åº”
    */
   virtual task wait_and_sample_response(uvma_my_protocol_mon_trn_c trn);
      int response_wait_cycles = 0;
      
      // å¯¹äºè¯»æ“ä½œï¼Œç­‰å¾…validä¿¡å·
      if (trn.access_type == MY_PROTOCOL_READ) begin
         while (vif.mon_cb.valid !== 1'b1) begin
            @(vif.mon_cb);
            response_wait_cycles++;
            
            if (response_wait_cycles > cfg.req_timeout_cycles) begin
               `uvm_error("MON", "Valid timeout")
               trn.has_error = 1;
               return;
            end
         end
         
         // é‡‡æ ·è¯»å–æ•°æ®
         trn.read_data = vif.mon_cb.rdata;
      end else begin
         // å¯¹äºå†™æ“ä½œï¼Œç­‰å¾…readyä¿¡å·
         while (vif.mon_cb.ready !== 1'b1) begin
            @(vif.mon_cb);
            response_wait_cycles++;
            
            if (response_wait_cycles > cfg.req_timeout_cycles) begin
               `uvm_error("MON", "Ready timeout")
               trn.has_error = 1;
               return;
            end
         end
      end
      
      trn.response_latency = response_wait_cycles;
      trn.success = !trn.has_error;
      
      `uvm_info("MON", $sformatf("Response received after %0d cycles", response_wait_cycles), UVM_HIGH)
      
   endtask
   
   /**
    * è®¡ç®—æ€§èƒ½æŒ‡æ ‡
    */
   virtual task calculate_performance_metrics(uvma_my_protocol_mon_trn_c trn);
      
      trn.total_latency = trn.grant_latency + trn.response_latency;
      trn.execution_time = trn.end_time - trn.start_time;
      
      // æ›´æ–°å¹³å‡å»¶è¿Ÿ
      if (cntxt.total_requests > 0) begin
         real total_lat = cntxt.avg_request_latency * (cntxt.total_requests - 1) + trn.total_latency;
         cntxt.avg_request_latency = total_lat / cntxt.total_requests;
      end else begin
         cntxt.avg_request_latency = trn.total_latency;
      end
      
   endtask
   
   /**
    * åè®®è¿è§„ç›‘æ§
    */
   virtual task monitor_protocol_violations();
      
      forever begin
         @(vif.mon_cb);
         
         if (!monitoring_enabled) continue;
         
         // æ£€æŸ¥åŸºæœ¬åè®®è¿è§„
         check_basic_protocol_violations();
         
         // æ£€æŸ¥æ—¶åºè¿è§„  
         check_timing_violations();
         
         // æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
         check_data_integrity();
      end
      
   endtask
   
   /**
    * æ£€æŸ¥åŸºæœ¬åè®®è¿è§„
    */
   virtual function void check_basic_protocol_violations();
      
      // æ£€æŸ¥ï¼šreqä¿¡å·ä¿æŒæ—¶é—´
      if (vif.mon_cb.req && !vif.mon_cb.gnt) begin
         // reqåº”è¯¥ä¿æŒç›´åˆ°gnt
      end
      
      // æ£€æŸ¥ï¼šåœ°å€å¯¹é½
      if (vif.mon_cb.req) begin
         case (vif.mon_cb.be)
            4'b1111: begin  // å­—è®¿é—®
               if (vif.mon_cb.addr[1:0] != 2'b00) begin
                  `uvm_error("MON", $sformatf("Word access misaligned: addr=0x%08x", vif.mon_cb.addr))
               end
            end
            4'b0011, 4'b1100: begin  // åŠå­—è®¿é—®
               if (vif.mon_cb.addr[0] != 1'b0) begin
                  `uvm_error("MON", $sformatf("Halfword access misaligned: addr=0x%08x", vif.mon_cb.addr))
               end
            end
         endcase
      end
      
   endfunction
   
   /**
    * æ£€æŸ¥æ—¶åºè¿è§„
    */
   virtual function void check_timing_violations();
      
      // æ£€æŸ¥å»ºç«‹æ—¶é—´å’Œä¿æŒæ—¶é—´
      // (åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œä¼šæœ‰æ›´å¤æ‚çš„æ—¶åºæ£€æŸ¥)
      
   endfunction
   
   /**
    * æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
    */
   virtual function void check_data_integrity();
      
      // æ£€æŸ¥X/Zå€¼
      if (vif.mon_cb.req === 1'b1) begin
         if ($isunknown(vif.mon_cb.addr)) begin
            `uvm_error("MON", "Address contains X/Z values")
         end
         
         if (vif.mon_cb.we === 1'b1 && $isunknown(vif.mon_cb.wdata)) begin
            `uvm_error("MON", "Write data contains X/Z values")
         end
      end
      
   endfunction
   
   /**
    * å¤ä½ç›‘æ§
    */
   virtual task monitor_reset();
      forever begin
         @(negedge vif.rst_n);
         `uvm_info("MON", "Reset asserted, stopping monitoring", UVM_MEDIUM)
         monitoring_enabled = 0;
         
         // æ¸…ç©ºå¾…å¤„ç†äº‹åŠ¡
         pending_transactions.delete();
         
         // é‡ç½®ä¸Šä¸‹æ–‡
         cntxt.reset();
         
         @(posedge vif.rst_n);
         repeat(2) @(vif.mon_cb);
         `uvm_info("MON", "Reset released, resuming monitoring", UVM_MEDIUM)
         monitoring_enabled = 1;
      end
   endtask

endclass : uvma_my_protocol_mon_c
```

Alexï¼Œæˆ‘åˆ›å»ºäº†éå¸¸è¯¦ç»†çš„æ–°Agentå¼€å‘æµç¨‹ï¼ŒåŒ…æ‹¬æ¥å£å®šä¹‰ã€é…ç½®å¯¹è±¡ã€ä¸Šä¸‹æ–‡å¯¹è±¡ã€åºåˆ—é¡¹ã€é©±åŠ¨å™¨å’Œç›‘æ§å™¨çš„å®Œæ•´å®ç°ã€‚

è®©æˆ‘ç»§ç»­å®Œæˆå‰©ä½™çš„é‡è¦æ–‡æ¡£ï¼ˆç›‘æ§äº‹åŠ¡ç±»ã€åºåˆ—å™¨ã€Agentä¸»ç±»ï¼‰ï¼Œç„¶åç»§ç»­å…¶ä»–æ–‡æ¡£çš„åˆ›å»ºã€‚ç”±äºæ–‡æ¡£å†…å®¹éå¸¸è¯¦ç»†ï¼Œæˆ‘ä¼šç»§ç»­å®Œå–„è¿™ä¸ªç»„ä»¶æ‰©å±•å¼€å‘æŒ‡å—ã€‚