# CV32E40Pç»„ä»¶æ¶æ„ä»£ç Walkthrough

> **é€æ–‡ä»¶ã€é€ç»„ä»¶æ·±å…¥åˆ†æCV32E40PéªŒè¯ç¯å¢ƒçš„ä»£ç å®ç°**  
> é€‚åˆéœ€è¦æ·±å…¥ç†è§£ä»£ç å®ç°ç»†èŠ‚ã€è¿›è¡Œç»„ä»¶å®šåˆ¶æˆ–æ‰©å±•å¼€å‘çš„å·¥ç¨‹å¸ˆ

## ğŸ“‹ ç›®å½•

- [å®Œæ•´ç»„ä»¶å±‚æ¬¡ç»“æ„](#å®Œæ•´ç»„ä»¶å±‚æ¬¡ç»“æ„)
- [æ ¸å¿ƒç¯å¢ƒç±»æ·±åº¦è§£æ](#æ ¸å¿ƒç¯å¢ƒç±»æ·±åº¦è§£æ)
- [å…³é”®Agentè¯¦ç»†å®ç°](#å…³é”®agentè¯¦ç»†å®ç°)
- [æ¥å£å’Œåè®®åˆ†æ](#æ¥å£å’Œåè®®åˆ†æ)
- [ç›‘æ§å’ŒéªŒè¯ç»„ä»¶](#ç›‘æ§å’ŒéªŒè¯ç»„ä»¶)
- [æ‰©å±•å’Œå®šåˆ¶æŒ‡å—](#æ‰©å±•å’Œå®šåˆ¶æŒ‡å—)

---

## ğŸ—ï¸ å®Œæ•´ç»„ä»¶å±‚æ¬¡ç»“æ„

### åŸºäºå®é™…ä»£ç çš„ç»„ä»¶æ ‘

é€šè¿‡åˆ†æé¡¹ç›®ä¸­çš„å®é™…å®ç°ï¼ŒCV32E40PéªŒè¯ç¯å¢ƒçš„å®Œæ•´ç»„ä»¶å±‚æ¬¡ï¼š

```
uvmt_cv32e40p_tb (é¡¶å±‚æµ‹è¯•å°)
â”‚
â”œâ”€ uvme_cv32e40p_env_c (ç¯å¢ƒç±»)
â”‚  â”‚
â”‚  â”œâ”€ Agents ä»£ç†ç»„ä»¶å±‚
â”‚  â”‚  â”œâ”€ uvma_clknrst_agent_c              # æ—¶é’Ÿå¤ä½ä»£ç†
â”‚  â”‚  â”œâ”€ uvma_interrupt_agent_c            # ä¸­æ–­ä»£ç†
â”‚  â”‚  â”œâ”€ uvma_debug_agent_c                # è°ƒè¯•ä»£ç†
â”‚  â”‚  â”œâ”€ uvma_obi_memory_agent_c           # OBIå†…å­˜ä»£ç†(æŒ‡ä»¤)
â”‚  â”‚  â””â”€ uvma_obi_memory_agent_c           # OBIå†…å­˜ä»£ç†(æ•°æ®)
â”‚  â”‚
â”‚  â”œâ”€ Analysis åˆ†æç»„ä»¶å±‚  
â”‚  â”‚  â”œâ”€ uvme_cv32e40p_prd_c               # é¢„æµ‹å™¨
â”‚  â”‚  â”œâ”€ uvme_cv32e40p_sb_c                # è®°åˆ†æ¿
â”‚  â”‚  â””â”€ uvme_cv32e40p_cov_model_c         # è¦†ç›–ç‡æ¨¡å‹
â”‚  â”‚
â”‚  â””â”€ Control æ§åˆ¶ç»„ä»¶å±‚
â”‚     â””â”€ uvme_cv32e40p_vsqr_c              # è™šæ‹Ÿåºåˆ—å™¨
â”‚
â””â”€ External å¤–éƒ¨ç»„ä»¶å±‚
   â”œâ”€ uvmt_cv32e40p_dut_wrap (DUTåŒ…è£…å™¨)
   â””â”€ uvmt_cv32e40p_iss_wrap (ISSåŒ…è£…å™¨)
```

### ç»„ä»¶åˆ›å»ºå’Œé…ç½®çš„ä»£ç æ˜ å°„

```systemverilog
// æ–‡ä»¶ï¼šcv32e40p/env/uvme/uvme_cv32e40p_env.sv:build_phase
// ğŸ”¹ å®é™…çš„ç»„ä»¶åˆ›å»ºé¡ºåº

function void uvme_cv32e40p_env_c::build_phase(uvm_phase phase);
   
   super.build_phase(phase);
   
   // ğŸ”¹ ç¬¬1æ­¥ï¼šè·å–é…ç½®å¯¹è±¡
   void'(uvm_config_db#(uvme_cv32e40p_cfg_c)::get(this, "", "cfg", cfg));
   if (cfg == null) begin
      `uvm_fatal("UVME_CV32E40P_ENV", "Configuration handle is null")
   end
   
   // ğŸ”¹ ç¬¬2æ­¥ï¼šä¸Šä¸‹æ–‡å¤„ç†
   void'(uvm_config_db#(uvme_cv32e40p_cntxt_c)::get(this, "", "cntxt", cntxt));
   if (cntxt == null) begin
      cntxt = uvme_cv32e40p_cntxt_c::type_id::create("cntxt");
   end
   
   // ğŸ”¹ ç¬¬3æ­¥ï¼šå†…å­˜æ˜ å°„è®¾ç½®
   cntxt.obi_memory_instr_cntxt.mem = cntxt.mem;
   cntxt.obi_memory_data_cntxt.mem  = cntxt.mem;
   
   if (cfg.enabled) begin
      // ğŸ”¹ ç¬¬4æ­¥ï¼šæŒ‰é¡ºåºåˆ›å»ºç»„ä»¶
      retrieve_vifs        ();    # è·å–è™šæ‹Ÿæ¥å£
      assign_cfg           ();    # åˆ†å‘é…ç½®  
      assign_cntxt         ();    # åˆ†å‘ä¸Šä¸‹æ–‡
      create_agents        ();    # åˆ›å»ºä»£ç†
      create_env_components();    # åˆ›å»ºç¯å¢ƒç»„ä»¶
      create_vsequencer    ();    # åˆ›å»ºè™šæ‹Ÿåºåˆ—å™¨
      create_cov_model     ();    # åˆ›å»ºè¦†ç›–ç‡æ¨¡å‹
   end
endfunction
```

---

## ğŸ  æ ¸å¿ƒç¯å¢ƒç±»æ·±åº¦è§£æ

### uvme_cv32e40p_env_c - ç¯å¢ƒä¸»æ§ç±»

#### ç±»å£°æ˜å’Œæˆå‘˜å˜é‡åˆ†æ

```systemverilog
// æ–‡ä»¶ï¼šcv32e40p/env/uvme/uvme_cv32e40p_env.sv

/**
 * ğŸ—ï¸ ç¯å¢ƒç±»çš„å®Œæ•´ç»“æ„åˆ†æ
 */
class uvme_cv32e40p_env_c extends uvm_env;
   
   // ğŸ”¹ é…ç½®å’Œä¸Šä¸‹æ–‡å¯¹è±¡ (å¿…é¡»æœ€å…ˆå£°æ˜)
   uvme_cv32e40p_cfg_c    cfg;      # ç¯å¢ƒé…ç½®
   uvme_cv32e40p_cntxt_c  cntxt;    # ç¯å¢ƒä¸Šä¸‹æ–‡
   
   // ğŸ”¹ åˆ†æç»„ä»¶ (éªŒè¯æ ¸å¿ƒ)
   uvme_cv32e40p_cov_model_c  cov_model;   # è¦†ç›–ç‡æ”¶é›†
   uvme_cv32e40p_prd_c        predictor;   # è¡Œä¸ºé¢„æµ‹
   uvme_cv32e40p_sb_c         sb;          # ç»“æœæ¯”è¾ƒ
   uvme_cv32e40p_vsqr_c       vsequencer;  # åºåˆ—æ§åˆ¶
   
   // ğŸ”¹ æ¥å£ä»£ç† (æŒ‰åŠŸèƒ½åŸŸåˆ†ç»„)
   // Clock and Reset Domain
   uvma_clknrst_agent_c     clknrst_agent;
   
   // Interrupt Domain  
   uvma_interrupt_agent_c   interrupt_agent;
   
   // Debug Domain
   uvma_debug_agent_c       debug_agent;
   
   // Memory Interface Domain
   uvma_obi_memory_agent_c  obi_memory_instr_agent;  # æŒ‡ä»¤å†…å­˜
   uvma_obi_memory_agent_c  obi_memory_data_agent;   # æ•°æ®å†…å­˜
```

#### ç»„ä»¶åˆ›å»ºæ–¹æ³•è¯¦è§£

```systemverilog
// ğŸ”¹ create_agents() - ä»£ç†åˆ›å»ºçš„å®é™…å®ç°
function void uvme_cv32e40p_env_c::create_agents();
   
   // Clock/Reset Agent Creation
   if (cfg.clknrst_cfg.enabled) begin
      clknrst_agent = uvma_clknrst_agent_c::type_id::create("clknrst_agent", this);
      uvm_config_db#(uvma_clknrst_cfg_c)::set(this, "clknrst_agent", "cfg", cfg.clknrst_cfg);
      uvm_config_db#(uvma_clknrst_cntxt_c)::set(this, "clknrst_agent", "cntxt", cntxt.clknrst_cntxt);
   end
   
   // Debug Agent Creation
   if (cfg.debug_cfg.enabled) begin
      debug_agent = uvma_debug_agent_c::type_id::create("debug_agent", this);
      uvm_config_db#(uvma_debug_cfg_c)::set(this, "debug_agent", "cfg", cfg.debug_cfg);
      uvm_config_db#(uvma_debug_cntxt_c)::set(this, "debug_agent", "cntxt", cntxt.debug_cntxt);
   end
   
   // OBI Memory Agents Creation (æŒ‡ä»¤å’Œæ•°æ®åˆ†ç¦»)
   if (cfg.obi_memory_instr_cfg.enabled) begin
      obi_memory_instr_agent = uvma_obi_memory_agent_c::type_id::create("obi_memory_instr_agent", this);
      uvm_config_db#(uvma_obi_memory_cfg_c)::set(this, "obi_memory_instr_agent", "cfg", cfg.obi_memory_instr_cfg);
      uvm_config_db#(uvma_obi_memory_cntxt_c)::set(this, "obi_memory_instr_agent", "cntxt", cntxt.obi_memory_instr_cntxt);
   end
   
   if (cfg.obi_memory_data_cfg.enabled) begin
      obi_memory_data_agent = uvma_obi_memory_agent_c::type_id::create("obi_memory_data_agent", this);
      uvm_config_db#(uvma_obi_memory_cfg_c)::set(this, "obi_memory_data_agent", "cfg", cfg.obi_memory_data_cfg);
      uvm_config_db#(uvma_obi_memory_cntxt_c)::set(this, "obi_memory_data_agent", "cntxt", cntxt.obi_memory_data_cntxt);
   end
   
endfunction
```

#### è¿æ¥é˜¶æ®µçš„å®é™…å®ç°

```systemverilog
// ğŸ”¹ connect_phase() - åˆ†æç«¯å£è¿æ¥çš„å…·ä½“å®ç°
function void uvme_cv32e40p_env_c::connect_phase(uvm_phase phase);
   
   super.connect_phase(phase);
   
   if (cfg.enabled) begin
      // ğŸ”¹ è¿æ¥é¢„æµ‹å™¨ (æ•°æ®æµ: Monitor â†’ Predictor)
      connect_predictor();
      
      // ğŸ”¹ è¿æ¥è®°åˆ†æ¿ (æ•°æ®æµ: Predictor â†’ Scoreboard)  
      connect_scoreboard();
      
      // ğŸ”¹ ç»„è£…è™šæ‹Ÿåºåˆ—å™¨ (æ§åˆ¶æµ: VSeq â†’ Agent Sequencers)
      assemble_vsequencer();
      
      // ğŸ”¹ è¿æ¥è¦†ç›–ç‡æ¨¡å‹ (åˆ†ææµ: All â†’ Coverage)
      connect_coverage_model();
   end
   
endfunction

// ğŸ”¹ connect_predictor() - é¢„æµ‹å™¨è¿æ¥ç»†èŠ‚
function void uvme_cv32e40p_env_c::connect_predictor();
   
   if (predictor != null) begin
      // æŒ‡ä»¤æ€»çº¿è¿æ¥
      obi_memory_instr_agent.monitor.ap.connect(predictor.obi_memory_instr_export);
      
      // æ•°æ®æ€»çº¿è¿æ¥  
      obi_memory_data_agent.monitor.ap.connect(predictor.obi_memory_data_export);
      
      // è°ƒè¯•æ¥å£è¿æ¥
      if (debug_agent != null) begin
         debug_agent.monitor.ap.connect(predictor.debug_export);
      end
      
      // ä¸­æ–­æ¥å£è¿æ¥
      if (interrupt_agent != null) begin
         interrupt_agent.monitor.ap.connect(predictor.interrupt_export);
      end
   end
   
endfunction
```

---

## ğŸ”Œ å…³é”®Agentè¯¦ç»†å®ç°

### uvma_obi_memory_agent_c - OBIå†…å­˜ä»£ç†

#### Agentæ¶æ„æ·±åº¦åˆ†æ

```systemverilog
// æ–‡ä»¶ï¼šlib/uvm_agents/uvma_obi_memory/src/comps/uvma_obi_memory_agent.sv

/**
 * ğŸ—ï¸ OBI Memory Agentçš„å®Œæ•´ç»„ä»¶ç»“æ„
 * OBI (Open Bus Interface) æ˜¯OpenHWç»„ç»‡å®šä¹‰çš„å¼€æ”¾æ€»çº¿æ ‡å‡†
 */
class uvma_obi_memory_agent_c extends uvm_agent;
   
   // ğŸ”¹ é…ç½®å’Œä¸Šä¸‹æ–‡ (AgentåŸºç¡€è®¾æ–½)
   uvma_obi_memory_cfg_c    cfg;        # Agenté…ç½®
   uvma_obi_memory_cntxt_c  cntxt;      # Agentè¿è¡Œæ—¶ä¸Šä¸‹æ–‡
   
   // ğŸ”¹ æ ¸å¿ƒUVMç»„ä»¶ (æ ‡å‡†ä¸‰ä»¶å¥—)
   uvma_obi_memory_drv_c              driver;     # é©±åŠ¨å™¨ - ç”Ÿæˆæ€»çº¿äº‹åŠ¡
   uvma_obi_memory_mon_c              monitor;    # ç›‘æ§å™¨ - è§‚å¯Ÿæ€»çº¿æ´»åŠ¨
   uvma_obi_memory_sqr_c              sequencer;  # åºåˆ—å™¨ - ç®¡ç†æµ‹è¯•åºåˆ—
   
   // ğŸ”¹ é™„åŠ åŠŸèƒ½ç»„ä»¶
   uvma_obi_memory_cov_model_c        cov_model;        # è¦†ç›–ç‡æ”¶é›†
   uvma_obi_memory_seq_item_logger_c  seq_item_logger;  # åºåˆ—é¡¹æ—¥å¿—
   uvma_obi_memory_mon_trn_logger_c   mon_trn_logger;   # ç›‘æ§äº‹åŠ¡æ—¥å¿—
   
   // ğŸ”¹ TLMåˆ†æç«¯å£ (æ•°æ®æµæ¥å£)
   uvm_analysis_port#(uvma_obi_memory_mstr_seq_item_c)  drv_mstr_ap;  # ä¸»è®¾å¤‡é©±åŠ¨å™¨ç«¯å£
   uvm_analysis_port#(uvma_obi_memory_slv_seq_item_c )  drv_slv_ap ;  # ä»è®¾å¤‡é©±åŠ¨å™¨ç«¯å£
   uvm_analysis_port#(uvma_obi_memory_mon_trn_c      )  mon_ap     ;  # ç›‘æ§å™¨åˆ†æç«¯å£
```

#### build_phaseå®ç°åˆ†æ

```systemverilog
// ğŸ”¹ Agentæ„å»ºè¿‡ç¨‹çš„å®é™…ä»£ç 
function void uvma_obi_memory_agent_c::build_phase(uvm_phase phase);
   
   super.build_phase(phase);
   
   // ğŸ”¹ ç¬¬1æ­¥ï¼šé…ç½®è·å–å’ŒéªŒè¯
   get_and_set_cfg  ();
   get_and_set_cntxt();
   
   // ğŸ”¹ ç¬¬2æ­¥ï¼šæ¡ä»¶æ€§ç»„ä»¶åˆ›å»º (åŸºäºé…ç½®)
   if (cfg.enabled) begin
      
      // Monitor - æ€»æ˜¯åˆ›å»º (è¢«åŠ¨è§‚å¯Ÿ)
      monitor = uvma_obi_memory_mon_c::type_id::create("monitor", this);
      
      // Driverå’ŒSequencer - ä»…åœ¨Activeæ¨¡å¼åˆ›å»º
      if (cfg.is_active == UVM_ACTIVE) begin
         driver    = uvma_obi_memory_drv_c::type_id::create("driver"   , this);
         sequencer = uvma_obi_memory_sqr_c::type_id::create("sequencer", this);
      end
      
      // Coverage Model - å¯é€‰åˆ›å»º
      if (cfg.cov_model_enabled) begin
         cov_model = uvma_obi_memory_cov_model_c::type_id::create("cov_model", this);
      end
      
      // Loggers - è°ƒè¯•æ—¶åˆ›å»º
      if (cfg.trn_log_enabled) begin
         seq_item_logger = uvma_obi_memory_seq_item_logger_c::type_id::create("seq_item_logger", this);
         mon_trn_logger  = uvma_obi_memory_mon_trn_logger_c ::type_id::create("mon_trn_logger" , this);
      end
   end
   
endfunction
```

#### connect_phaseè¿æ¥é€»è¾‘

```systemverilog
// ğŸ”¹ Agentå†…éƒ¨è¿æ¥çš„è¯¦ç»†å®ç°
function void uvma_obi_memory_agent_c::connect_phase(uvm_phase phase);
   
   super.connect_phase(phase);
   
   if (cfg.enabled) begin
      
      // ğŸ”¹ åˆ†æç«¯å£è¿æ¥ (æ•°æ®æµå»ºç«‹)
      drv_mstr_ap = driver.mstr_ap;      # ä¸»è®¾å¤‡é©±åŠ¨å™¨ç«¯å£ç›´è¿
      drv_slv_ap  = driver.slv_ap ;      # ä»è®¾å¤‡é©±åŠ¨å™¨ç«¯å£ç›´è¿
      mon_ap      = monitor.ap    ;      # ç›‘æ§å™¨ç«¯å£ç›´è¿
      
      // ğŸ”¹ Driver-Sequencerè¿æ¥ (æ§åˆ¶æµå»ºç«‹)
      if (cfg.is_active == UVM_ACTIVE) begin
         driver.seq_item_port.connect(sequencer.seq_item_export);
      end
      
      // ğŸ”¹ è¦†ç›–ç‡è¿æ¥ (åˆ†ææµå»ºç«‹)
      if (cov_model != null) begin
         // é©±åŠ¨å™¨è¦†ç›–ç‡
         driver.mstr_ap.connect(cov_model.mstr_seq_item_export);
         driver.slv_ap .connect(cov_model.slv_seq_item_export );
         
         // ç›‘æ§å™¨è¦†ç›–ç‡
         monitor.ap.connect(cov_model.mon_trn_export);
      end
      
      // ğŸ”¹ æ—¥å¿—è¿æ¥ (è°ƒè¯•æµå»ºç«‹)
      if (seq_item_logger != null) begin
         driver.mstr_ap.connect(seq_item_logger.mstr_export);
         driver.slv_ap .connect(seq_item_logger.slv_export );
      end
      
      if (mon_trn_logger != null) begin
         monitor.ap.connect(mon_trn_logger.analysis_export);
      end
   end
   
endfunction
```

### Driverç»„ä»¶çš„å®ç°ç»†èŠ‚

```systemverilog
// æ–‡ä»¶ï¼šlib/uvm_agents/uvma_obi_memory/src/comps/uvma_obi_memory_drv.sv (æ¦‚å¿µæ€§å±•ç¤º)

class uvma_obi_memory_drv_c extends uvm_driver#(uvma_obi_memory_seq_item_c);
   
   // ğŸ”¹ è™šæ‹Ÿæ¥å£å¥æŸ„ (ä¸DUTé€šä¿¡)
   virtual uvma_obi_memory_if  vif;
   
   // ğŸ”¹ é…ç½®å’Œä¸Šä¸‹æ–‡
   uvma_obi_memory_cfg_c    cfg;
   uvma_obi_memory_cntxt_c  cntxt;
   
   // ğŸ”¹ åˆ†æç«¯å£ (å‘ä¸Šçº§æŠ¥å‘Š)
   uvm_analysis_port#(uvma_obi_memory_mstr_seq_item_c)  mstr_ap;
   uvm_analysis_port#(uvma_obi_memory_slv_seq_item_c )  slv_ap;
   
   /**
    * ğŸš— ä¸»è¦é©±åŠ¨ä»»åŠ¡ - å°†åºåˆ—é¡¹è½¬æ¢ä¸ºæ€»çº¿ä¿¡å·
    */
   virtual task run_phase(uvm_phase phase);
      
      forever begin
         // ğŸ”¹ ä»åºåˆ—å™¨è·å–ä¸‹ä¸€ä¸ªäº‹åŠ¡
         seq_item_port.get_next_item(req);
         
         // ğŸ”¹ æ ¹æ®äº‹åŠ¡ç±»å‹æ‰§è¡Œç›¸åº”çš„æ€»çº¿æ“ä½œ
         case (req.access_type)
            UVMA_OBI_MEMORY_ACCESS_READ:  drive_read_access (req);
            UVMA_OBI_MEMORY_ACCESS_WRITE: drive_write_access(req);
            default: `uvm_error("DRV", $sformatf("Unknown access type: %s", req.access_type.name()));
         endcase
         
         // ğŸ”¹ å‘åˆ†æç«¯å£å¹¿æ’­å®Œæˆçš„äº‹åŠ¡
         mstr_ap.write(req);
         
         // ğŸ”¹ é€šçŸ¥åºåˆ—å™¨äº‹åŠ¡å®Œæˆ
         seq_item_port.item_done();
      end
   endtask
   
   /**
    * ğŸ” è¯»æ“ä½œçš„å…·ä½“å®ç°
    */
   virtual task drive_read_access(uvma_obi_memory_seq_item_c req);
      
      // ğŸ”¹ ç¬¬1æ­¥ï¼šè®¾ç½®åœ°å€å’Œæ§åˆ¶ä¿¡å·
      vif.req     <= 1'b1;
      vif.we      <= 1'b0;           # è¯»æ“ä½œ
      vif.addr    <= req.address;
      vif.be      <= req.byte_enable;
      
      // ğŸ”¹ ç¬¬2æ­¥ï¼šç­‰å¾…æ€»çº¿æ¡æ‰‹
      do begin
         @(posedge vif.clk);
      end while (vif.gnt !== 1'b1);
      
      // ğŸ”¹ ç¬¬3æ­¥ï¼šç­‰å¾…æ•°æ®è¿”å›
      do begin
         @(posedge vif.clk);
      end while (vif.rvalid !== 1'b1);
      
      // ğŸ”¹ ç¬¬4æ­¥ï¼šé‡‡æ ·è¿”å›æ•°æ®
      req.rdata = vif.rdata;
      
      // ğŸ”¹ ç¬¬5æ­¥ï¼šæ¸…é™¤è¯·æ±‚ä¿¡å·
      vif.req <= 1'b0;
      
   endtask
```

---

## ğŸ” æ¥å£å’Œåè®®åˆ†æ

### OBI (Open Bus Interface) åè®®å®ç°

#### æ¥å£å®šä¹‰çš„å®é™…ä»£ç 

```systemverilog
// æ–‡ä»¶ï¼šlib/uvm_agents/uvma_obi_memory/src/uvma_obi_memory_if.sv

/**
 * ğŸ”Œ OBI Memoryæ¥å£çš„å®Œæ•´ä¿¡å·å®šä¹‰
 * åŸºäºOpenHWç»„ç»‡çš„OBI 1.2è§„èŒƒå®ç°
 */
interface uvma_obi_memory_if (
   input logic clk,      # æ—¶é’Ÿä¿¡å·
   input logic reset_n   # å¤ä½ä¿¡å· (ä½æœ‰æ•ˆ)
);
   
   // ğŸ”¹ è¯·æ±‚é˜¶æ®µä¿¡å· (Master â†’ Slave)
   logic         req;       # è¯·æ±‚æœ‰æ•ˆä¿¡å·
   logic [31:0]  addr;      # åœ°å€ä¿¡å· (32ä½åœ°å€ç©ºé—´)
   logic         we;        # å†™ä½¿èƒ½ (1=å†™, 0=è¯»)
   logic [3:0]   be;        # å­—èŠ‚ä½¿èƒ½ (æ”¯æŒéå¯¹é½è®¿é—®)
   logic [31:0]  wdata;     # å†™æ•°æ® (32ä½æ•°æ®æ€»çº¿)
   
   // ğŸ”¹ å“åº”é˜¶æ®µä¿¡å· (Slave â†’ Master)
   logic         gnt;       # æˆæƒä¿¡å· (æ¡æ‰‹ç¡®è®¤)
   logic         rvalid;    # è¯»æ•°æ®æœ‰æ•ˆ
   logic [31:0]  rdata;     # è¯»æ•°æ®
   
   // ğŸ”¹ æ—¶é’Ÿè¾¹æ²¿å®šä¹‰ (åŒæ­¥æ¥å£)
   clocking mstr_cb @(posedge clk);    # ä¸»è®¾å¤‡æ—¶é’ŸåŸŸ
      default input #1step output #1step;
      output req, addr, we, be, wdata;
      input  gnt, rvalid, rdata;
   endclocking
   
   clocking slv_cb @(posedge clk);     # ä»è®¾å¤‡æ—¶é’ŸåŸŸ  
      default input #1step output #1step;
      input  req, addr, we, be, wdata;
      output gnt, rvalid, rdata;
   endclocking
   
   // ğŸ”¹ å»ºæ¨¡ç«¯å£ (ä»¿çœŸé©±åŠ¨)
   modport mstr_mp (clocking mstr_cb);
   modport slv_mp  (clocking slv_cb );
   
   /**
    * ğŸ” åè®®æ£€æŸ¥å™¨ - ç¡®ä¿æ—¶åºåˆè§„
    */
   // æ£€æŸ¥ï¼šè¯·æ±‚åå¿…é¡»æœ‰æˆæƒ
   property req_gnt_handshake;
      @(posedge clk) disable iff (!reset_n)
      req |-> ##[1:10] gnt;    # è¯·æ±‚å1-10å‘¨æœŸå†…å¿…é¡»æˆæƒ
   endproperty
   
   // æ£€æŸ¥ï¼šè¯»æ“ä½œåå¿…é¡»æœ‰æ•°æ®è¿”å›
   property read_rvalid;
      @(posedge clk) disable iff (!reset_n)  
      (req && gnt && !we) |-> ##[1:10] rvalid;
   endproperty
   
   assert property (req_gnt_handshake) else `uvm_error("OBI_IF", "Request/Grant handshake violation");
   assert property (read_rvalid) else `uvm_error("OBI_IF", "Read operation missing rvalid");
   
endinterface
```

#### åè®®æ—¶åºå›¾

```
OBIè¯»æ“ä½œæ—¶åºï¼š

    clk    â”Œâ”€â” â”Œâ”€â” â”Œâ”€â” â”Œâ”€â” â”Œâ”€â” â”Œâ”€â” â”Œâ”€â”
           â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚
           â””â”€â”˜ â””â”€â”˜ â””â”€â”˜ â””â”€â”˜ â””â”€â”˜ â””â”€â”˜ â””â”€â”˜
    
    req    â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
               â””â”€â”€â”€â”€â”€â”€â”€â”˜
    
    addr   XXXXXXâ•±â•â•â•â•â•â•â•â•â•â•â•²XXXXXXXXX
               â•± 0x8000_0004 â•²
    
    we     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€0â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    gnt    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€
                       â””â”€â”€â”€â”˜
    
    rvalid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€
                             â””â”€â”€â”€â”˜
    
    rdata  XXXXXXXXXXXXXXXâ•±â•â•â•â•â•â•â•â•²XXX
                         â•± Data   â•²

    é˜¶æ®µï¼š  è¯·æ±‚    æ¡æ‰‹    æ•°æ®è¿”å›
```

### è°ƒè¯•æ¥å£å®ç°

```systemverilog
// æ–‡ä»¶ï¼šlib/uvm_agents/uvma_debug/uvma_debug_if.sv (æ¦‚å¿µå±•ç¤º)

interface uvma_debug_if (
   input logic clk,
   input logic reset_n
);
   
   // ğŸ”¹ è°ƒè¯•è¯·æ±‚ä¿¡å·
   logic        debug_req;      # è°ƒè¯•è¯·æ±‚
   logic [31:0] debug_addr;     # è°ƒè¯•åœ°å€
   logic        debug_we;       # è°ƒè¯•å†™ä½¿èƒ½
   logic [31:0] debug_wdata;    # è°ƒè¯•å†™æ•°æ®
   logic [31:0] debug_rdata;    # è°ƒè¯•è¯»æ•°æ®
   
   // ğŸ”¹ è°ƒè¯•çŠ¶æ€ä¿¡å·
   logic        debug_mode;     # è°ƒè¯•æ¨¡å¼æŒ‡ç¤º
   logic        debug_halt_req; # åœæœºè¯·æ±‚
   logic        debug_resume_req; # æ¢å¤è¯·æ±‚
   
   // ğŸ”¹ æ–­ç‚¹å’Œè§‚å¯Ÿç‚¹
   logic [3:0]  debug_bp_hit;   # æ–­ç‚¹å‘½ä¸­
   logic [3:0]  debug_wp_hit;   # è§‚å¯Ÿç‚¹å‘½ä¸­
   
endinterface
```

---

## ğŸ“Š ç›‘æ§å’ŒéªŒè¯ç»„ä»¶

### Monitorç»„ä»¶å®ç°æ·±åº¦åˆ†æ

```systemverilog
// æ–‡ä»¶ï¼šlib/uvm_agents/uvma_obi_memory/src/comps/uvma_obi_memory_mon.sv (ç®€åŒ–å±•ç¤º)

/**
 * ğŸ” OBI Memory Monitor - è¢«åŠ¨è§‚å¯Ÿæ€»çº¿æ´»åŠ¨
 */
class uvma_obi_memory_mon_c extends uvm_monitor;
   
   // ğŸ”¹ æ¥å£å’Œé…ç½®
   virtual uvma_obi_memory_if  vif;
   uvma_obi_memory_cfg_c       cfg;
   uvma_obi_memory_cntxt_c     cntxt;
   
   // ğŸ”¹ è¾“å‡ºç«¯å£ (å‘ä¸Šçº§åˆ†æç»„ä»¶æŠ¥å‘Š)
   uvm_analysis_port#(uvma_obi_memory_mon_trn_c)  ap;
   
   /**
    * ğŸ¯ ä¸»ç›‘æ§ä»»åŠ¡ - æŒç»­è§‚å¯Ÿæ€»çº¿æ´»åŠ¨
    */
   virtual task run_phase(uvm_phase phase);
      
      forever begin
         uvma_obi_memory_mon_trn_c  trn;
         
         // ğŸ”¹ ç­‰å¾…æ€»çº¿æ´»åŠ¨
         wait_for_transaction_start();
         
         // ğŸ”¹ åˆ›å»ºç›‘æ§äº‹åŠ¡å¯¹è±¡
         trn = uvma_obi_memory_mon_trn_c::type_id::create("trn");
         
         // ğŸ”¹ é‡‡æ ·äº‹åŠ¡ä¿¡æ¯
         sample_transaction(trn);
         
         // ğŸ”¹ ç­‰å¾…äº‹åŠ¡å®Œæˆ
         wait_for_transaction_end(trn);
         
         // ğŸ”¹ å‘åˆ†æç«¯å£å¹¿æ’­
         ap.write(trn);
         
         // ğŸ”¹ è®°å½•åˆ°ä¸Šä¸‹æ–‡
         cntxt.mon_trns.push_back(trn);
      end
   endtask
   
   /**
    * ğŸ¯ ç­‰å¾…äº‹åŠ¡å¼€å§‹
    */
   virtual task wait_for_transaction_start();
      do begin
         @(posedge vif.clk);
      end while (!(vif.req && vif.gnt));    # OBIæ¡æ‰‹
   endtask
   
   /**
    * ğŸ“Š é‡‡æ ·äº‹åŠ¡ä¿¡æ¯
    */
   virtual task sample_transaction(uvma_obi_memory_mon_trn_c trn);
      
      // ğŸ”¹ åœ°å€é˜¶æ®µé‡‡æ ·
      trn.address     = vif.addr;
      trn.access_type = vif.we ? UVMA_OBI_MEMORY_ACCESS_WRITE : UVMA_OBI_MEMORY_ACCESS_READ;
      trn.byte_enable = vif.be;
      
      if (trn.access_type == UVMA_OBI_MEMORY_ACCESS_WRITE) begin
         trn.wdata = vif.wdata;
      end
      
      // ğŸ”¹ æ—¶é—´æˆ³è®°å½•
      trn.timestamp = $time;
      
   endtask
   
endclass
```

### Scoreboardå®ç° - Step-and-Compare

```systemverilog
// æ–‡ä»¶ï¼šcv32e40p/env/uvme/uvme_cv32e40p_sb.sv (æ¦‚å¿µå±•ç¤º)

/**
 * ğŸ“Š CV32E40P Scoreboard - å®ç°step-and-compareéªŒè¯
 */
class uvme_cv32e40p_sb_c extends uvm_scoreboard;
   
   // ğŸ”¹ åˆ†æç«¯å£ (ä»å„ä¸ªAgentæ¥æ”¶äº‹åŠ¡)
   `uvm_analysis_imp_decl(_obi_instr)
   `uvm_analysis_imp_decl(_obi_data)
   `uvm_analysis_imp_decl(_iss_instr)
   
   uvm_analysis_imp_obi_instr#(uvma_obi_memory_mon_trn_c, uvme_cv32e40p_sb_c)  obi_instr_export;
   uvm_analysis_imp_obi_data #(uvma_obi_memory_mon_trn_c, uvme_cv32e40p_sb_c)  obi_data_export;
   uvm_analysis_imp_iss_instr#(uvme_iss_instr_trn_c     , uvme_cv32e40p_sb_c)  iss_instr_export;
   
   // ğŸ”¹ æ¯”è¾ƒé˜Ÿåˆ— (å­˜å‚¨å¾…æ¯”è¾ƒçš„äº‹åŠ¡)
   uvma_obi_memory_mon_trn_c  rtl_instr_queue[$];   # RTLæŒ‡ä»¤äº‹åŠ¡é˜Ÿåˆ—
   uvme_iss_instr_trn_c       iss_instr_queue[$];   # ISSæŒ‡ä»¤äº‹åŠ¡é˜Ÿåˆ—
   
   /**
    * ğŸ” æ¥æ”¶RTLæŒ‡ä»¤äº‹åŠ¡
    */
   virtual function void write_obi_instr(uvma_obi_memory_mon_trn_c trn);
      
      // ğŸ”¹ å°†RTLäº‹åŠ¡åŠ å…¥é˜Ÿåˆ—
      rtl_instr_queue.push_back(trn);
      
      // ğŸ”¹ å°è¯•è¿›è¡Œæ¯”è¾ƒ
      try_compare_instruction();
      
   endfunction
   
   /**
    * ğŸ” æ¥æ”¶ISSæŒ‡ä»¤äº‹åŠ¡
    */
   virtual function void write_iss_instr(uvme_iss_instr_trn_c trn);
      
      // ğŸ”¹ å°†ISSäº‹åŠ¡åŠ å…¥é˜Ÿåˆ—
      iss_instr_queue.push_back(trn);
      
      // ğŸ”¹ å°è¯•è¿›è¡Œæ¯”è¾ƒ
      try_compare_instruction();
      
   endfunction
   
   /**
    * ğŸ¯ Step-and-Compareæ ¸å¿ƒé€»è¾‘
    */
   virtual function void try_compare_instruction();
      
      uvma_obi_memory_mon_trn_c  rtl_trn;
      uvme_iss_instr_trn_c       iss_trn;
      
      // ğŸ”¹ æ£€æŸ¥æ˜¯å¦æœ‰åŒ¹é…çš„äº‹åŠ¡å¯æ¯”è¾ƒ
      if (rtl_instr_queue.size() > 0 && iss_instr_queue.size() > 0) begin
         
         // ğŸ”¹ å–å‡ºé˜Ÿé¦–äº‹åŠ¡
         rtl_trn = rtl_instr_queue.pop_front();
         iss_trn = iss_instr_queue.pop_front();
         
         // ğŸ”¹ æ‰§è¡Œè¯¦ç»†æ¯”è¾ƒ
         compare_instruction_transaction(rtl_trn, iss_trn);
      end
   endfunction
   
   /**
    * ğŸ“Š æŒ‡ä»¤äº‹åŠ¡æ¯”è¾ƒçš„è¯¦ç»†å®ç°
    */
   virtual function void compare_instruction_transaction(
      uvma_obi_memory_mon_trn_c  rtl_trn,
      uvme_iss_instr_trn_c       iss_trn
   );
      
      bit match = 1'b1;
      
      // ğŸ”¹ åœ°å€æ¯”è¾ƒ
      if (rtl_trn.address !== iss_trn.pc) begin
         `uvm_error("SB", $sformatf("PC mismatch: RTL=%h, ISS=%h", rtl_trn.address, iss_trn.pc))
         match = 1'b0;
      end
      
      // ğŸ”¹ æŒ‡ä»¤å†…å®¹æ¯”è¾ƒ
      if (rtl_trn.rdata !== iss_trn.instruction) begin
         `uvm_error("SB", $sformatf("Instruction mismatch at PC=%h: RTL=%h, ISS=%h", 
                                   rtl_trn.address, rtl_trn.rdata, iss_trn.instruction))
         match = 1'b0;
      end
      
      // ğŸ”¹ ç»Ÿè®¡è®°å½•
      if (match) begin
         num_matches++;
         `uvm_info("SB", $sformatf("Instruction match #%0d at PC=%h", num_matches, rtl_trn.address), UVM_HIGH)
      end else begin
         num_mismatches++;
      end
      
   endfunction
   
endclass
```

---

## ğŸ› ï¸ æ‰©å±•å’Œå®šåˆ¶æŒ‡å—

### æ·»åŠ æ–°Agentçš„æ ‡å‡†æµç¨‹

#### ç¬¬1æ­¥ï¼šåˆ›å»ºAgentç›®å½•ç»“æ„

```bash
# ğŸ”¹ æŒ‰ç…§é¡¹ç›®çº¦å®šåˆ›å»ºç›®å½•ç»“æ„
lib/uvm_agents/uvma_my_protocol/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ comps/                          # ç»„ä»¶å®ç°
â”‚   â”‚   â”œâ”€â”€ uvma_my_protocol_agent.sv
â”‚   â”‚   â”œâ”€â”€ uvma_my_protocol_drv.sv
â”‚   â”‚   â”œâ”€â”€ uvma_my_protocol_mon.sv
â”‚   â”‚   â””â”€â”€ uvma_my_protocol_sqr.sv
â”‚   â”œâ”€â”€ obj/                            # å¯¹è±¡å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ uvma_my_protocol_cfg.sv
â”‚   â”‚   â”œâ”€â”€ uvma_my_protocol_cntxt.sv
â”‚   â”‚   â””â”€â”€ uvma_my_protocol_seq_item.sv
â”‚   â”œâ”€â”€ seq/                            # åºåˆ—åº“
â”‚   â”‚   â””â”€â”€ uvma_my_protocol_base_seq.sv
â”‚   â”œâ”€â”€ uvma_my_protocol_if.sv          # æ¥å£å®šä¹‰
â”‚   â”œâ”€â”€ uvma_my_protocol_pkg.sv         # åŒ…æ–‡ä»¶
â”‚   â””â”€â”€ uvma_my_protocol_pkg.flist      # æ–‡ä»¶åˆ—è¡¨
```

#### ç¬¬2æ­¥ï¼šå®ç°æ ¸å¿ƒAgentç±»

```systemverilog
// æ–‡ä»¶ï¼šlib/uvm_agents/uvma_my_protocol/src/comps/uvma_my_protocol_agent.sv

class uvma_my_protocol_agent_c extends uvm_agent;
   
   // ğŸ”¹ éµå¾ªé¡¹ç›®å‘½åçº¦å®š
   uvma_my_protocol_cfg_c    cfg;
   uvma_my_protocol_cntxt_c  cntxt;
   
   // ğŸ”¹ æ ‡å‡†UVMç»„ä»¶
   uvma_my_protocol_drv_c    driver;
   uvma_my_protocol_mon_c    monitor; 
   uvma_my_protocol_sqr_c    sequencer;
   
   // ğŸ”¹ åˆ†æç«¯å£
   uvm_analysis_port#(uvma_my_protocol_mon_trn_c)  mon_ap;
   
   `uvm_component_utils_begin(uvma_my_protocol_agent_c)
      `uvm_field_object(cfg  , UVM_DEFAULT)
      `uvm_field_object(cntxt, UVM_DEFAULT)
   `uvm_component_utils_end
   
   // ğŸ”¹ æŒ‰ç…§é¡¹ç›®æ¨¡å¼å®ç°Phaseæ–¹æ³•
   virtual function void build_phase(uvm_phase phase);
      super.build_phase(phase);
      
      // è·å–é…ç½®
      void'(uvm_config_db#(uvma_my_protocol_cfg_c)::get(this, "", "cfg", cfg));
      if (cfg == null) `uvm_fatal("AGENT", "Configuration not found");
      
      // åˆ›å»ºç»„ä»¶
      if (cfg.enabled) begin
         monitor = uvma_my_protocol_mon_c::type_id::create("monitor", this);
         
         if (cfg.is_active == UVM_ACTIVE) begin
            driver    = uvma_my_protocol_drv_c::type_id::create("driver", this);
            sequencer = uvma_my_protocol_sqr_c::type_id::create("sequencer", this);
         end
      end
   endfunction
   
   virtual function void connect_phase(uvm_phase phase);
      super.connect_phase(phase);
      
      if (cfg.enabled) begin
         // è¿æ¥åˆ†æç«¯å£
         mon_ap = monitor.ap;
         
         // è¿æ¥Driverå’ŒSequencer
         if (cfg.is_active == UVM_ACTIVE) begin
            driver.seq_item_port.connect(sequencer.seq_item_export);
         end
      end
   endfunction
   
endclass
```

#### ç¬¬3æ­¥ï¼šé›†æˆåˆ°ç¯å¢ƒä¸­

```systemverilog
// æ–‡ä»¶ï¼šcv32e40p/env/uvme/uvme_cv32e40p_env.sv (æ‰©å±•)

class uvme_cv32e40p_env_c extends uvm_env;
   
   // ğŸ”¹ åœ¨ç¯å¢ƒä¸­æ·»åŠ æ–°Agent
   uvma_my_protocol_agent_c  my_protocol_agent;
   
   // ğŸ”¹ åœ¨create_agentsä¸­å®ä¾‹åŒ–
   function void create_agents();
      // ... ç°æœ‰Agentåˆ›å»ºä»£ç  ...
      
      // æ–°Agentåˆ›å»º
      if (cfg.my_protocol_cfg.enabled) begin
         my_protocol_agent = uvma_my_protocol_agent_c::type_id::create("my_protocol_agent", this);
         uvm_config_db#(uvma_my_protocol_cfg_c)::set(this, "my_protocol_agent", "cfg", cfg.my_protocol_cfg);
         uvm_config_db#(uvma_my_protocol_cntxt_c)::set(this, "my_protocol_agent", "cntxt", cntxt.my_protocol_cntxt);
      end
   endfunction
   
   // ğŸ”¹ åœ¨è¿æ¥é˜¶æ®µé›†æˆ
   function void connect_predictor();
      // ... ç°æœ‰è¿æ¥ä»£ç  ...
      
      // æ–°Agentè¿æ¥
      if (my_protocol_agent != null) begin
         my_protocol_agent.monitor.ap.connect(predictor.my_protocol_export);
      end
   endfunction
   
endclass
```

### å®šåˆ¶ç°æœ‰ç»„ä»¶çš„æœ€ä½³å®è·µ

#### æ‰©å±•é…ç½®å¯¹è±¡

```systemverilog
// ğŸ”¹ æ‰©å±•ç¯å¢ƒé…ç½®ä»¥æ”¯æŒæ–°åŠŸèƒ½
class my_extended_cfg_c extends uvme_cv32e40p_cfg_c;
   
   // æ–°å¢é…ç½®é¡¹
   bit                      my_feature_enabled;
   int                      my_timeout_cycles;
   my_protocol_mode_e       my_protocol_mode;
   
   `uvm_object_utils_begin(my_extended_cfg_c)
      `uvm_field_int (my_feature_enabled, UVM_DEFAULT)
      `uvm_field_int (my_timeout_cycles , UVM_DEFAULT)
      `uvm_field_enum(my_protocol_mode_e, my_protocol_mode, UVM_DEFAULT)
   `uvm_object_utils_end
   
   // çº¦æŸæ–°å¢é…ç½®é¡¹
   constraint my_feature_cons {
      if (my_feature_enabled) {
         my_timeout_cycles inside {[100:1000]};
         my_protocol_mode != INVALID_MODE;
      }
   }
   
endclass
```

#### æ‰©å±•æµ‹è¯•ç±»

```systemverilog
// ğŸ”¹ åŸºäºé¡¹ç›®base_teståˆ›å»ºå®šåˆ¶æµ‹è¯•
class my_custom_test_c extends uvmt_cv32e40p_base_test_c;
   
   `uvm_component_utils(my_custom_test_c)
   
   // ğŸ”¹ é‡è½½é…ç½®åˆ›å»º
   virtual function void create_cfg();
      super.create_cfg();
      
      // å®šåˆ¶é…ç½®
      env_cfg.my_feature_enabled = 1'b1;
      env_cfg.my_timeout_cycles = 500;
   endfunction
   
   // ğŸ”¹ é‡è½½è¿è¡ŒPhaseæ·»åŠ å®šåˆ¶é€»è¾‘
   virtual task run_phase(uvm_phase phase);
      my_custom_vseq_c  my_vseq;
      
      phase.raise_objection(this);
      
      // æ‰§è¡Œå®šåˆ¶åºåˆ—
      my_vseq = my_custom_vseq_c::type_id::create("my_vseq");
      my_vseq.start(vsequencer);
      
      // è°ƒç”¨çˆ¶ç±»é€»è¾‘
      super.run_phase(phase);
      
      phase.drop_objection(this);
   endtask
   
endclass
```

---

## ğŸ’¡ æœ€ä½³å®è·µæ€»ç»“

### ä»£ç ç»„ç»‡åŸåˆ™

1. **ğŸ“ å±‚æ¬¡åŒ–è®¾è®¡**ï¼šä¸¥æ ¼éµå¾ªAgent â†’ Environment â†’ Testçš„å±‚æ¬¡ç»“æ„
2. **ğŸ”§ é…ç½®é©±åŠ¨**ï¼šæ‰€æœ‰è¡Œä¸ºéƒ½é€šè¿‡é…ç½®å¯¹è±¡æ§åˆ¶
3. **ğŸ”„ å¯å¤ç”¨æ€§**ï¼šç»„ä»¶è®¾è®¡è€ƒè™‘å¤šé¡¹ç›®å¤ç”¨
4. **ğŸ“Š å¯è§‚å¯Ÿæ€§**ï¼šæä¾›å……è¶³çš„æ—¥å¿—å’Œè°ƒè¯•ä¿¡æ¯

### è°ƒè¯•å’Œç»´æŠ¤æŠ€å·§

1. **ğŸ” åˆ†å±‚è°ƒè¯•**ï¼šä»Test â†’ Environment â†’ Agent â†’ Driver/Monitoré€å±‚ç¼©å°é—®é¢˜èŒƒå›´
2. **ğŸ“ˆ åˆ†æç«¯å£è¿½è¸ª**ï¼šåˆ©ç”¨åˆ†æç«¯å£çš„è¿æ¥å…³ç³»è¿½è¸ªæ•°æ®æµ
3. **â±ï¸ æ—¶åºè°ƒè¯•**ï¼šä½¿ç”¨æ³¢å½¢æŸ¥çœ‹å™¨åˆ†æPhaseåˆ‡æ¢å’Œæ—¶åºé—®é¢˜  
4. **ğŸ“‹ é…ç½®éªŒè¯**ï¼šç¡®ä¿é…ç½®å¯¹è±¡çš„ä¸€è‡´æ€§å’Œçº¦æŸæ­£ç¡®æ€§

---

> ğŸ’¡ **å¼€å‘å»ºè®®**  
> åœ¨æ‰©å±•æˆ–ä¿®æ”¹CV32E40PéªŒè¯ç¯å¢ƒæ—¶ï¼Œé¦–å…ˆç†è§£ç°æœ‰ç»„ä»¶çš„è®¾è®¡æ¨¡å¼å’Œè¿æ¥å…³ç³»ï¼Œç„¶åæŒ‰ç…§ç›¸åŒçš„æ¨¡å¼è¿›è¡Œæ‰©å±•ã€‚é¡¹ç›®çš„ç»„ä»¶æ¶æ„ç»è¿‡ç²¾å¿ƒè®¾è®¡ï¼Œéµå¾ªå…¶æ¨¡å¼èƒ½å¤Ÿç¡®ä¿æ‰©å±•çš„å…¼å®¹æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

> ğŸ”§ **è°ƒè¯•æç¤º**  
> å½“é‡åˆ°ç»„ä»¶é›†æˆé—®é¢˜æ—¶ï¼Œé‡ç‚¹æ£€æŸ¥é…ç½®å¯¹è±¡çš„åˆ†å‘ã€åˆ†æç«¯å£çš„è¿æ¥ä»¥åŠPhaseæ–¹æ³•çš„å®ç°ã€‚å¤§å¤šæ•°é›†æˆé—®é¢˜éƒ½æºäºè¿™ä¸‰ä¸ªæ–¹é¢çš„ä¸åŒ¹é…ã€‚