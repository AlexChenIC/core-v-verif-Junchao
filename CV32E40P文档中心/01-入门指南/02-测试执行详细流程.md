# CV32E40P 测试执行详细指南 📚

## 概述

本指南详细解释了在CV32E40P验证环境中执行 `make test TEST=hello-world` 命令后，整个系统的每一步执行流程。

### 🎯 目标读者
- 具有UVM基础经验的验证工程师
- 了解SoC设计的硬件工程师  
- 熟悉xrun仿真器的工程师
- 对RISC-V处理器验证感兴趣的初学者

### 🔍 你将学到什么
- 完整的验证流程：从Makefile到最终测试报告
- UVM测试台的工作原理和组件协调
- 软硬件协同验证的实现机制
- step-and-compare验证方法学
- 实际的调试技巧和问题排查方法

> 💡 **类比理解**: 如果把处理器验证比作工厂质检，那么这个指南就是详细的质检手册——告诉你每个检验步骤的原理、工具使用方法，以及如何确保产品质量。

## 🔧 环境准备和前置条件

### 基本环境设置

在执行测试前，必须设置以下关键环境变量：

```bash
# ✨ 仿真器选择：告诉系统使用哪个仿真工具
export CV_SIMULATOR=xrun                    # Cadence Xcelium (高性能专业仿真器)

# 🎯 目标核心：指定要验证的处理器型号  
export CV_CORE=cv32e40p                     # OpenHW的RISC-V核心

# 🔧 工具链路径：编译器和工具的安装位置
export CV_SW_TOOLCHAIN=/opt/riscv           # RISC-V GCC工具链根目录

# 🏷️ 工具链前缀：编译器可执行文件的命名前缀
export CV_SW_PREFIX=riscv32-unknown-elf-    # 32位RISC-V编译器前缀
```

### 📝 自检清单

在继续之前，请确认：
- [ ] Cadence Xcelium已正确安装且可访问
- [ ] RISC-V工具链已安装在`/opt/riscv`
- [ ] 环境变量已正确设置（可用`make vars`检查）
- [ ] 有读写项目目录的权限

> 💡 **类比理解**: 这些环境变量就像是告诉工厂机器人使用哪个工具、在哪里找零件、怎么组装产品。没有这些信息，机器人就不知道该做什么。

## 目录结构

```
core-v-verif/
├── cv32e40p/
│   ├── sim/uvmt/                          # UVM测试台仿真目录
│   │   ├── Makefile                       # 主Makefile
│   │   └── README.md
│   ├── tb/uvmt/                           # UVM测试台SystemVerilog源码
│   │   ├── uvmt_cv32e40p_tb.sv           # 顶层测试台
│   │   ├── uvmt_cv32e40p_pkg.sv          # UVM包定义
│   │   └── ...
│   └── tests/programs/custom/hello-world/ # 测试程序目录
│       ├── hello-world.c                  # C源程序
│       └── test.yaml                      # 测试配置
├── mk/                                    # 通用Makefile文件
│   ├── uvmt/                              # UVM测试台相关Makefile
│   │   ├── uvmt.mk                        # 通用UVM测试台Makefile
│   │   ├── xrun.mk                        # Cadence Xcelium特定Makefile
│   │   └── ...
│   └── Common.mk                          # 通用定义和规则
└── lib/                                   # 通用验证组件库
```

## 完整执行流程详解

### 第1步：Makefile解析和环境检查

**位置**: `cv32e40p/sim/uvmt/Makefile`

**执行流程**:
```makefile
# 设置核心变量
MAKE_PATH := $(shell dirname $(realpath $(lastword $(MAKEFILE_LIST))))
export CORE_V_VERIF = $(abspath $(MAKE_PATH)/../../..)
export CV_CORE ?= cv32e40p

# 包含外部仓库配置
include ../ExternalRepos.mk
# 包含主要的UVM测试台Makefile
include $(CORE_V_VERIF)/mk/uvmt/uvmt.mk
```

**目的**: 
- 确定项目根目录路径
- 设置核心变量（CV_CORE等）
- 加载外部依赖配置（RTL仓库、第三方工具等）
- 包含主要的测试逻辑

### 第2步：UVM测试台Makefile加载

**位置**: `mk/uvmt/uvmt.mk`

**执行流程**:
```makefile
# 检查必需的环境变量
ifndef CV_CORE
$(error Must set CV_CORE to a valid core)
endif

# 转换为大小写变量
CV_CORE_LC = $(shell echo $(CV_CORE) | tr A-Z a-z)
CV_CORE_UC = $(shell echo $(CV_CORE) | tr a-z A-Z)

# 设置仿真器
CV_SIMULATOR ?= unsim
SIMULATOR ?= $(CV_SIMULATOR)

# 包含通用定义
include $(CORE_V_VERIF)/mk/Common.mk
```

**目的**:
- 验证环境变量设置
- 标准化变量名称（大小写转换）
- 确定使用的仿真器类型
- 加载通用的编译和链接规则

### 第3步：仿真器特定Makefile加载

**位置**: `mk/uvmt/xrun.mk` （以xrun为例）

**执行流程**:
```makefile
# 仿真器可执行文件定义
XRUN = $(CV_SIM_PREFIX) xrun
SIMVISION = $(CV_TOOL_PREFIX) simvision

# 编译标志
XRUN_COMP_FLAGS ?= -64bit \
                   -disable_sem2009 \
                   -access +rwc \
                   -sv \
                   -uvm \
                   -uvmhome $(XRUN_UVMHOME_ARG) \
                   $(TIMESCALE) \
                   $(SV_CMP_FLAGS)

# 运行标志
XRUN_RUN_BASE_FLAGS ?= -64bit $(XRUN_GUI) \
                       +UVM_VERBOSITY=$(XRUN_UVM_VERBOSITY) \
                       -svseed $(RNDSEED)
```

**目的**:
- 定义仿真器特定的编译和运行参数
- 配置SystemVerilog和UVM支持
- 设置调试和波形生成选项

### 第4步：测试配置系统深度解析 📊

> 💡 **类比理解**: 测试配置就像是菜谱和烹饪指南——告诉厨师(测试台)要做什么菜(测试)，用什么材料(程序)，怎么做(参数)。

#### 4.1 测试程序配置文件
**位置**: `cv32e40p/tests/programs/custom/hello-world/test.yaml`

```yaml
# 📛 测试基本信息
name: hello-world                           # 测试名称(必须与目录名一致)
uvm_test: uvmt_cv32e40p_firmware_test_c     # UVM测试类名称
description: >                             # 测试描述
    Simple hello-world sanity test         # 基础功能性测试
```

#### 4.2 全局配置系统 🌐
**位置**: `cv32e40p/tests/cfg/default.yaml`

```yaml
# 🔧 编译器配置 - 告诉SystemVerilog编译器如何编译RTL
name: default                               # 配置名称
description: Default configuration for CV32E40P simulations
compile_flags:                              # SystemVerilog编译标志 
    +define+NO_PULP                         # 禁用PULP扩展指令集

# 🎯 OVP参考模型配置 - 告诉"标准答案"如何表现
ovpsim: >                                   # 多行字符串
    --override root/cpu/misa_Extensions=0x001104  # RISC-V ISA扩展配置
    --override root/cpu/marchid=4               # 架构ID(标识CV32E40P)
    --override root/cpu/noinhibit_mask=0xFFFFFFF0  # 不可禁止的中断掩码
#    --trace --tracechange --traceshowicount --monitornets  # 调试选项(已注释)

# 🔨 C编译器配置 - 告诉GCC如何编译C程序  
cflags: >                                   # C编译参数
    -DNO_PULP                               # 定义NO_PULP宏，禁用PULP特性
```

#### 4.3 Makefile配置处理机制 ⚙️
```makefile
# 📁 测试程序变量解析
TEST_PROGRAM ?= $(TEST)                     # hello-world
TEST_NAME = $(TEST)                        # hello-world 
TEST_UVM_TEST = uvmt_cv32e40p_firmware_test_c  # 从test.yaml解析得出

# 🌐 全局配置解析 (CFG=default 时)
CFG_COMPILE_FLAGS = +define+NO_PULP         # SystemVerilog编译标志
CFG_CFLAGS = -DNO_PULP                     # C编译标志
CFG_OVPSIM = --override root/cpu/misa_Extensions=0x001104 --override root/cpu/marchid=4 --override root/cpu/noinhibit_mask=0xFFFFFFF0

# 📝 结果目录生成
SIM_TEST_RESULTS = $(SIM_CFG_RESULTS)/$(TEST)  # xrun_results/default/hello-world
SIM_RUN_RESULTS = $(SIM_TEST_RESULTS)/$(RUN_INDEX) # .../hello-world/0
```

**配置系统的强大功能**:
- ✅ **多配置支持**: 可以同时维护no_pulp.yaml、pulp.yaml等多套配置
- ✅ **层次化配置**: 全局配置 + 测试特定配置的组合
- ✅ **参数传递**: 从 YAML → Makefile → 仿真器 → C编译器的完整链路
- ✅ **灵活扩展**: 新增测试只需添加目录和test.yaml

### 第5步：依赖项检查和构建

**主要依赖项**:
1. `$(XRUN_SIM_PREREQ)` → `comp` （编译）
2. `hex` （程序二进制文件）
3. `gen_ovpsim_ic` （OVP仿真器配置）

#### 5.1 RTL编译 (comp目标)

**位置**: `mk/uvmt/xrun.mk:297`

**执行流程**:
```makefile
comp: mk_xrun_dir $(CV_CORE_PKG) $(SVLIB_PKG)
	@echo "$(BANNER)"
	@echo "* Compiling xrun in $(SIM_CFG_RESULTS)"
	@echo "$(BANNER)"
	cd $(SIM_CFG_RESULTS) && $(XRUN) \
		$(XRUN_COMP) \
		$(XRUN_ELAB_COV_FLAGS) \
		-top $(RTLSRC_VLOG_TB_TOP) \
		-l xrun.log \
		-elaborate
```

**详细过程**:
1. **创建仿真目录**: `mk_xrun_dir`创建必要的仿真工作目录
2. **检查RTL依赖**: 确保CV32E40P RTL代码已克隆到`$(CV_CORE_PKG)`
3. **编译SystemVerilog**: 
   - 包含RTL源码文件（来自`cv32e40p/rtl/`）
   - 包含测试台文件（来自`cv32e40p/tb/uvmt/`）
   - 编译UVM库和自定义验证组件
4. **顶层模块**: 以`uvmt_cv32e40p_tb`作为顶层测试台

**涉及的主要SystemVerilog文件**:
- `uvmt_cv32e40p_tb.sv`: 顶层测试台模块
- `uvmt_cv32e40p_dut_wrap.sv`: 设计包装器
- `uvmt_cv32e40p_pkg.sv`: UVM包定义

#### 5.2 软件程序编译 (hex目标)

**位置**: `mk/Common.mk:507`

**执行流程**:
```makefile
hex: $(SIM_TEST_PROGRAM_RESULTS)/$(TEST_PROGRAM)$(OPT_RUN_INDEX_SUFFIX).hex

# 实际的编译规则（通过后缀规则定义）
%.elf: %.c
	$(RISCV_EXE_PREFIX)gcc $(RISCV_CFLAGS) \
		-march=$(RISCV_MARCH) -mabi=$(RISCV_MABI) \
		-o $@ $< $(BSP_OBJS) \
		-T $(LINKER_SCRIPT)

%.hex: %.elf
	$(RISCV_EXE_PREFIX)objcopy -O verilog $< $@
```

**详细过程**:
1. **编译C程序**: 
   - 使用RISC-V GCC编译`hello-world.c`
   - 链接Board Support Package (BSP)
   - 应用特定的链接脚本
2. **生成ELF文件**: 包含调试信息的可执行文件
3. **转换为HEX**: 生成Verilog可读的十六进制格式
4. **生成其他格式**: 
   - `.nm`: 符号表文件
   - `.itb`: 指令跟踪文件

**涉及的文件**:
- `hello-world.c`: C源程序
- BSP文件: 启动代码和硬件抽象层
- 链接脚本: 定义内存布局

#### 5.3 OVP仿真器配置 (gen_ovpsim_ic目标)

**位置**: `mk/uvmt/xrun.mk:347`

**执行流程**:
```makefile
gen_ovpsim_ic:
	@rm -f $(SIM_CFG_RESULTS)/$(TEST_NAME)/$(RUN_INDEX)/ovpsim.ic
	@mkdir -p $(SIM_CFG_RESULTS)/$(TEST_NAME)/$(RUN_INDEX)
	@touch -f $(SIM_CFG_RESULTS)/$(TEST_NAME)/$(RUN_INDEX)/ovpsim.ic
	@if [ ! -z "$(CFG_OVPSIM)" ]; then \
		echo "$(CFG_OVPSIM)" > $(SIM_CFG_RESULTS)/$(TEST_NAME)/$(RUN_INDEX)/ovpsim.ic; \
	fi
```

**目的**:
- 为OVP (Open Virtual Platform) 参考模型创建配置文件
- OVP模型用作"金标准"与RTL进行比较
- 配置文件包含处理器特性和仿真参数

### 第6步：UVM测试执行

**位置**: `mk/uvmt/xrun.mk:359`

**主要执行命令**:
```bash
cd $(SIM_RUN_RESULTS) && $(XRUN) \
    -R -xmlibdirname ../../xcelium.d \
    -l xrun-$(TEST_NAME).log \
    $(XRUN_COMP_RUN) \
    $(XRUN_RUN_WAVES_FLAGS) \
    -covtest $(TEST_NAME) \
    $(CFG_PLUSARGS) \
    $(TEST_PLUSARGS) \
    +UVM_TESTNAME=$(TEST_UVM_TEST) \
    +elf_file=$(SIM_TEST_PROGRAM_RESULTS)/$(TEST_PROGRAM)$(OPT_RUN_INDEX_SUFFIX).elf \
    +firmware=$(SIM_TEST_PROGRAM_RESULTS)/$(TEST_PROGRAM)$(OPT_RUN_INDEX_SUFFIX).hex \
    +itb_file=$(SIM_TEST_PROGRAM_RESULTS)/$(TEST_PROGRAM)$(OPT_RUN_INDEX_SUFFIX).itb \
    +nm_file=$(SIM_TEST_PROGRAM_RESULTS)/$(TEST_PROGRAM)$(OPT_RUN_INDEX_SUFFIX).nm
```

**参数详解**:

1. **`-R`**: 运行之前编译好的仿真快照
2. **`-xmlibdirname`**: 指定编译库目录
3. **`-l xrun-hello-world.log`**: 指定日志文件
4. **`+UVM_TESTNAME=uvmt_cv32e40p_firmware_test_c`**: 指定要运行的UVM测试类
5. **`+elf_file=...`**: 传递ELF文件路径给测试台
6. **`+firmware=...`**: 传递HEX文件路径给测试台

### 第7步：UVM测试台初始化

**位置**: `cv32e40p/tb/uvmt/uvmt_cv32e40p_tb.sv`

**执行流程**:

#### 7.1 测试台模块实例化 🏭

> 💡 **类比理解**: 这里就像搭建一个完整的汽车测试台——有被测车辆、模拟器、传感器和控制系统。

```systemverilog
module uvmt_cv32e40p_tb;
    // 🔄 时钟和复位控制接口 - 相当于电源系统
    uvma_clknrst_if     clknrst_if();          // 主时钟和复位信号
    uvma_clknrst_if     clknrst_if_iss();      // ISS(参考模型)专用时钟
    
    // 🎯 被测设计(DUT)的关键接口 - 相当于汽车的各种接口
    uvma_debug_if       debug_if();            // 调试接口(相当于OBD接口)
    uvma_interrupt_if   interrupt_if();        // 中断接口(相当于紧急信号)
    
    // 📦 内存总线接口 - 数据和指令的传输通道
    uvma_obi_memory_if  obi_memory_instr_if(.clk(clknrst_if.clk),
                                            .reset_n(clknrst_if.reset_n)); // 指令获取总线
    uvma_obi_memory_if  obi_memory_data_if (.clk(clknrst_if.clk), 
                                            .reset_n(clknrst_if.reset_n));  // 数据访问总线
    
    // 🏭 DUT包装器实例化 - 相当于汽车本身
    uvmt_cv32e40p_dut_wrap  dut_wrap(
        .clknrst_if(clknrst_if),              // 电源连接  
        .obi_memory_instr_if(obi_memory_instr_if), // 指令存储器连接
        .obi_memory_data_if(obi_memory_data_if),   // 数据存储器连接
        .debug_if(debug_if),                  // 调试端口
        .interrupt_if(interrupt_if)           // 中断信号
    );
    
    // 🏆 参考模型(ISS)实例化 - 相当于标准样车
    uvmt_cv32e40p_iss_wrap  iss_wrap(
        .clknrst_if(clknrst_if_iss),         // 独立的时钟域
        .obi_memory_instr_if(obi_memory_instr_if), // 同步指令访问
        .obi_memory_data_if(obi_memory_data_if)    // 同步数据访问
    );
    
    // 📊 状态监控接口 - 相当于仪表盘
    uvmt_cv32e40p_vp_status_if vp_status_if(
        .tests_passed(tp),    // 测试通过指示灯 🟢
        .tests_failed(tf),    // 测试失败指示灯 🔴  
        .exit_valid(evalid),  // 程序结束信号 
        .exit_value(evalue)   // 退出码(成功=0, 失败!=0)
    );
```

**关键技术点解释**:
- **OBI总线**: OpenHW组织定义的开放总线接口，类似ARM的AHB总线
- **ISS模型**: Instruction Set Simulator，提供指令级的参考实现  
- **Virtual Peripheral**: 虚拟外设，用于测试程序和测试台的通信

#### 7.2 UVM环境初始化 🎆

> 💡 **类比理解**: 这个过程就像是电影导演在开拍前的准备工作——把所有道具、演员、地点都记录在册，然后喊“Action!”开始拍摄。

```systemverilog
initial begin
    // 📝 UVM配置数据库注册 - 相当于电影道具库
    // 注册指令总线接口，让UVM Agent能找到它
    uvm_config_db#(virtual uvma_obi_memory_if)::set(
        null,                           // 从根节点开始
        "*.env.*instr*agent*",         // 指令Agent的路径模式
        "vif",                         // 接口关键字
        obi_memory_instr_if            // 实际接口句柄
    );
    
    // 注册数据总线接口
    uvm_config_db#(virtual uvma_obi_memory_if)::set(
        null, 
        "*.env.*data*agent*", 
        "vif", 
        obi_memory_data_if
    );
    
    // 注册调试接口
    uvm_config_db#(virtual uvma_debug_if)::set(
        null,
        "*.env.*debug*agent*", 
        "vif", 
        debug_if
    );
    
    // 注册中断接口 
    uvm_config_db#(virtual uvma_interrupt_if)::set(
        null,
        "*.env.*interrupt*agent*",
        "vif",
        interrupt_if
    );
    
    // 🎦 启动UVM测试 - 相当于导演喊"Action!"
    run_test();  // 这个函数会根据+UVM_TESTNAME参数创建指定的测试类
end
```

**技术详解**:
- **uvm_config_db**: UVM的全局配置数据库，类似一个全局的“电话簿”
- **路径模式**: `"*.env.*instr*agent*"`用通配符匹配所有相关的Agent
- **virtual interface**: SystemVerilog的虚拟接口，允许类和模块之间传递接口句柄

### 第8步：UVM测试类执行

**位置**: UVM测试包中的`uvmt_cv32e40p_firmware_test_c`类

**执行流程**:

#### 8.1 构建阶段 (build_phase)
```systemverilog
class uvmt_cv32e40p_firmware_test_c extends uvmt_cv32e40p_base_test_c;
    
    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        // 配置测试环境
        uvm_config_db#(string)::set(null, "*", "elf_file", elf_file_path);
        uvm_config_db#(string)::set(null, "*", "firmware_file", firmware_path);
        
        // 创建环境组件
        env = uvmt_cv32e40p_env_c::type_id::create("env", this);
    endfunction
```

#### 8.2 运行阶段 (run_phase)
```systemverilog
virtual task run_phase(uvm_phase phase);
    super.run_phase(phase);
    
    phase.raise_objection(this);
    
    // 加载程序到内存
    load_program_to_memory();
    
    // 启动处理器
    start_processor();
    
    // 等待程序执行完成
    wait_for_completion();
    
    phase.drop_objection(this);
endtask
```

### 第9步：程序加载和执行

#### 9.1 内存加载
- **Virtual Sequencer**读取hex文件
- 通过**Memory Agent**将程序加载到仿真内存
- 设置程序计数器到入口地址

#### 9.2 处理器启动
- 释放复位信号
- CV32E40P开始从程序入口执行指令
- OVP参考模型同步执行相同程序

#### 9.3 指令执行监控
- **Instruction Monitor**捕获每条执行的指令
- **Data Monitor**监控内存访问
- **Step-and-Compare**机制比较RTL和参考模型的执行结果

### 第10步：结果验证和报告

#### 10.1 实时比较
- 每个时钟周期比较RTL和参考模型的状态
- 检查寄存器文件、内存状态、程序计数器等
- 发现不匹配时立即报告错误

#### 10.2 最终检查
- 程序正常结束检查
- 输出结果验证（如hello-world的打印输出）
- 性能计数器检查

#### 10.3 测试报告生成
```
UVM_INFO @ 0: reporter [RNTST] Running test uvmt_cv32e40p_firmware_test_c...
UVM_INFO @ 0: uvm_test_top.env [ENV] Loading firmware: hello-world.hex
UVM_INFO @ 0: uvm_test_top.env.step_compare [STEPCMP] Starting step-and-compare
UVM_INFO @ 1000: uvm_test_top.env [ENV] Program execution started
UVM_INFO @ 5000: uvm_test_top.env [ENV] Hello World! printed to console
UVM_INFO @ 6000: uvm_test_top.env [ENV] Program execution completed successfully
UVM_INFO @ 6000: uvm_test_top.env.step_compare [STEPCMP] 1234 instructions compared, 0 mismatches
```

## 文件和目录详解

### 关键SystemVerilog文件

1. **`uvmt_cv32e40p_tb.sv`**: 顶层测试台，连接所有组件
2. **`uvmt_cv32e40p_pkg.sv`**: 包含所有UVM类定义
3. **`uvmt_cv32e40p_dut_wrap.sv`**: DUT包装器，连接接口信号
4. **`uvmt_cv32e40p_iss_wrap.sv`**: 参考模型包装器

### 关键脚本和工具

1. **Makefile链**: 控制整个构建和仿真过程
2. **RISC-V工具链**: 编译C程序为RISC-V机器码
3. **Xcelium仿真器**: 执行SystemVerilog仿真
4. **OVP模型**: 提供指令级精确的参考模型

### 生成的输出文件

1. **日志文件**: `xrun-hello-world.log`
2. **波形文件**: `waves.shm/` (如果启用WAVES=1)
3. **覆盖率数据**: `.cov` 文件 (如果启用COV=1)
4. **程序文件**: `.elf`, `.hex`, `.nm`, `.itb`

## 常见问题排查

### 环境变量问题
```bash
# 检查环境变量
make vars

# 常见错误和解决方案
export CV_SIMULATOR=xrun    # 必须指定仿真器
export CV_CORE=cv32e40p     # 必须指定核心类型
```

### 编译问题
```bash
# 清理重新编译
make clean_all
make comp

# 查看编译日志
cat xcelium.d/xrun.log
```

### 仿真问题
```bash
# 启用调试模式
make test TEST=hello-world GUI=1

# 查看详细UVM日志
make test TEST=hello-world USER_RUN_FLAGS=+UVM_VERBOSITY=UVM_DEBUG
```

## 扩展阅读

1. **UVM用户指南**: 了解UVM测试台架构
2. **CV32E40P规格书**: 了解处理器特性
3. **SystemVerilog语言手册**: 理解测试台实现
4. **RISC-V指令集手册**: 理解处理器行为

这个详细的执行流程说明了从简单的`make test TEST=hello-world`命令开始，整个复杂的验证系统是如何协调工作的，包括Makefile系统、软件编译、硬件仿真、UVM验证环境以及结果验证等各个方面。